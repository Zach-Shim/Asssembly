0000107E Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/15/2021 1:55:52 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00000000                            11              
00001000                            12              ORG     $1000
00001000                            13  
00001000  =0000000D                 14  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 15  LF          EQU     $0A 
00001000                            16  
00001000= 50 6C 65 61 73 65 ...     17  startMsg:   DC.B    'Please enter a starting address ', CR, LF, 0
00001023= 50 6C 65 61 73 65 ...     18  endMsg:     DC.B    'Please enter an ending address ', CR, LF, 0
00001045= 65 78 69 74 69 6E ...     19  doneMsg:    DC.B    'exiting...', CR, LF, 0
00001052= 49 6E 76 61 6C 69 ...     20  badInput:   DC.B    'Invalid Input', CR, LF, 0
00001062= 0D 0A 00                  21  newline:    DC.B    '', CR, LF, 0
00001065                            22  
00001066                            23  userAddr:   DS.L    1
0000106A                            24  startAddr:  DS.L    1
0000106E                            25  endAddr:    DS.L    1
00001072                            26  
00001072                            27  opOutput:   DS.L    2
0000107A                            28  
0000107A                            29  opcode:     DS.W    1   
0000107C                            30  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
0000107D                            31  valid:      DS.B    1
0000107E                            32  
0000107E                            33  
0000107E                            34  
0000107E                            35  
0000107E                            36  
0000107E                            37  
0000107E                            38  *-----------------------------------------------------------
0000107E                            39  * Macros:
0000107E                            40  *-----------------------------------------------------------
0000107E                            41  
0000107E                            42  PRINT_MSG:  MACRO 
0000107E                            43              CLR.L   D0
0000107E                            44              LEA     \1, A1      ; \1 acts as a parameter
0000107E                            45              MOVE.B  #14, D0     
0000107E                            46              TRAP    #15
0000107E                            47              ENDM
0000107E                            48  
0000107E                            49  CLR_D_REGS: MACRO
0000107E                            50              CLR.L   D0
0000107E                            51              CLR.L   D1
0000107E                            52              CLR.L   D2
0000107E                            53              CLR.L   D3
0000107E                            54              CLR.L   D4
0000107E                            55              CLR.L   D5
0000107E                            56              CLR.L   D6
0000107E                            57              CLR.L   D7
0000107E                            58              ENDM
0000107E                            59  
0000107E                            60  CLR_A_REG:  MACRO
0000107E                            61              CLR.L   \1
0000107E                            62              MOVE.L  \1, \2
0000107E                            63              ENDM              
0000107E                            64  
0000107E                            65  *-----------------------------------------------------------
0000107E                            66  * \1 should be highest bit in range
0000107E                            67  * \2 should be lowest bit in range
0000107E                            68  * Result will be returned in D4
0000107E                            69  * Example: #11, #9
0000107E                            70  *
0000107E                            71  * Return Value:
0000107E                            72  *   D4 = value held within bits \1 and \2
0000107E                            73  *
0000107E                            74  * Registers:
0000107E                            75  *   D4 = holds opcode
0000107E                            76  *   D5 = highest bit in range 
0000107E                            77  *   D6 = lowest bit in range 
0000107E                            78  *   D7 = number of bits we want
0000107E                            79  *-----------------------------------------------------------
0000107E                            80  GET_BITS:   MACRO
0000107E                            81  
0000107E                            82              CLR_D_REGS
0000107E                            83  
0000107E                            84              * Subtract value to find amount to shift by 
0000107E                            85              ADD.B   \1, D7          
0000107E                            86              SUB.B   \2, D7 
0000107E                            87              ADD.B   #1, D7  * add 1 because we start our count from 0
0000107E                            88  
0000107E                            89              * Get high bit offset
0000107E                            90              ADD.B   #15, D5
0000107E                            91              SUB.B   \1, D5
0000107E                            92              
0000107E                            93              * shift out high bits
0000107E                            94              MOVE.W  opcode, D4
0000107E                            95              LSL.W   D5, D4
0000107E                            96              
0000107E                            97              *get low bit offset
0000107E                            98              *16 - NUMBER OF BITS WE WANT
0000107E                            99              ADD.B   #16, D6         * 16 total bits
0000107E                           100              SUB.L   D7, D6          * subtract numBits from 16
0000107E                           101              
0000107E                           102              * shift out low bits
0000107E                           103              LSR.W   D6, D4          * isolate bits
0000107E                           104              ENDM
0000107E                           105  
0000107E                           106  *----------------------TO BUFFER----------------------------
0000107E                           107  * Description:
0000107E                           108  * Converts a Hex numbered address (1-9 or A-F) back to an
0000107E                           109  * ASCII value and pushes it to the buffer for printing
0000107E                           110  *
0000107E                           111  * Parameters:
0000107E                           112  *   \1 = should hold value (in hex) you want to push to the buffer
0000107E                           113  *-----------------------------------------------------------
0000107E                           114  TO_BUFFER:  MACRO
0000107E                           115              MOVE.L  \1, D2  
0000107E                           116              JSR     NUMBER_OR_LETTER
0000107E                           117              ENDM
0000107E                           118  *-----------------------------------------------------------
0000107E                           119  
0000107E                           120  
0000107E                           121  *-----------------------------------------------------------
0000107E                           122  * Description:  
0000107E                           123  * Main routine
0000107E                           124  *-----------------------------------------------------------
0000107E                           125  
0000107E                           126  *-------------------------MAIN------------------------------
0000107E                           127  MAIN:
0000107E  6100 0006                128              BSR     GET_INPUT
00001082  6000 019C                129              BRA     LOAD_ADDRESSES
00001086                           130  *-----------------------------------------------------------
00001086                           131  
00001086                           132  
00001086                           133  
00001086                           134  
00001086                           135  
00001086                           136  
00001086                           137  
00001086                           138  
00001086                           139  *-----------------------------------------------------------
00001086                           140  * Description:  
00001086                           141  * Get User Input
00001086                           142  *
00001086                           143  * Registers Used:
00001086                           144  *   D0 = task values
00001086                           145  *   D1 = stores of size of ascii string in A1 from user input
00001086                           146  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
00001086                           147  *   A1 = stores an ascii string from user input
00001086                           148  *-----------------------------------------------------------
00001086                           149  *-------------------------Get Input-------------------------
00001086                           150  GET_INPUT:
00001086  B87C 0000                151              CMP      #0, D4
0000108A  6700 000C                152              BEQ      GET_START_ADDRESS
0000108E                           153                 
0000108E  21C6 106A                154              MOVE.L   D6, startAddr
00001092  21C7 106E                155              MOVE.L   D7, endAddr
00001096  4E75                     156              RTS 
00001098                           157  *-----------------------------------------------------------
00001098                           158  
00001098                           159  *----------------------Get Starting Address-----------------
00001098                           160  GET_START_ADDRESS:
00001098  4280                     161              CLR.L   D0
0000109A  43F8 1000                162              LEA.L   startMsg, A1      
0000109E  103C 000E                163              MOVE.B  #14, D0     
000010A2  4E4F                     164              TRAP    #15
000010A4                           165  
000010A4  43F8 1066                166              LEA.L   userAddr, A1
000010A8  103C 0002                167              MOVE.B  #2, D0
000010AC  4E4F                     168              TRAP    #15
000010AE                           169              ;MOVE.B  D1, startSize
000010AE  6000 001C                170              BRA     VALIDATE_INPUT
000010B2                           171  *-----------------------------------------------------------
000010B2                           172  
000010B2                           173  *----------------------Get Ending Address-------------------
000010B2                           174  GET_END_ADDRESS:
000010B2  4280                     175              CLR.L   D0
000010B4  43F8 1023                176              LEA.L   endMsg, A1      
000010B8  103C 000E                177              MOVE.B  #14, D0     
000010BC  4E4F                     178              TRAP    #15
000010BE                           179  
000010BE  43F8 1066                180              LEA.L   userAddr, A1
000010C2  103C 0002                181              MOVE.B  #2, D0
000010C6  4E4F                     182              TRAP    #15
000010C8                           183              ;MOVE.B  D1, endSize
000010C8  6000 0012                184              BRA     CHECK_LENGTH
000010CC                           185  *-----------------------------------------------------------
000010CC                           186  
000010CC                           187  
000010CC                           188  
000010CC                           189  
000010CC                           190  
000010CC                           191  
000010CC                           192  
000010CC                           193  
000010CC                           194  
000010CC                           195  
000010CC                           196  *-----------------------------------------------------------
000010CC                           197  * Description:  Validate User Input
000010CC                           198  * Constraints:  
000010CC                           199  *   User input must be:
000010CC                           200  *   Length 4 or Length 8
000010CC                           201  *   ASCII character 0-9 or A-F
000010CC                           202  *   Starting and ending address with value < $00FFFFFF 
000010CC                           203  *   Starting address is before ending address
000010CC                           204  *
000010CC                           205  * Registers Used:
000010CC                           206  *   D0 = task values
000010CC                           207  *   D1 = stores of size of ascii string in A1 from user input
000010CC                           208  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000010CC                           209  *   A1 = stores an ascii string from user input
000010CC                           210  *-----------------------------------------------------------
000010CC                           211  
000010CC                           212  *----------------------VALIDATE INPUT---------------------------      
000010CC                           213  
000010CC                           214  VALIDATE_INPUT:        
000010CC  B83C 0000                215              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
000010D0  6700 000A                216              BEQ        CHECK_LENGTH         ; if equal, parse START address 
000010D4  B83C 0001                217              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
000010D8  67D8                     218              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
000010DA  60AA                     219              BRA        GET_INPUT            ; done parsing, D4 = 2
000010DC                           220  
000010DC                           221  CHECK_LENGTH:
000010DC  B23C 0004                222              CMP.B      #4, D1               ; for task 2, length of string is in D1                
000010E0  6700 002C                223              BEQ        CONVERT_TO_HEX 
000010E4  B23C 0008                224              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
000010E8  6700 0024                225              BEQ        CONVERT_TO_HEX
000010EC  6000 0002                226              BRA        INVALID_INPUT
000010F0                           227  
000010F0                           228  INVALID_INPUT:  
000010F0  4283                     229              CLR.L      D3
000010F2                           230m             PRINT_MSG  badInput
000010FE  B83C 0000                231              CMP.B      #0, D4 
00001102  6794                     232              BEQ        GET_START_ADDRESS  
00001104  B83C 0001                233              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001108  67A8                     234              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
0000110A  6000 FF72                235              BRA        MAIN
0000110E                           236  *-----------------------------------------------------------
0000110E                           237  
0000110E                           238  *----------------CONVERT FROM ASCII TO HEX------------------
0000110E                           239  CONVERT_TO_HEX:
0000110E  0C11 0030                240              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001112  6DDC                     241              BLT        INVALID_INPUT        
00001114                           242  
00001114  0C11 003A                243              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001118  6D00 0012                244              BLT        NUM_TO_HEX      
0000111C                           245  
0000111C  0C11 0041                246              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001120  6DCE                     247              BLT        INVALID_INPUT             
00001122                           248  
00001122  0C11 0047                249              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001126  6D00 000C                250              BLT        LETTER_TO_HEX
0000112A                           251  
0000112A  60C4                     252              BRA        INVALID_INPUT    
0000112C                           253  
0000112C                           254  NUM_TO_HEX:      
0000112C  0411 0030                255              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001130  6000 000A                256              BRA        STORE_CHAR   
00001134                           257  
00001134                           258  LETTER_TO_HEX:     
00001134  0411 0037                259              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001138  6000 0002                260              BRA        STORE_CHAR
0000113C                           261  
0000113C                           262  STORE_CHAR:       
0000113C  D619                     263              ADD.B     (A1)+, D3            ; keep hex stored in D3           
0000113E  6000 0002                264              BRA        ITERATE                 
00001142                           265  
00001142                           266  ITERATE:
00001142  5301                     267              SUB.B      #$1, D1
00001144  B23C 0000                268              CMP.B      #0, D1
00001148  6700 0006                269              BEQ        STORE_INPUT
0000114C                           270  
0000114C  E98B                     271              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000114E  60BE                     272              BRA        CONVERT_TO_HEX
00001150                           273  
00001150                           274  STORE_INPUT:
00001150  B83C 0000                275              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
00001154  6700 000A                276              BEQ        STORE_START          ; if equal, parse START address 
00001158                           277              
00001158  B83C 0001                278              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
0000115C  6700 000C                279              BEQ        STORE_END         
00001160                           280  
00001160                           281  STORE_START:
00001160  2C03                     282              MOVE.L     D3, D6
00001162  5204                     283              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001164                           284              
00001164  4243                     285              CLR         D3
00001166  6000 FF64                286              BRA         VALIDATE_INPUT
0000116A                           287  
0000116A                           288  STORE_END:
0000116A  2E03                     289              MOVE.L     D3, D7
0000116C  5204                     290              ADD.B      #1, D4               ; value to indicate if we are done parsing
0000116E                           291  
0000116E  4243                     292              CLR         D3
00001170  6000 FF5A                293              BRA         VALIDATE_INPUT
00001174                           294  *-----------------------------------------------------------
00001174                           295  
00001174                           296  
00001174                           297  
00001174                           298  
00001174                           299  
00001174                           300  
00001174                           301  
00001174                           302  
00001174                           303  
00001174                           304  
00001174                           305  
00001174                           306  *--------------------------PRINT----------------------------
00001174                           307  * Description:
00001174                           308  * Prints hex addresses according to where we are in the .S file
00001174                           309  * and source/destination effective addresses
00001174                           310  *
00001174                           311  * No Parameters
00001174                           312  *
00001174                           313  * Registers:
00001174                           314  *   D0 = used for tasks and trap #15
00001174                           315  *   D1 = size of comparison
00001174                           316  *   D2 = destination for comparisons, holds an address
00001174                           317  *   D3 = iterator
00001174                           318  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001174                           319  *   A2 = current address (given by user)
00001174                           320  *-----------------------------------------------------------
00001174                           321  
00001174                           322  *----------------------PRINT_ADDRESS------------------------
00001174                           323  PRINT_ADDRESS:
00001174                           324              * reset A1 to beginning of string
00001174                           325m             CLR_D_REGS
00001184                           326m             CLR_A_REG D0, A1
00001188                           327              
00001188                           328              * move current address to D2
00001188  240A                     329              MOVE.L    A2, D2
0000118A                           330  
0000118A                           331              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
0000118A  223C 00008000            332              MOVE.L    #$8000, D1
00001190  B481                     333              CMP.L     D1, D2
00001192  6D00 000E                334              BLT       PRINT_WORD
00001196                           335              
00001196                           336              * if absolute long, print long. Range $8000 - $FFFF7FFF
00001196  223C FFFF8000            337              MOVE.L    #$FFFF8000, D1
0000119C  B481                     338              CMP.L     D1, D2
0000119E  6C00 0022                339              BGE       PRINT_LONG                 
000011A2                           340  
000011A2                           341  PRINT_WORD:
000011A2                           342m             CLR_D_REGS
000011B2  123C 0001                343              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000011B6  3E0A                     344              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000011B8  4EB9 00001AD4            345              JSR       HEX_TO_ASCII
000011BE  6000 0022                346              BRA       FINISH_PRINT
000011C2                           347  
000011C2                           348  PRINT_LONG:
000011C2                           349m             CLR_D_REGS
000011D2  123C 0003                350              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
000011D6  2E0A                     351              MOVE.L    A2, D7
000011D8  4EB9 00001AD4            352              JSR       HEX_TO_ASCII
000011DE  6000 0002                353              BRA       FINISH_PRINT
000011E2                           354  
000011E2                           355  FINISH_PRINT:
000011E2                           356              * print out string
000011E2  12BC 0000                357              MOVE.B    #00,(A1)
000011E6                           358m             CLR_D_REGS
000011F6                           359m             CLR_A_REG D0, A1
000011FA  103C 000E                360              MOVE.B    #14, D0
000011FE  4E4F                     361              TRAP      #15
00001200  4E75                     362              RTS
00001202                           363  *-----------------------------------------------------------
00001202                           364  
00001202                           365  *-------------------PRINT_INSTRUCTION-----------------------
00001202                           366  PRINT_INSTRUCTION:    
00001202                           367              * null terminator
00001202  12BC 0000                368              MOVE.B    #00,(A1)              
00001206                           369  
00001206                           370              * reset A1 to beginning of string
00001206  4280                     371              CLR.L     D0
00001208                           372m             CLR_A_REG D0, A1
0000120C                           373  
0000120C                           374              * print out string
0000120C  103C 000E                375              MOVE.B    #14, D0
00001210  4E4F                     376              TRAP      #15
00001212                           377  
00001212                           378m             PRINT_MSG newline
0000121E  4E75                     379              RTS
00001220                           380  *-----------------------------------------------------------
00001220                           381  
00001220                           382  
00001220                           383  
00001220                           384  
00001220                           385  
00001220                           386  
00001220                           387  
00001220                           388  
00001220                           389  
00001220                           390  
00001220                           391  
00001220                           392  
00001220                           393  
00001220                           394  
00001220                           395  
00001220                           396  
00001220                           397  
00001220                           398  
00001220                           399  
00001220                           400  
00001220                           401  *---------------------LOAD ADDRESSES------------------------
00001220                           402  * Description:
00001220                           403  * Stores INITIAL values into appropriate address registers 
00001220                           404  * which is necessary to complete before starting identify opcodes loop
00001220                           405  * Also pushes reigsters onto the stack
00001220                           406  *
00001220                           407  * No Parameters
00001220                           408  *
00001220                           409  * Registers:
00001220                           410  *   A2 = current address (given by user)
00001220                           411  *   A3 = ending address (given by user)
00001220                           412  *-----------------------------------------------------------
00001220                           413  LOAD_ADDRESSES: 
00001220                           414              * reset A1 to beginning of string
00001220  4280                     415              CLR.L     D0
00001222                           416m             CLR_A_REG D0, A1
00001226                           417  
00001226                           418              * load start and end registers and print starting address
00001226  2478 106A                419              MOVEA.L startAddr, A2
0000122A  2678 106E                420              MOVEA.L endAddr, A3
0000122E  6100 FF44                421              BSR     PRINT_ADDRESS
00001232  4EB9 00001B40            422              JSR     INSERT_SPACE
00001238                           423          
00001238  6100 0042                424              BSR     GRAB_NEXT_WORD
0000123C  6100 0044                425              BSR     GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
00001240                           426  
00001240                           427              * Push current registers onto the stack (so we can have fresh registers)
00001240  48E7 FF00                428              MOVEM.L D0-D7,-(SP)              ; move the old registers onto the stack
00001244  6000 004E                429              BRA     FIND_OPCODE
00001248                           430  *-----------------------------------------------------------
00001248                           431  
00001248                           432  *-----------------------------------------------------------
00001248                           433  * Description:  IDENTIFY OPCODES LOOP
00001248                           434  * Registers:
00001248                           435  *   D0 = used for tasks and trap #15
00001248                           436  *   D1 = size of shifting bits
00001248                           437  *   D2 = destination for shifts
00001248                           438  *   D3 = size of opcode
00001248                           439  *   D4 = used to hold bits returned from SHIFT macro
00001248                           440  *   D7 = holds address (word in length)
00001248                           441  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001248                           442  *   A2 = current address (given by user)
00001248                           443  *   A3 = ending address (given by user)
00001248                           444  *-----------------------------------------------------------
00001248                           445  *-------------------IDENTIFY OPCODES------------------------
00001248                           446  * evaluates an opcode based on first four bits (aka opTag)
00001248                           447  * for now only works with one instruction
00001248                           448  *-----------------------------------------------------------
00001248                           449  IDENTIFY_OPCODE:
00001248                           450  
00001248                           451              * print opcode
00001248  61B8                     452              BSR     PRINT_INSTRUCTION
0000124A                           453  
0000124A                           454              * check if starting address >= ending address
0000124A  B5CB                     455              CMPA.L  A3, A2
0000124C  6C00 0932                456              BGE     DONE
00001250                           457              
00001250                           458              * print next address
00001250  6100 FF22                459              BSR     PRINT_ADDRESS
00001254  4EB9 00001B40            460              JSR     INSERT_SPACE
0000125A                           461              
0000125A                           462              ;BSR     RESTORE_REGS           need to fix
0000125A                           463  
0000125A                           464m             CLR_D_REGS
0000126A  6100 0010                465              BSR     GRAB_NEXT_WORD          * grab opcode
0000126E  6100 0012                466              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
00001272                           467             
00001272  6000 0020                468              BRA     FIND_OPCODE
00001276                           469  *------------------------------------------------------------
00001276                           470  
00001276                           471  *----------------------RESTORE_REGS--------------------------
00001276                           472  * Description:
00001276                           473  * Move the old registers onto the stack
00001276                           474  *------------------------------------------------------------
00001276                           475  RESTORE_REGS:
00001276  4CDF 00FF                476              MOVEM.L (SP)+, D0-D7            
0000127A  4E75                     477              RTS
0000127C                           478  *-----------------------------------------------------------
0000127C                           479  
0000127C                           480  *---------Useful Subroutines For Identifying Opcodes--------
0000127C                           481  GRAB_NEXT_WORD:
0000127C                           482              * load current word of bits into D7
0000127C  31DA 107A                483              MOVE.W (A2)+, opcode
00001280  4E75                     484              RTS
00001282                           485  
00001282                           486  GRAB_FIRST_FOUR_BITS:
00001282                           487              * find first four bits of opcode
00001282  3438 107A                488              MOVE.W  opcode, D2
00001286  123C 000C                489              MOVE.B  #12, D1
0000128A  E2AA                     490              LSR.L   D1, D2
0000128C  1002                     491              MOVE.B  D2, D0
0000128E  11C0 107C                492              MOVE.B  D0, opTag
00001292  4E75                     493              RTS
00001294                           494  *-----------------------------------------------------------
00001294                           495  
00001294                           496  
00001294                           497  
00001294                           498  
00001294                           499  
00001294                           500  
00001294                           501  
00001294                           502  
00001294                           503  
00001294                           504  *----------------------FIND OPCODE--------------------------
00001294                           505  * Description:
00001294                           506  * Finds a matching opTag (first four bits of opcode) and 
00001294                           507  * jumps to that opcode's encoding subroutine
00001294                           508  *
00001294                           509  * For example:
00001294                           510  *               ADD's first four bits = 1101, so I put
00001294                           511  *               CMP.B #%1101, D0
00001294                           512  *
00001294                           513  * No Parameters
00001294                           514  *
00001294                           515  * No Registers Used
00001294                           516  *-----------------------------------------------------------        
00001294                           517  FIND_OPCODE:
00001294  0C38 0000 107C           518              CMP.B   #%0000, opTag 
0000129A  6700 0052                519              BEQ     OPC_0000
0000129E                           520  
0000129E  0C38 0004 107C           521              CMP.B   #%0100, opTag 
000012A4  6700 012A                522              BEQ     OPC_0100
000012A8                           523  
000012A8  0C38 0005 107C           524              CMP.B   #%0101, opTag 
000012AE  6700 0254                525              BEQ     OPC_0101
000012B2                           526  
000012B2  0C38 0008 107C           527              CMP.B   #%1000, opTag
000012B8  6700 0220                528              BEQ     OPC_1000
000012BC                           529  
000012BC  0C38 0009 107C           530              CMP.B   #%1001, opTag
000012C2  6700 0334                531              BEQ     OPC_1001
000012C6                           532  
000012C6  0C38 000C 107C           533              CMP.B   #%1100, opTag
000012CC  6700 033E                534              BEQ     OPC_1100
000012D0                           535  
000012D0  0C38 000D 107C           536              CMP.B   #%1101, opTag
000012D6  6700 03A4                537              BEQ     OPC_1101
000012DA                           538              
000012DA  0C38 000E 107C           539              CMP.B   #%1110, opTag
000012E0  6700 03AE                540              BEQ     OPC_1110
000012E4                           541  
000012E4                           542              * error, bad opcode
000012E4  6000 0002                543              BRA      BAD_OPCODE
000012E8                           544  
000012E8                           545  *-----------------------------------------------------------
000012E8                           546  
000012E8                           547  *-----------------------BAD OPCODE--------------------------
000012E8                           548  BAD_OPCODE:
000012E8  4EF9 00001B80            549              JMP      DONE
000012EE                           550  *-----------------------------------------------------------
000012EE                           551  
000012EE                           552  *------------------------OPC_0000---------------------------
000012EE                           553  * First four bits = 0000
000012EE                           554  * (ADDI, SUBI)
000012EE                           555  *-----------------------------------------------------------
000012EE                           556  OPC_0000:
000012EE                           557m             GET_BITS  #11, #8
000012FE                           558m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001306                           559m             * GET HIGH BIT OFFSET
0000130E                           560m             * SHIFT OUT HIGH BITS
00001314                           561m             *GET LOW BIT OFFSET
00001314                           562m             *16 - NUMBER OF BITS WE WANT
0000131A                           563m             * SHIFT OUT LOW BITS
0000131C                           564              
0000131C                           565              * is the opcode ADDI?
0000131C  B83C 0006                566              CMP.B     #%0110, D4
00001320  6700 000E                567              BEQ       OPC_ADDI
00001324                           568  
00001324                           569              * is the opcode SUBI?
00001324  B83C 0004                570              CMP.B     #%0100, D4
00001328  6700 001E                571              BEQ       OPC_SUBI
0000132C                           572  
0000132C  4EF8 12E8                573              JMP       BAD_OPCODE
00001330                           574  
00001330                           575  *------------------------OPC_ADDI---------------------------
00001330                           576  OPC_ADDI:
00001330  12FC 0041                577              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001334  12FC 0044                578              MOVE.B  #'D',(A1)+
00001338  12FC 0044                579              MOVE.B  #'D',(A1)+
0000133C  12FC 0049                580              MOVE.B  #'I',(A1)+
00001340  12FC 002E                581              MOVE.B  #'.',(A1)+
00001344                           582  
00001344  6100 001A                583              BSR     DECODE_IMMEDIATE
00001348                           584  
00001348                           585  *------------------------OPC_SUBI---------------------------
00001348                           586  OPC_SUBI:            
00001348  12FC 0053                587              MOVE.B  #'S',(A1)+          * Put ADD into Buff
0000134C  12FC 0055                588              MOVE.B  #'U',(A1)+
00001350  12FC 0042                589              MOVE.B  #'B',(A1)+
00001354  12FC 0049                590              MOVE.B  #'I',(A1)+
00001358  12FC 002E                591              MOVE.B  #'.',(A1)+
0000135C                           592  
0000135C  6100 0002                593              BSR     DECODE_IMMEDIATE
00001360                           594  
00001360                           595  *--------------Subroutines for OPC_0000---------------------  
00001360                           596  DECODE_IMMEDIATE:
00001360                           597              * push size to buffer
00001360                           598m             GET_BITS #7, #6              * get size bits (gets returned to D4)
00001370                           599m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001376                           600m             * GET HIGH BIT OFFSET
0000137C                           601m             * SHIFT OUT HIGH BITS
00001382                           602m             *GET LOW BIT OFFSET
00001382                           603m             *16 - NUMBER OF BITS WE WANT
00001388                           604m             * SHIFT OUT LOW BITS
0000138A  3604                     605              MOVE     D4, D3              * load parameter for SIZE_TO_BUFFER
0000138C  4EB9 00001B46            606              JSR      SIZE_TO_BUFFER      * put operation size in buffer
00001392                           607  
00001392                           608              * push #<data> to buffer
00001392  4EB9 000013AC            609              JSR     CHECK_IMMEDIATE
00001398                           610  
00001398                           611              * push <ea> to buffer
00001398  12FC 002C                612              MOVE.B  #',',(A1)+
0000139C  4EB9 00001B40            613              JSR     INSERT_SPACE
000013A2  4EB9 0000196A            614              JSR     GET_EA_MODE
000013A8  6000 FE9E                615              BRA     IDENTIFY_OPCODE
000013AC                           616   
000013AC                           617  CHECK_IMMEDIATE:
000013AC  12FC 0023                618              MOVE.B  #'#', (A1)+
000013B0                           619  
000013B0  B67C 0001                620              CMP     #1, D3
000013B4  6F00 000A                621              BLE     IMMEDIATE_WORD
000013B8                           622  
000013B8  B67C 0002                623              CMP     #2, D3
000013BC  6000 000A                624              BRA     IMMEDIATE_LONG
000013C0                           625  
000013C0                           626  IMMEDIATE_WORD:
000013C0  4EB9 00001A9E            627              JSR     EA_WORD
000013C6  4E75                     628              RTS
000013C8                           629  
000013C8                           630  IMMEDIATE_LONG:
000013C8  4EB9 00001AB2            631              JSR     EA_LONG      
000013CE  4E75                     632              RTS
000013D0                           633  *-----------------------------------------------------------
000013D0                           634  
000013D0                           635  
000013D0                           636  *------------------------OPC_0100---------------------------
000013D0                           637  * First four bits = 0100
000013D0                           638  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
000013D0                           639  *-----------------------------------------------------------
000013D0                           640  OPC_0100:
000013D0                           641  
000013D0                           642              * Check if the opcode is NOP
000013D0  3438 107A                643              MOVE.W  opcode, D2              * Copy opcode to D2
000013D4  B47C 4E71                644              CMP.W   #$4E71, D2              * Check if D2 is equal to NOP (0x4E71 in hex)
000013D8  6700 0054                645              BEQ     OPC_NOP                 * If equal branch to label to handle the opcode NOP
000013DC                           646              
000013DC                           647              * Check if the opcode is NOT
000013DC  E082                     648              ASR.L   #8, D2                  * Shift bits to compare
000013DE  B43C 0046                649              CMP.B   #%01000110, D2
000013E2  6700 005A                650              BEQ     OPC_NOT
000013E6  4282                     651              CLR.L   D2
000013E8                           652              
000013E8                           653              * Check if the opcode is LEA
000013E8  3838 107A                654              MOVE.W   opcode, D4             * Put opcode in D4 to use the macro get bits
000013EC                           655m             GET_BITS #8, #6 
000013FC                           656m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001402                           657m             * GET HIGH BIT OFFSET
00001408                           658m             * SHIFT OUT HIGH BITS
0000140E                           659m             *GET LOW BIT OFFSET
0000140E                           660m             *16 - NUMBER OF BITS WE WANT
00001414                           661m             * SHIFT OUT LOW BITS
00001416  B83C 0007                662              CMP.B   #%0111, D4              * if bits 6-8 are equal to 111, then the opocde is LEA
0000141A  6700 005E                663              BEQ     OPC_LEA
0000141E                           664  
0000141E                           665              * Check if the opcode is JSR
0000141E  B83C 0002                666              CMP.B   #%0010, D4              * if bits 6-8 are equal to 010, then the opocde is LEA
00001422  6700 008A                667              BEQ     OPC_JSR
00001426                           668  
00001426                           669              * Check if the opcode is RTS
00001426  B83C 0001                670              CMP.B   #%0001, D4              * if bits 6-8 are equal to 001, then the opocde is LEA
0000142A  6700 009E                671              BEQ     OPC_RTS
0000142E                           672  
0000142E                           673  *---------------------------OPC_NOP--------------------------------
0000142E                           674  
0000142E                           675  OPC_NOP:
0000142E                           676              * Put NOP into A1 buffer for printing
0000142E  12FC 004E                677              MOVE.B  #'N',(A1)+      
00001432  12FC 004F                678              MOVE.B  #'O',(A1)+ 
00001436  12FC 0050                679              MOVE.B  #'P',(A1)+ 
0000143A                           680              
0000143A  6000 FE0C                681              BRA     IDENTIFY_OPCODE
0000143E                           682  
0000143E                           683  
0000143E                           684  *-----------------------------OPC_NOT------------------------------
0000143E                           685  
0000143E                           686  OPC_NOT:
0000143E                           687              * Put NOT into A1 buffer for printing
0000143E  12FC 004E                688              MOVE.B  #'N',(A1)+ 
00001442  12FC 004F                689              MOVE.B  #'O',(A1)+
00001446  12FC 0054                690              MOVE.B  #'T',(A1)+
0000144A  12FC 002E                691              MOVE.B  #'.',(A1)+
0000144E                           692              
0000144E                           693              * Calculate Size (.b,.w.l)
0000144E  4EB9 00001464            694              JSR     GET_NOT_SIZE
00001454  4EB9 00001B46            695              JSR     SIZE_TO_BUFFER 
0000145A  4EB9 0000196A            696              JSR     GET_EA_MODE
00001460  6000 FDE6                697              BRA     IDENTIFY_OPCODE
00001464                           698              
00001464                           699  GET_NOT_SIZE:
00001464  4282                     700              CLR.L   D2
00001466  3438 107A                701              MOVE.W  opcode, D2
0000146A                           702  
0000146A                           703              * shift left to get rid of opTag
0000146A  123C 0008                704              MOVE.B  #8, D1
0000146E  E36A                     705              LSL.W   D1, D2
00001470                           706  
00001470                           707              * shift right to get rid of opmode, mode, and register bits
00001470  123C 000E                708              MOVE.B  #14, D1
00001474  E26A                     709              LSR.W   D1, D2
00001476                           710  
00001476                           711              * store in appropriate register
00001476  1602                     712              MOVE.B  D2, D3
00001478  4E75                     713              RTS
0000147A                           714  
0000147A                           715  *-----------------------------OPC_LEA------------------------------
0000147A                           716  OPC_LEA:
0000147A                           717              * Put LEA into A1 buffer for printing
0000147A  12FC 004C                718              MOVE.B  #'L',(A1)+      
0000147E  12FC 0045                719              MOVE.B  #'E',(A1)+ 
00001482  12FC 0041                720              MOVE.B  #'A',(A1)+
00001486  12FC 002E                721              MOVE.B  #'.',(A1)+ 
0000148A  12FC 004C                722              MOVE.B  #'L',(A1)+ 
0000148E  4EB9 00001B40            723              JSR     INSERT_SPACE
00001494                           724                      
00001494  4EB9 0000196A            725              JSR     GET_EA_MODE
0000149A  12FC 002C                726              MOVE.B  #',',(A1)+ 
0000149E  4EB9 00001B40            727              JSR INSERT_SPACE
000014A4  4EB9 0000194A            728              JSR GET_DATA_REG_NUM
000014AA                           729  
000014AA  6000 FD9C                730              BRA IDENTIFY_OPCODE    
000014AE                           731  
000014AE                           732  
000014AE                           733  *-----------------------------------------------------------
000014AE                           734  
000014AE                           735  *-----------------------------OPC_JSR------------------------------
000014AE                           736  OPC_JSR:
000014AE                           737              * Put LEA into A1 buffer for printing
000014AE  12FC 004A                738              MOVE.B  #'J',(A1)+      
000014B2  12FC 0053                739              MOVE.B  #'S',(A1)+ 
000014B6  12FC 0052                740              MOVE.B  #'R',(A1)+
000014BA  4EB9 00001B40            741              JSR     INSERT_SPACE
000014C0                           742              
000014C0  4EB9 0000196A            743              JSR     GET_EA_MODE
000014C6  6000 FD80                744              BRA     IDENTIFY_OPCODE  
000014CA                           745  
000014CA                           746  *-----------------------------OPC_RTS------------------------------
000014CA                           747  OPC_RTS:
000014CA                           748              * Put LEA into A1 buffer for printing
000014CA  12FC 0052                749              MOVE.B  #'R',(A1)+      
000014CE  12FC 0054                750              MOVE.B  #'T',(A1)+ 
000014D2  12FC 0053                751              MOVE.B  #'S',(A1)+
000014D6                           752          
000014D6  6000 FD70                753              BRA IDENTIFY_OPCODE
000014DA                           754  
000014DA                           755  *-----------------------------------------------------------
000014DA                           756  
000014DA                           757  *---------------------------OPC_1000------------------------
000014DA                           758  * First four bits = 1001
000014DA                           759  * (DIVU)
000014DA                           760  *-----------------------------------------------------------
000014DA                           761  OPC_1000:   * keeping this in case there's more that start with 1000
000014DA  6000 0002                762              BRA     OPC_DIVU
000014DE                           763              
000014DE                           764  OPC_DIVU:
000014DE  12FC 0044                765              MOVE.B  #'D',(A1)+
000014E2  12FC 0049                766              MOVE.B  #'I',(A1)+
000014E6  12FC 0056                767              MOVE.B  #'V',(A1)+
000014EA  12FC 0055                768              MOVE.B  #'U',(A1)+
000014EE  12FC 002E                769              MOVE.B  #'.',(A1)+
000014F2  12FC 0057                770              MOVE.B  #'W',(A1)+  * always size word
000014F6  12FC 0020                771              MOVE.B  #' ',(A1)+
000014FA                           772              
000014FA                           773              * set the valid bits (since there's only one adressing mode)
000014FA  11FC 00BF 107D           774              MOVE.B  #%10111111, valid
00001500                           775              
00001500  6000 03FA                776              BRA     EA_TO_D
00001504                           777  
00001504                           778  *-----------------------------------------------------------
00001504                           779  
00001504                           780  
00001504                           781  
00001504                           782  *-----------------------OPC_0101----------------------------
00001504                           783  * First four bits = 0101
00001504                           784  * (ADDQ, SUBQ)
00001504                           785  *-----------------------------------------------------------
00001504                           786  OPC_0101:
00001504                           787m             GET_BITS  #8, #8
00001514                           788m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000151A                           789m             * GET HIGH BIT OFFSET
00001520                           790m             * SHIFT OUT HIGH BITS
00001526                           791m             *GET LOW BIT OFFSET
00001526                           792m             *16 - NUMBER OF BITS WE WANT
0000152C                           793m             * SHIFT OUT LOW BITS
0000152E                           794              
0000152E                           795              * is the opcode ADDQ?
0000152E  B83C 0000                796              CMP.B     #%0000, D4
00001532  6700 000E                797              BEQ       OPC_ADDQ
00001536                           798  
00001536                           799              * is the opcode SUBI?
00001536  B83C 0001                800              CMP.B     #%0001, D4
0000153A  6700 001E                801              BEQ       OPC_SUBQ
0000153E                           802  
0000153E  4EF8 12E8                803              JMP       BAD_OPCODE
00001542                           804  
00001542                           805  *------------------------OPC_ADDI---------------------------
00001542                           806  OPC_ADDQ:
00001542  12FC 0041                807              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001546  12FC 0044                808              MOVE.B  #'D',(A1)+
0000154A  12FC 0044                809              MOVE.B  #'D',(A1)+
0000154E  12FC 0051                810              MOVE.B  #'Q',(A1)+
00001552  12FC 002E                811              MOVE.B  #'.',(A1)+
00001556                           812  
00001556  6100 001A                813              BSR     DECODE_QUICK
0000155A                           814  
0000155A                           815  *------------------------OPC_SUBI---------------------------
0000155A                           816  OPC_SUBQ:            
0000155A  12FC 0053                817              MOVE.B  #'S',(A1)+          * Put ADD into Buff
0000155E  12FC 0055                818              MOVE.B  #'U',(A1)+
00001562  12FC 0042                819              MOVE.B  #'B',(A1)+
00001566  12FC 0051                820              MOVE.B  #'Q',(A1)+
0000156A  12FC 002E                821              MOVE.B  #'.',(A1)+
0000156E                           822  
0000156E  6100 0002                823              BSR     DECODE_QUICK
00001572                           824  
00001572                           825  *------------------Subroutines for OPC_0101-----------------
00001572                           826  DECODE_QUICK:            
00001572                           827              * Get size of operation and push to buffer
00001572  4284                     828              CLR.L           D4
00001574                           829m             GET_BITS        #7, #6
00001584                           830m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000158A                           831m             * GET HIGH BIT OFFSET
00001590                           832m             * SHIFT OUT HIGH BITS
00001596                           833m             *GET LOW BIT OFFSET
00001596                           834m             *16 - NUMBER OF BITS WE WANT
0000159C                           835m             * SHIFT OUT LOW BITS
0000159E  1604                     836              MOVE.B          D4, D3
000015A0  4EB9 00001B46            837              JSR             SIZE_TO_BUFFER  
000015A6                           838  
000015A6                           839              * push value of #<data> to buffer
000015A6  4284                     840              CLR.L      D4
000015A8                           841m             GET_BITS   #11, #9
000015B8                           842m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000015C2                           843m             * GET HIGH BIT OFFSET
000015CA                           844m             * SHIFT OUT HIGH BITS
000015D0                           845m             *GET LOW BIT OFFSET
000015D0                           846m             *16 - NUMBER OF BITS WE WANT
000015D6                           847m             * SHIFT OUT LOW BITS
000015D8  12FC 0023                848              MOVE.B     #'#',(A1)+
000015DC                           849m             TO_BUFFER  D4
000015E4                           850  
000015E4                           851              * push <ea> to buffer
000015E4  12FC 002C                852              MOVE.B  #',',(A1)+
000015E8  4EB9 00001B40            853              JSR     INSERT_SPACE
000015EE  4EB9 0000196A            854              JSR     GET_EA_MODE
000015F4                           855  
000015F4  6000 FC52                856              BRA     IDENTIFY_OPCODE
000015F8                           857  *-----------------------------------------------------------
000015F8                           858  
000015F8                           859  
000015F8                           860  
000015F8                           861  *-----------------------OPC_1001----------------------------
000015F8                           862  * First four bits = 1001
000015F8                           863  * (SUB)
000015F8                           864  *-----------------------------------------------------------
000015F8                           865  OPC_1001:
000015F8                           866              * fill in A1 register
000015F8  12FC 0053                867              MOVE.B  #'S',(A1)+          * Put ADD into Buff
000015FC  12FC 0055                868              MOVE.B  #'U',(A1)+
00001600  12FC 0042                869              MOVE.B  #'B',(A1)+
00001604  12FC 002E                870              MOVE.B  #'.',(A1)+
00001608  6000 02B6                871              BRA     PROCESS_ROEA
0000160C                           872  *-----------------------------------------------------------
0000160C                           873  
0000160C                           874  
0000160C                           875  
0000160C                           876  *-----------------------OPC_1100----------------------------
0000160C                           877  * First four bits = 1100
0000160C                           878  * (AND, MULS)
0000160C                           879  *-----------------------------------------------------------
0000160C                           880  OPC_1100:   
0000160C                           881              ; check to see if bits 8-6 are 111
0000160C                           882              ; if they are, then branch to PARSE_MULS
0000160C                           883              ; else, keep going to parse AND
0000160C                           884  
0000160C                           885m             GET_BITS #8, #6
0000161C                           886m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001622                           887m             * GET HIGH BIT OFFSET
00001628                           888m             * SHIFT OUT HIGH BITS
0000162E                           889m             *GET LOW BIT OFFSET
0000162E                           890m             *16 - NUMBER OF BITS WE WANT
00001634                           891m             * SHIFT OUT LOW BITS
00001636  B83C 0007                892              CMP.B   #%00000111, D4
0000163A  6700 001A                893              BEQ     OPC_MULS
0000163E  6600 0002                894              BNE     OPC_AND
00001642                           895  
00001642                           896  *---------------------------OPC_AND------------------------
00001642                           897  OPC_AND:    ; AND opcode subroutine
00001642                           898  
00001642                           899              ;-----------------------------
00001642                           900              ; fill A1 with the opcode name
00001642  12FC 0041                901              MOVE.B  #'A',(A1)+
00001646  12FC 004E                902              MOVE.B  #'N',(A1)+
0000164A  12FC 0044                903              MOVE.B  #'D',(A1)+
0000164E  12FC 002E                904              MOVE.B  #'.',(A1)+
00001652  6000 026C                905              BRA     PROCESS_ROEA
00001656                           906  
00001656                           907  *---------------------------OPC_MULS------------------------
00001656                           908  OPC_MULS:  * MULS opcode subroutine
00001656                           909  
00001656                           910              * load the command name into the output
00001656  12FC 004D                911              MOVE.B  #'M',(A1)+
0000165A  12FC 0055                912              MOVE.B  #'U',(A1)+
0000165E  12FC 004C                913              MOVE.B  #'L',(A1)+
00001662  12FC 0053                914              MOVE.B  #'S',(A1)+
00001666  12FC 002E                915              MOVE.B  #'.',(A1)+
0000166A  12FC 0057                916              MOVE.B  #'W',(A1)+ * always size word
0000166E  12FC 0020                917              MOVE.B  #' ',(A1)+
00001672                           918              
00001672  11FC 00BF 107D           919              MOVE.B  #%10111111, valid   * set the valid mode bits (to be used later)
00001678                           920              
00001678  6000 0282                921              BRA     EA_TO_D * just the one addressing mode
0000167C                           922  *-----------------------------------------------------------
0000167C                           923  
0000167C                           924  
0000167C                           925  *---------------------------opc_1101------------------------
0000167C                           926  * First four bits = 1101
0000167C                           927  * (ADD)
0000167C                           928  *-----------------------------------------------------------
0000167C                           929  OPC_1101:
0000167C                           930              * fill in A1 register
0000167C  12FC 0041                931              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001680  12FC 0044                932              MOVE.B  #'D',(A1)+
00001684  12FC 0044                933              MOVE.B  #'D',(A1)+
00001688  12FC 002E                934              MOVE.B  #'.',(A1)+
0000168C  6000 0232                935              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
00001690                           936  
00001690                           937  *-----------------------------------------------------------
00001690                           938              
00001690                           939  *---------------------------opc_1110------------------------
00001690                           940  * First four bits = 1110
00001690                           941  * (LSL, LSR, ASL, ASR)
00001690                           942  *-----------------------------------------------------------
00001690                           943  OPC_1110:
00001690  11FC 003E 107D           944              MOVE.B  #%00111110, valid ; valid bits are the same for all shifts
00001696                           945              
00001696                           946              ; check for LSL/LSR vs ASL/ASR
00001696                           947m             GET_BITS #4,#3
000016A6                           948m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000016AC                           949m             * GET HIGH BIT OFFSET
000016B2                           950m             * SHIFT OUT HIGH BITS
000016B8                           951m             *GET LOW BIT OFFSET
000016B8                           952m             *16 - NUMBER OF BITS WE WANT
000016BE                           953m             * SHIFT OUT LOW BITS
000016C0  B83C 0000                954              CMP.B   #0,D4
000016C4  6700 0006                955              BEQ     A_SHIFT     ; if bits 4-3 are 00, ASL/ASR
000016C8  6000 0040                956              BRA     L_SHIFT     ; if bits 4-3 are 01, LSL/LSR
000016CC                           957  
000016CC                           958  ;======================================================
000016CC                           959  ; getting the opcode name
000016CC                           960  A_SHIFT:
000016CC  12FC 0041                961              MOVE.B  #'A',(A1)+
000016D0  12FC 0053                962              MOVE.B  #'S',(A1)+ 
000016D4                           963m             GET_BITS #8,#8      ; check for shifting left or right
000016E4                           964m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000016EA                           965m             * GET HIGH BIT OFFSET
000016F0                           966m             * SHIFT OUT HIGH BITS
000016F6                           967m             *GET LOW BIT OFFSET
000016F6                           968m             *16 - NUMBER OF BITS WE WANT
000016FC                           969m             * SHIFT OUT LOW BITS
000016FE  B83C 0001                970              CMP.B   #01,D4
00001702  6700 0044                971              BEQ     L_TO_BUFF
00001706  6000 004C                972              BRA     R_TO_BUFF
0000170A                           973              
0000170A                           974  L_SHIFT:
0000170A  12FC 004C                975              MOVE.B  #'L',(A1)+
0000170E  12FC 0053                976              MOVE.B  #'S',(A1)+
00001712                           977m             GET_BITS #8,#8      ; check for shifting left or right
00001722                           978m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001728                           979m             * GET HIGH BIT OFFSET
0000172E                           980m             * SHIFT OUT HIGH BITS
00001734                           981m             *GET LOW BIT OFFSET
00001734                           982m             *16 - NUMBER OF BITS WE WANT
0000173A                           983m             * SHIFT OUT LOW BITS
0000173C  B83C 0001                984              CMP.B   #01,D4
00001740  6700 0006                985              BEQ     L_TO_BUFF
00001744  6000 000E                986              BRA     R_TO_BUFF
00001748                           987              
00001748                           988              
00001748                           989  L_TO_BUFF:
00001748  12FC 004C                990              MOVE.B  #'L',(A1)+
0000174C  12FC 002E                991              MOVE.B  #'.',(A1)+
00001750                           992              
00001750  6000 000E                993              BRA     SHIFT_MODES
00001754                           994  
00001754                           995  
00001754                           996  R_TO_BUFF:
00001754  12FC 0052                997              MOVE.B  #'R',(A1)+
00001758  12FC 002E                998              MOVE.B  #'.',(A1)+
0000175C                           999  
0000175C  6000 0002               1000              BRA     SHIFT_MODES
00001760                          1001  
00001760                          1002  
00001760                          1003  ;======================================================
00001760                          1004  ; determining which mode to use
00001760                          1005  SHIFT_MODES:
00001760                          1006m             GET_BITS #7,#6
00001770                          1007m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001776                          1008m             * GET HIGH BIT OFFSET
0000177C                          1009m             * SHIFT OUT HIGH BITS
00001782                          1010m             *GET LOW BIT OFFSET
00001782                          1011m             *16 - NUMBER OF BITS WE WANT
00001788                          1012m             * SHIFT OUT LOW BITS
0000178A  B83C 0003               1013              CMP.B   #3,D4
0000178E  6600 0006               1014              BNE     SHIFT_REG_OR_IMM    ; jump to register/immediate mode if the bits aren't #%11
00001792  6000 011A               1015              BRA     SHIFT_MEM_MODE      ; otherwise, jump to memory mode if the bits are #%11
00001796                          1016  
00001796                          1017  
00001796                          1018  SHIFT_REG_OR_IMM: ; register and immediate shifts
00001796                          1019              
00001796                          1020              ; get the size
00001796  1604                    1021              MOVE.B  D4,D3
00001798  4EB9 00001B46           1022              JSR     SIZE_TO_BUFFER
0000179E                          1023              
0000179E                          1024              
0000179E                          1025              ; get the i/r bit to determine immediate/register
0000179E                          1026m             GET_BITS #5,#5
000017AE                          1027m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000017B4                          1028m             * GET HIGH BIT OFFSET
000017BA                          1029m             * SHIFT OUT HIGH BITS
000017C0                          1030m             *GET LOW BIT OFFSET
000017C0                          1031m             *16 - NUMBER OF BITS WE WANT
000017C6                          1032m             * SHIFT OUT LOW BITS
000017C8                          1033              ; if i/r is 0, it's an immediate shift
000017C8                          1034              ; if i/r is 1, it's a register shift
000017C8  B83C 0000               1035              CMP.B   #0,D4
000017CC  6700 0006               1036              BEQ     SHIFT_IMMEDIATE_MODE
000017D0  6000 005E               1037              BRA     SHIFT_REGISTER_MODE
000017D4                          1038              
000017D4                          1039  
000017D4                          1040  ;======================================================
000017D4                          1041  ; shifting modes (immediate data, from a register, from memory)
000017D4                          1042  SHIFT_IMMEDIATE_MODE:
000017D4  12FC 0023               1043              MOVE.B  #'#',(A1)+
000017D8                          1044              
000017D8  4EB9 000017EA           1045              JSR     SHIFT_COUNT
000017DE                          1046              
000017DE  12FC 002C               1047              MOVE.B  #',',(A1)+
000017E2  12FC 0020               1048              MOVE.B  #' ',(A1)+
000017E6                          1049              
000017E6  6000 0088               1050              BRA     SHIFT_DEST_REG   ; get the destination register
000017EA                          1051  
000017EA                          1052  SHIFT_COUNT: ; moves the size to the buffer
000017EA                          1053m             GET_BITS #11,#9
000017FA                          1054m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001804                          1055m             * GET HIGH BIT OFFSET
0000180C                          1056m             * SHIFT OUT HIGH BITS
00001812                          1057m             *GET LOW BIT OFFSET
00001812                          1058m             *16 - NUMBER OF BITS WE WANT
00001818                          1059m             * SHIFT OUT LOW BITS
0000181A                          1060              
0000181A  B83C 0000               1061              CMP.B   #0,D4   ; shift bits = 0, shifting 8 bits
0000181E  6700 000A               1062              BEQ     EIGHT_TO_BUFF
00001822                          1063              
00001822  0604 0030               1064              ADD.B   #$30,D4
00001826  12C4                    1065              MOVE.B  D4,(A1)+
00001828  4E75                    1066              RTS
0000182A                          1067              
0000182A                          1068  EIGHT_TO_BUFF:
0000182A  12FC 0038               1069              MOVE.B  #'8',(A1)+
0000182E  4E75                    1070              RTS
00001830                          1071              
00001830                          1072              
00001830                          1073  SHIFT_REGISTER_MODE:
00001830  12FC 0044               1074              MOVE.B  #'D',(A1)+
00001834                          1075              
00001834                          1076m             GET_BITS #7, #6
00001844                          1077m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000184A                          1078m             * GET HIGH BIT OFFSET
00001850                          1079m             * SHIFT OUT HIGH BITS
00001856                          1080m             *GET LOW BIT OFFSET
00001856                          1081m             *16 - NUMBER OF BITS WE WANT
0000185C                          1082m             * SHIFT OUT LOW BITS
0000185E                          1083              
0000185E  0604 0030               1084              ADD.B   #$30,D4         ; push the register to the buffer
00001862  12C4                    1085              MOVE.B  D4,(A1)+
00001864  12FC 002C               1086              MOVE.B  #',',(A1)+
00001868  12FC 0020               1087              MOVE.B  #' ',(A1)+
0000186C                          1088              
0000186C  6000 0002               1089              BRA     SHIFT_DEST_REG   ; get the destination register
00001870                          1090  
00001870                          1091  SHIFT_DEST_REG:
00001870  12FC 0044               1092              MOVE.B  #'D',(A1)+
00001874                          1093m             GET_BITS #2,#0
00001884                          1094m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000188C                          1095m             * GET HIGH BIT OFFSET
00001892                          1096m             * SHIFT OUT HIGH BITS
00001898                          1097m             *GET LOW BIT OFFSET
00001898                          1098m             *16 - NUMBER OF BITS WE WANT
0000189E                          1099m             * SHIFT OUT LOW BITS
000018A0                          1100              ; add 30 to the register bits
000018A0  0604 0030               1101              ADD.B   #$30,D4
000018A4  12C4                    1102              MOVE.B  D4,(A1)+
000018A6                          1103              
000018A6  12FC 0000               1104              MOVE.B  #0,(A1)+        ; add the null terminator
000018AA                          1105              
000018AA  6000 F99C               1106              BRA     IDENTIFY_OPCODE
000018AE                          1107              
000018AE                          1108              
000018AE                          1109  SHIFT_MEM_MODE: ; memory shifts
000018AE  12FC 0057               1110              MOVE.B  #'W',(A1)+      ; always word sized
000018B2  12FC 0020               1111              MOVE.B  #' ',(A1)+
000018B6                          1112              
000018B6  4EB9 0000196A           1113              JSR     GET_EA_MODE
000018BC  6000 F98A               1114              BRA     IDENTIFY_OPCODE
000018C0                          1115  
000018C0                          1116  
000018C0                          1117  *--------------Process Register->Opmode->EA-----------------
000018C0                          1118  * Description:
000018C0                          1119  * Parses bits for opcodes that share bit placements:
000018C0                          1120  * ROEA stands for Register, Opmode, and Effective Address,
000018C0                          1121  * because the opcodes below share this bit order.
000018C0                          1122  *
000018C0                          1123  * Used by: (ADD, SUB, MULS)
000018C0                          1124  *
000018C0                          1125  *-----------------------------------------------------------
000018C0                          1126  PROCESS_ROEA:
000018C0  4EB9 0000191E           1127              JSR     GET_SIZE
000018C6  4EB9 00001B46           1128              JSR     SIZE_TO_BUFFER
000018CC  4EB9 00001934           1129              JSR     OPMODE_TYPE         * 0 or 1 value (either <ea> -> Dn or Dn -> <ea>)  
000018D2  B83C 0001               1130              CMP.B   #1, D4              * is this Dn + <ea> -> <ea>?
000018D6  6700 000A               1131              BEQ     D_TO_EA
000018DA  B83C 0000               1132              CMP.B   #0, D4              * is this Dn + <ea> -> <ea>?
000018DE  6700 001C               1133              BEQ     EA_TO_D
000018E2                          1134  
000018E2                          1135  D_TO_EA:
000018E2  4EB9 0000194A           1136              JSR     GET_DATA_REG_NUM
000018E8  12FC 002C               1137              MOVE.B  #',',(A1)+
000018EC  4EB9 00001B40           1138              JSR     INSERT_SPACE
000018F2  4EB9 0000196A           1139              JSR     GET_EA_MODE
000018F8  6000 001C               1140              BRA     ROEA_DONE
000018FC                          1141  
000018FC                          1142  EA_TO_D:
000018FC  4EB9 0000196A           1143              JSR     GET_EA_MODE
00001902  12FC 002C               1144              MOVE.B  #',',(A1)+
00001906  4EB9 00001B40           1145              JSR     INSERT_SPACE
0000190C  4EB9 0000194A           1146              JSR     GET_DATA_REG_NUM
00001912  6000 0002               1147              BRA     ROEA_DONE
00001916                          1148  
00001916                          1149  ROEA_DONE:
00001916  12FC 0020               1150              MOVE.B  #' ',(A1)+
0000191A  6000 F92C               1151              BRA     IDENTIFY_OPCODE
0000191E                          1152              
0000191E                          1153  
0000191E                          1154  GET_SIZE:
0000191E                          1155              * copy current instruction to shift
0000191E  4282                    1156              CLR.L   D2
00001920  3438 107A               1157              MOVE.W  opcode ,D2          
00001924                          1158              
00001924                          1159              * shift left to get rid of opTag
00001924  123C 0008               1160              MOVE.B  #8, D1
00001928  E36A                    1161              LSL.W   D1, D2
0000192A                          1162  
0000192A                          1163              * shift right to get rid of opmode, mode, and register bits
0000192A  123C 000E               1164              MOVE.B  #14, D1
0000192E  E26A                    1165              LSR.W   D1, D2
00001930                          1166  
00001930                          1167              * store in appropriate register
00001930  1602                    1168              MOVE.B  D2, D3
00001932                          1169              
00001932  4E75                    1170              RTS
00001934                          1171  
00001934                          1172  OPMODE_TYPE:
00001934                          1173              * copy current instruction to shift
00001934  4282                    1174              CLR.L   D2
00001936  3438 107A               1175              MOVE.W  opcode ,D2          
0000193A                          1176  
0000193A                          1177              * shift left to identify
0000193A  123C 0007               1178              MOVE.B  #7, D1
0000193E  E36A                    1179              LSL.W   D1, D2
00001940                          1180              
00001940                          1181              * shift left to identify
00001940  123C 000F               1182              MOVE.B  #15, D1
00001944  E26A                    1183              LSR.W   D1, D2
00001946                          1184  
00001946                          1185              * store in appropriate register
00001946  1802                    1186              MOVE.B  D2, D4
00001948                          1187  
00001948  4E75                    1188              RTS
0000194A                          1189  
0000194A                          1190  GET_DATA_REG_NUM:
0000194A                          1191              * D3 should hold the size of the opcode operation
0000194A  4282                    1192              CLR.L   D2
0000194C  3438 107A               1193              MOVE.W  opcode, D2  
00001950                          1194  
00001950                          1195              * shift left to identify
00001950  123C 0004               1196              MOVE.B  #4, D1
00001954  E36A                    1197              LSL.W   D1, D2
00001956                          1198              
00001956                          1199              * shift right to isolate high register bits
00001956  123C 000D               1200              MOVE.B  #13, D1
0000195A  E26A                    1201              LSR.W   D1, D2
0000195C                          1202  
0000195C                          1203              * store in appropriate register
0000195C  12FC 0044               1204              MOVE.B  #'D',(A1)+              * add "D" to buffer
00001960  0602 0030               1205              ADD.B   #$30,D2                   * convert data register # to hex digit
00001964  12C2                    1206              MOVE.B  D2,(A1)+                * register # to buffer             
00001966  1C02                    1207              MOVE.B  D2, D6
00001968                          1208  
00001968  4E75                    1209              RTS
0000196A                          1210  *-----------------------------------------------------------
0000196A                          1211  
0000196A                          1212  
0000196A                          1213  
0000196A                          1214  
0000196A                          1215  
0000196A                          1216  
0000196A                          1217  
0000196A                          1218  
0000196A                          1219  
0000196A                          1220  
0000196A                          1221  
0000196A                          1222  
0000196A                          1223  *----------------------------GET_EA_MODE------------------------
0000196A                          1224  * Description:
0000196A                          1225  * Evaluates the ea mode and register of an opcode 
0000196A                          1226  * (usually last 6 bits of instruction format),
0000196A                          1227  * and adds it to A1 to be printed out
0000196A                          1228  *
0000196A                          1229  * No Parameters
0000196A                          1230  *
0000196A                          1231  * Registers Used:
0000196A                          1232  *   D1 = amount to shift the opcode
0000196A                          1233  *   D2 = destination for shifts
0000196A                          1234  *   D5 = addressing mode
0000196A                          1235  *-----------------------------------------------------------
0000196A                          1236  GET_EA_MODE:
0000196A                          1237m             CLR_D_REGS
0000197A                          1238              * move size of opcode to be manipulated
0000197A  4282                    1239              CLR.L   D2
0000197C  3438 107A               1240              MOVE.W  opcode, D2     
00001980                          1241  
00001980                          1242              * shift left to identify
00001980  123C 000A               1243              MOVE.B  #10, D1
00001984  E36A                    1244              LSL.W   D1, D2
00001986                          1245              
00001986                          1246              * shift right to isolate mode bits for EA 
00001986  123C 000D               1247              MOVE.B  #13, D1
0000198A  E26A                    1248              LSR.W   D1, D2
0000198C                          1249  
0000198C                          1250              * store in appropriate register
0000198C  1A02                    1251              MOVE.B  D2, D5
0000198E                          1252              
0000198E  6000 0002               1253              BRA     FIND_MODE
00001992                          1254  
00001992                          1255  *----------------------------FIND_MODE------------------------
00001992                          1256  FIND_MODE:                            
00001992  BA3C 0000               1257              CMP.B   #%0000, D5        * Direct Data Register
00001996  6700 003E               1258              BEQ     ea_000
0000199A                          1259  
0000199A  BA3C 0001               1260              CMP.B   #%0001, D5        * Direct Address Register
0000199E  6700 004E               1261              BEQ     ea_001
000019A2                          1262  
000019A2  BA3C 0002               1263              CMP.B   #%0010, D5        * Indirect Address Register
000019A6  6700 005E               1264              BEQ     ea_010
000019AA                          1265  
000019AA  BA3C 0003               1266              CMP.B   #%0011, D5        * Post Increment
000019AE  6700 0076               1267              BEQ     ea_011
000019B2                          1268  
000019B2  BA3C 0004               1269              CMP.B   #%0100, D5        * Pre Decrement
000019B6  6700 0092               1270              BEQ     ea_100
000019BA                          1271  
000019BA  BA3C 0005               1272              CMP.B   #%0101, D5        * Not necessary, go to bad ea
000019BE  6700 00AE               1273              BEQ     ea_101
000019C2                          1274  
000019C2  BA3C 0006               1275              CMP.B   #%0110, D5        * Not necessary, go to bad ea
000019C6  6700 00AA               1276              BEQ     ea_110
000019CA                          1277  
000019CA  BA3C 0007               1278              CMP.B   #%0111, D5        * Absolute or immediate address
000019CE  6700 00A6               1279              BEQ     ea_111
000019D2                          1280  
000019D2  6000 00FA               1281              BRA    INVALID_EA
000019D6                          1282  
000019D6                          1283  *----------------------------Direct Data Register------------------------
000019D6                          1284  ea_000:
000019D6  3438 107A               1285              MOVE.W      opcode, D2              * move current working word into temp storage
000019DA  12FC 0044               1286              MOVE.B      #'D',(A1)+              * add "D" to buffer
000019DE                          1287              
000019DE  123C 000D               1288              MOVE.B      #13, D1
000019E2  E36A                    1289              LSL.W       D1,D2                   * isolate register bits (last 3)
000019E4  E26A                    1290              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
000019E6  0602 0030               1291              ADD.B       #$30,D2                 * convert data register # to ASCII digit
000019EA                          1292  
000019EA  12C2                    1293              MOVE.B      D2,(A1)+                * register # to buffer                  
000019EC                          1294              
000019EC  4E75                    1295              RTS                                
000019EE                          1296  
000019EE                          1297  *----------------------------Direct Address Register------------------------
000019EE                          1298  ea_001:
000019EE  3438 107A               1299              MOVE.W      opcode, D2              * move current working word into temp storage
000019F2  12FC 0041               1300              MOVE.B      #'A',(A1)+              * add "A" to buffer
000019F6                          1301              
000019F6  123C 000D               1302              MOVE.B      #13, D1
000019FA  E36A                    1303              LSL.W       D1,D2                   * isolate register bits (last 3)
000019FC  E26A                    1304              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
000019FE  0602 0030               1305              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001A02                          1306  
00001A02  12C2                    1307              MOVE.B      D2,(A1)+                * register # to buffer               
00001A04                          1308                
00001A04  4E75                    1309              RTS                            
00001A06                          1310  
00001A06                          1311  *----------------------------Indirect Address Register------------------------
00001A06                          1312  ea_010:
00001A06  3438 107A               1313              MOVE.W      opcode, D2              * move current working word into temp storage
00001A0A  12FC 0028               1314              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001A0E  12FC 0041               1315              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001A12                          1316  
00001A12  123C 000D               1317              MOVE.B      #13, D1
00001A16  E36A                    1318              LSL.W       D1,D2                   * isolate register bits (last 3)
00001A18  E26A                    1319              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
00001A1A  0602 0030               1320              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001A1E  12C2                    1321              MOVE.B      D2,(A1)+                * register # to buffer     
00001A20                          1322  
00001A20  12FC 0029               1323              MOVE.B      #')',(A1)+              * add ")" to buffer
00001A24                          1324               
00001A24  4E75                    1325              RTS                            
00001A26                          1326  
00001A26                          1327  *----------------------------Post Increment------------------------
00001A26                          1328  ea_011:
00001A26  3438 107A               1329              MOVE.W      opcode, D2              * move current working word into temp storage
00001A2A                          1330  
00001A2A  12FC 0028               1331              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001A2E  12FC 0041               1332              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001A32                          1333              
00001A32  123C 000D               1334              MOVE.B      #13, D1
00001A36  E36A                    1335              LSL.W       D1,D2                   * isolate register bits (last 3)
00001A38  E26A                    1336              LSR.W       D1,D2                  
00001A3A  0602 0030               1337              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001A3E  12C2                    1338              MOVE.B      D2,(A1)+                * register # to buffer     
00001A40                          1339  
00001A40  12FC 0029               1340              MOVE.B      #')',(A1)+              * add ")" to buffer
00001A44  12FC 002B               1341              MOVE.B      #'+',(A1)+              * add "+" to buffer
00001A48                          1342                   
00001A48  4E75                    1343              RTS                              
00001A4A                          1344  
00001A4A                          1345  *----------------------------Pre Decrement------------------------
00001A4A                          1346  ea_100:
00001A4A  3438 107A               1347              MOVE.W      opcode, D2              * move current working word into temp storage
00001A4E                          1348  
00001A4E  12FC 002D               1349              MOVE.B      #'-',(A1)+              * add "-" to buffer
00001A52  12FC 0028               1350              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001A56  12FC 0041               1351              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001A5A                          1352              
00001A5A  123C 000D               1353              MOVE.B      #13, D1
00001A5E  E36A                    1354              LSL.W       D1, D2                   * isolate register bits (last 3)
00001A60  E26A                    1355              LSR.W       D1, D2                   * D2 now holds the mode of the opcode
00001A62  0602 0030               1356              ADD.B       #$30, D2                 * convert data register # to ASCII digit
00001A66  12C2                    1357              MOVE.B      D2, (A1)+                * register # to buffer     
00001A68                          1358  
00001A68  12FC 0029               1359              MOVE.B      #')',(A1)+               * add ")" to buffer
00001A6C                          1360              
00001A6C  4E75                    1361              RTS
00001A6E                          1362  
00001A6E                          1363  *----------------------------Not necessary, go to bad ea------------------------
00001A6E                          1364  ea_101:
00001A6E  6000 005E               1365              BRA         INVALID_EA        
00001A72                          1366  
00001A72                          1367  
00001A72                          1368  *----------------------------Not necessary, go to bad ea------------------------
00001A72                          1369  ea_110:
00001A72  6000 005A               1370              BRA         INVALID_EA        
00001A76                          1371  
00001A76                          1372  
00001A76                          1373  *----------------------------Absolute or immediate address------------------------
00001A76                          1374  ea_111:
00001A76                          1375              * D405      0 0003456  23345245
00001A76                          1376              * ADD.L     $1234, D0
00001A76                          1377  
00001A76                          1378              * 8 bit value
00001A76                          1379              * 11111111
00001A76                          1380  
00001A76                          1381              * 11111011 - Direct data register would be Invalid
00001A76                          1382              * 00000100
00001A76                          1383              * 00000000 -> invalid code
00001A76                          1384  
00001A76                          1385              * and.b     #$F, Dn        ---->  10000000
00001A76                          1386              * cmp.b     #%10000000, Dn  
00001A76                          1387  
00001A76                          1388              * check against valid bits
00001A76                          1389                  * if invalid, branch to invalid opcode subroutine
00001A76                          1390                      * if the mode is 111, then go back and print out addresses
00001A76                          1391  
00001A76  3438 107A               1392              MOVE.W      opcode, D2
00001A7A  123C 000D               1393              MOVE.B      #13, D1
00001A7E  E36A                    1394              LSL.W       D1, D2                   * isolate register bits (last 3)
00001A80  E26A                    1395              LSR.W       D1, D2                   * isolate register bits (last 3)
00001A82                          1396  
00001A82  B43C 0000               1397              CMP.B       #%000, D2                * compare to determine if it's a word
00001A86  6700 0016               1398              BEQ         EA_WORD                  * put word address in buffer
00001A8A                          1399  
00001A8A  B43C 0001               1400              CMP.B       #%001, D2                * compare to determine if it's a long
00001A8E  6700 0022               1401              BEQ         EA_LONG                  * put long address in buffer
00001A92                          1402              
00001A92  B43C 0004               1403              CMP.B       #%100, D2
00001A96  6700 002E               1404              BEQ         EA_IMMEDIATE             * always print a long if it's immediate data
00001A9A                          1405  
00001A9A                          1406              * Invalid EA mode/register
00001A9A  6000 0032               1407              BRA         INVALID_EA
00001A9E                          1408  
00001A9E                          1409  EA_WORD:
00001A9E  12FC 0024               1410              MOVE.B      #'$', (A1)+
00001AA2  4281                    1411              CLR.L       D1
00001AA4  123C 0001               1412              MOVE.B      #1, D1
00001AA8  3E1A                    1413              MOVE.W      (A2)+, D7
00001AAA  6100 0028               1414              BSR         HEX_TO_ASCII
00001AAE  6000 001C               1415              BRA         GET_EA_DONE
00001AB2                          1416  
00001AB2                          1417  EA_LONG:
00001AB2  12FC 0024               1418              MOVE.B      #'$', (A1)+
00001AB6  4281                    1419              CLR.L       D1
00001AB8  123C 0003               1420              MOVE.B      #3, D1
00001ABC  2E1A                    1421              MOVE.L      (A2)+, D7   
00001ABE  6100 0014               1422              BSR         HEX_TO_ASCII
00001AC2  6000 0008               1423              BRA         GET_EA_DONE
00001AC6                          1424  
00001AC6                          1425  EA_IMMEDIATE:
00001AC6  12FC 0023               1426              MOVE.B      #'#', (A1)+
00001ACA  60E6                    1427              BRA         EA_LONG
00001ACC                          1428  
00001ACC                          1429  GET_EA_DONE:
00001ACC  4E75                    1430              RTS
00001ACE                          1431  
00001ACE                          1432  *------------------Invalid Effective Address----------------
00001ACE                          1433  INVALID_EA:
00001ACE  4EF9 00001B80           1434              JMP      DONE
00001AD4                          1435  *-----------------------------------------------------------
00001AD4                          1436  
00001AD4                          1437  
00001AD4                          1438  
00001AD4                          1439  
00001AD4                          1440  
00001AD4                          1441  
00001AD4                          1442  
00001AD4                          1443  
00001AD4                          1444  
00001AD4                          1445  *----------------------HEX TO ASCII-------------------------
00001AD4                          1446  * Description:
00001AD4                          1447  * Converts a Hex numbered address (1-9 or A-F) back to an
00001AD4                          1448  * ASCII value for printing
00001AD4                          1449  *
00001AD4                          1450  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
00001AD4                          1451  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
00001AD4                          1452  *   D7 = holds the original address to parse (either word or long, for example: $7000)
00001AD4                          1453  *
00001AD4                          1454  *
00001AD4                          1455  * Registers Used:
00001AD4                          1456  *   D0 = number of bits to remove
00001AD4                          1457  *   D2 = holds either top four bits or bottom four bits of each byte in D6
00001AD4                          1458  *   D3 = holds temp data
00001AD4                          1459  *   D6 = holds part of address (used as temp variable)
00001AD4                          1460  *   A1 = used for buffer
00001AD4                          1461  *-----------------------------------------------------------
00001AD4                          1462  HEX_TO_ASCII:
00001AD4  1001                    1463              MOVE.B   D1, D0             * current number of bytes to remove
00001AD6  C1FC 0008               1464              MULS.W   #8, D0             * number of bits to remove
00001ADA                          1465  
00001ADA  2C07                    1466              MOVE.L   D7, D6             * load original address to parse
00001ADC  E0AE                    1467              LSR.L    D0, D6             * remove lowest byte(s)
00001ADE                          1468  
00001ADE                          1469              * isolate first four bits
00001ADE  1406                    1470              MOVE.B   D6, D2
00001AE0  E80A                    1471              LSR.B    #4, D2 
00001AE2  6100 0018               1472              BSR      NUMBER_OR_LETTER
00001AE6                          1473  
00001AE6                          1474              * isolate second set of four bits
00001AE6  1406                    1475              MOVE.B   D6, D2
00001AE8  E90A                    1476              LSL.B    #4, D2 
00001AEA  E80A                    1477              LSR.B    #4, D2 
00001AEC  6100 000E               1478              BSR      NUMBER_OR_LETTER
00001AF0                          1479  
00001AF0  5301                    1480              SUB.B    #1, D1             * iterate
00001AF2  B23C 0000               1481              CMP.B    #0, D1             * done if equal
00001AF6  6D00 0036               1482              BLT      ATH_DONE
00001AFA                          1483  
00001AFA  60D8                    1484              BRA      HEX_TO_ASCII
00001AFC                          1485  
00001AFC                          1486  NUMBER_OR_LETTER:
00001AFC  1602                    1487              MOVE.B   D2, D3
00001AFE  0603 0030               1488              ADD.B    #$30, D3           
00001B02  B63C 0039               1489              CMP.B    #$39, D3           * is byte in D2 a number?
00001B06  6F00 0012               1490              BLE      NUMBER_TO_ASCII
00001B0A                          1491              
00001B0A  1602                    1492              MOVE.B   D2, D3
00001B0C  0603 0037               1493              ADD.B    #$37, D3           
00001B10  B63C 0039               1494              CMP.B    #$39, D3           * is byte in D2 a letter?
00001B14  6C00 000C               1495              BGE      LETTER_TO_ASCII
00001B18                          1496  
00001B18  60B4                    1497              BRA      INVALID_EA
00001B1A                          1498  
00001B1A                          1499  NUMBER_TO_ASCII:
00001B1A  0602 0030               1500              ADD.B    #$30, D2           * Get the hex range from '0-9'
00001B1E  6000 000A               1501              BRA      ADD_TO_BUFFER
00001B22                          1502  
00001B22                          1503  LETTER_TO_ASCII:
00001B22  0602 0037               1504              ADD.B    #$37, D2           * Get the hex range from 'A-F'
00001B26  6000 0002               1505              BRA      ADD_TO_BUFFER
00001B2A                          1506  
00001B2A                          1507  ADD_TO_BUFFER:
00001B2A  12C3                    1508              MOVE.B   D3, (A1)+          * add part of address to buffer    
00001B2C  4E75                    1509              RTS
00001B2E                          1510  
00001B2E                          1511  ATH_DONE:
00001B2E                          1512m             CLR_D_REGS
00001B3E  4E75                    1513              RTS
00001B40                          1514  *-----------------------------------------------------------
00001B40                          1515  
00001B40                          1516  INSERT_SPACE:
00001B40  12FC 0020               1517              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001B44  4E75                    1518              RTS
00001B46                          1519  
00001B46                          1520  
00001B46                          1521  
00001B46                          1522  
00001B46                          1523  
00001B46                          1524  
00001B46                          1525  
00001B46                          1526  
00001B46                          1527  
00001B46                          1528  *---------------------SIZE TO BUFFER------------------------
00001B46                          1529  * Description:
00001B46                          1530  * Evaluates the size of an opcode and adds it to A1 to be printed out
00001B46                          1531  *
00001B46                          1532  * Parameters:
00001B46                          1533  *   D3 = size of opcode
00001B46                          1534  *
00001B46                          1535  * Registers Used:
00001B46                          1536  *   A1: adding words/numbers to buffer
00001B46                          1537  *-----------------------------------------------------------
00001B46                          1538  SIZE_TO_BUFFER: 
00001B46  B63C 0000               1539              CMP.B   #%0000,D3            
00001B4A  6700 0016               1540              BEQ     BYTE_TO_BUFFER              
00001B4E                          1541  
00001B4E  B63C 0001               1542              CMP.B   #%0001,D3             * is this a word?
00001B52  6700 0016               1543              BEQ     WORD_TO_BUFFER
00001B56                          1544  
00001B56  B63C 0002               1545              CMP.B   #%0010,D3             * is this a long?
00001B5A  6700 0016               1546              BEQ     LONG_TO_BUFFER             
00001B5E                          1547        
00001B5E  4EF8 12E8               1548              JMP     BAD_OPCODE  
00001B62                          1549              
00001B62                          1550  BYTE_TO_BUFFER:
00001B62  12FC 0042               1551              MOVE.B  #'B', (A1)+           * add B to buffer
00001B66  6000 0012               1552              BRA     STB_END             
00001B6A                          1553              
00001B6A                          1554  WORD_TO_BUFFER:
00001B6A  12FC 0057               1555              MOVE.B  #'W', (A1)+          * add W to buffer
00001B6E  6000 000A               1556              BRA     STB_END             
00001B72                          1557  
00001B72                          1558  LONG_TO_BUFFER:
00001B72  12FC 004C               1559              MOVE.B  #'L',(A1)+          * add L to buffer
00001B76  6000 0002               1560              BRA     STB_END             
00001B7A                          1561  
00001B7A                          1562  STB_END:
00001B7A  12FC 0020               1563              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001B7E  4E75                    1564              RTS                         
00001B80                          1565  
00001B80                          1566  
00001B80                          1567  
00001B80                          1568  
00001B80                          1569  
00001B80                          1570  
00001B80                          1571  
00001B80                          1572  *-------------------------DONE-------------------------------
00001B80                          1573  DONE:
00001B80                          1574m             CLR_A_REG D0, A1
00001B84                          1575  
00001B84                          1576              * add 'SIMHAULT' to buffer
00001B84  12FC 0053               1577              MOVE.B  #'S',(A1)+      
00001B88  12FC 0049               1578              MOVE.B  #'I',(A1)+         
00001B8C  12FC 004D               1579              MOVE.B  #'M',(A1)+         
00001B90  12FC 0048               1580              MOVE.B  #'H',(A1)+        
00001B94  12FC 0041               1581              MOVE.B  #'A',(A1)+         
00001B98  12FC 0055               1582              MOVE.B  #'U',(A1)+         
00001B9C  12FC 004C               1583              MOVE.B  #'L',(A1)+          
00001BA0  12FC 0054               1584              MOVE.B  #'T',(A1)+         
00001BA4  12FC 0000               1585              MOVE.B  #00,(A1)+         
00001BA8                          1586  
00001BA8                          1587m             CLR_A_REG D0, A1
00001BAC                          1588              
00001BAC                          1589              * print out string
00001BAC  103C 000E               1590              MOVE.B    #14, D0
00001BB0  4E4F                    1591              TRAP      #15
00001BB2                          1592              
00001BB2                          1593m             CLR_A_REG D0, A1
00001BB6                          1594  
00001BB6                          1595  
00001BB6                          1596              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       1B2A
ATH_DONE            1B2E
A_SHIFT             16CC
BADINPUT            1052
BAD_OPCODE          12E8
BYTE_TO_BUFFER      1B62
CHECK_IMMEDIATE     13AC
CHECK_LENGTH        10DC
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      110E
CR                  D
DECODE_IMMEDIATE    1360
DECODE_QUICK        1572
DONE                1B80
DONEMSG             1045
D_TO_EA             18E2
EA_000              19D6
EA_001              19EE
EA_010              1A06
EA_011              1A26
EA_100              1A4A
EA_101              1A6E
EA_110              1A72
EA_111              1A76
EA_IMMEDIATE        1AC6
EA_LONG             1AB2
EA_TO_D             18FC
EA_WORD             1A9E
EIGHT_TO_BUFF       182A
ENDADDR             106E
ENDMSG              1023
FIND_MODE           1992
FIND_OPCODE         1294
FINISH_PRINT        11E2
GET_BITS            1C5
GET_DATA_REG_NUM    194A
GET_EA_DONE         1ACC
GET_EA_MODE         196A
GET_END_ADDRESS     10B2
GET_INPUT           1086
GET_NOT_SIZE        1464
GET_SIZE            191E
GET_START_ADDRESS   1098
GRAB_FIRST_FOUR_BITS  1282
GRAB_NEXT_WORD      127C
HEX_TO_ASCII        1AD4
IDENTIFY_OPCODE     1248
IMMEDIATE_LONG      13C8
IMMEDIATE_WORD      13C0
INSERT_SPACE        1B40
INVALID_EA          1ACE
INVALID_INPUT       10F0
ITERATE             1142
LETTER_TO_ASCII     1B22
LETTER_TO_HEX       1134
LF                  A
LOAD_ADDRESSES      1220
LONG_TO_BUFFER      1B72
L_SHIFT             170A
L_TO_BUFF           1748
MAIN                107E
NEWLINE             1062
NUMBER_OR_LETTER    1AFC
NUMBER_TO_ASCII     1B1A
NUM_TO_HEX          112C
OPCODE              107A
OPC_0000            12EE
OPC_0100            13D0
OPC_0101            1504
OPC_1000            14DA
OPC_1001            15F8
OPC_1100            160C
OPC_1101            167C
OPC_1110            1690
OPC_ADDI            1330
OPC_ADDQ            1542
OPC_AND             1642
OPC_DIVU            14DE
OPC_JSR             14AE
OPC_LEA             147A
OPC_MULS            1656
OPC_NOP             142E
OPC_NOT             143E
OPC_RTS             14CA
OPC_SUBI            1348
OPC_SUBQ            155A
OPMODE_TYPE         1934
OPOUTPUT            1072
OPTAG               107C
PRINT_ADDRESS       1174
PRINT_INSTRUCTION   1202
PRINT_LONG          11C2
PRINT_MSG           0
PRINT_WORD          11A2
PROCESS_ROEA        18C0
RESTORE_REGS        1276
ROEA_DONE           1916
R_TO_BUFF           1754
SHIFT_COUNT         17EA
SHIFT_DEST_REG      1870
SHIFT_IMMEDIATE_MODE  17D4
SHIFT_MEM_MODE      18AE
SHIFT_MODES         1760
SHIFT_REGISTER_MODE  1830
SHIFT_REG_OR_IMM    1796
SIZE_TO_BUFFER      1B46
STARTADDR           106A
STARTMSG            1000
STB_END             1B7A
STORE_CHAR          113C
STORE_END           116A
STORE_INPUT         1150
STORE_START         1160
TO_BUFFER           4B4
USERADDR            1066
VALID               107D
VALIDATE_INPUT      10CC
WORD_TO_BUFFER      1B6A
