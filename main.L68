0000127C Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/15/2021 3:07:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00000000                            11              
00001000                            12              ORG     $1000
00001000                            13  
00001000  =0000000D                 14  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 15  LF          EQU     $0A 
00001000                            16  
00001000= 31 2E 20 41 64 64 ...     17  rule1:      DC.B    '1. Addresses must be in the range $FFFFFF > x > $6FFF', CR, LF, 0 ' 
00001038= 77 68 65 72 65 20 ...     18  rule1c:     DC.B    'where x is your given address.', CR, LF, 0 '
00001059= 32 2E 20 49 66 20 ...     19  rule2:      DC.B    '2. If you use any letters (A-F), make sure they are upper case.', CR, LF, 0
0000109B= 33 2E 20 49 66 20 ...     20  rule3:      DC.B    '3. If you use constants (DC), make sure you give addresses that', CR, LF, 0 
000010DD= 64 6F 20 6E 6F 74 ...     21  rule3c:     DC.B    'do not include that part of memory (only want to parse instructions).', CR, LF, 0
00001125= 50 6C 65 61 73 65 ...     22  startMsg:   DC.B    'Please enter a starting address.  ', CR, LF, 0
0000114A= 50 6C 65 61 73 65 ...     23  endMsg:     DC.B    'Please enter an ending address. ', CR, LF, 0
0000116D= 65 78 69 74 69 6E ...     24  doneMsg:    DC.B    'exiting...', CR, LF, 0
0000117A= 49 6E 76 61 6C 69 ...     25  badInput:   DC.B    'Invalid Input', CR, LF, 0
0000118A= 0D 0A 00                  26  newline:    DC.B    '', CR, LF, 0
0000118D                            27  
0000118E                            28  userAddr:   DS.L    1
00001192= 00000000                  29              DC.L    0 *Null termination for userAddr
00001196                            30  startAddr:  DS.L    1
0000119A                            31  endAddr:    DS.L    1
0000119E                            32  
0000119E                            33  opcode:     DS.W    1   
000011A0                            34  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
000011A1                            35  opSize:     DS.B    1
000011A2                            36  valid:      DS.B    1
000011A3                            37  
000011A3                            38  ea_mode     DS.B    1
000011A4                            39  ea_register DS.B    1
000011A5                            40  ea_valid    DS.B    1
000011A6                            41  
000011A6                            42  
000011A6                            43  
000011A6                            44  
000011A6                            45  
000011A6                            46  
000011A6                            47  
000011A6                            48  *-----------------------------------------------------------
000011A6                            49  * Macros:
000011A6                            50  *-----------------------------------------------------------
000011A6                            51  
000011A6                            52  PRINT_MSG:  MACRO 
000011A6                            53              CLR.L   D0
000011A6                            54              LEA     \1, A1      ; \1 acts as a parameter
000011A6                            55              MOVE.B  #14, D0     
000011A6                            56              TRAP    #15
000011A6                            57              ENDM
000011A6                            58  
000011A6                            59  CLR_D_REGS: MACRO
000011A6                            60              CLR.L   D0
000011A6                            61              CLR.L   D1
000011A6                            62              CLR.L   D2
000011A6                            63              CLR.L   D3
000011A6                            64              CLR.L   D4
000011A6                            65              CLR.L   D5
000011A6                            66              CLR.L   D6
000011A6                            67              CLR.L   D7
000011A6                            68              ENDM
000011A6                            69  
000011A6                            70  CLR_A_REG:  MACRO
000011A6                            71              CLR.L   \1
000011A6                            72              MOVE.L  \1, \2
000011A6                            73              ENDM              
000011A6                            74  
000011A6                            75  *-----------------------------------------------------------
000011A6                            76  * Parameters:
000011A6                            77  *   \1 should be highest bit in range
000011A6                            78  *   \2 should be lowest bit in range
000011A6                            79  * 
000011A6                            80  * Example: #11, #9
000011A6                            81  *
000011A6                            82  * Return Value:
000011A6                            83  *   D4 = value held within bits \1 and \2
000011A6                            84  *
000011A6                            85  * Registers:
000011A6                            86  *   D4 = holds opcode
000011A6                            87  *   D5 = highest bit in range 
000011A6                            88  *   D6 = lowest bit in range 
000011A6                            89  *   D7 = number of bits we want
000011A6                            90  *-----------------------------------------------------------
000011A6                            91  GET_BITS:   MACRO
000011A6                            92  
000011A6                            93              CLR_D_REGS
000011A6                            94  
000011A6                            95              * Subtract value to find amount to shift by 
000011A6                            96              ADD.B   \1, D7          
000011A6                            97              SUB.B   \2, D7 
000011A6                            98              ADD.B   #1, D7  * add 1 because we start our count from 0
000011A6                            99  
000011A6                           100              * Get high bit offset
000011A6                           101              ADD.B   #15, D5
000011A6                           102              SUB.B   \1, D5
000011A6                           103              
000011A6                           104              * shift out high bits
000011A6                           105              MOVE.W  opcode, D4
000011A6                           106              LSL.W   D5, D4
000011A6                           107              
000011A6                           108              *get low bit offset
000011A6                           109              *16 - NUMBER OF BITS WE WANT
000011A6                           110              ADD.B   #16, D6         * 16 total bits
000011A6                           111              SUB.L   D7, D6          * subtract numBits from 16
000011A6                           112              
000011A6                           113              * shift out low bits
000011A6                           114              LSR.W   D6, D4          * isolate bits
000011A6                           115              ENDM
000011A6                           116  
000011A6                           117  *----------------------Value To Buffer----------------------
000011A6                           118  * Description:
000011A6                           119  * Converts a Hex numbered address (1-9 or A-F) back to an
000011A6                           120  * ASCII value and pushes it to the buffer for printing
000011A6                           121  *
000011A6                           122  * Parameters:
000011A6                           123  *   \1 = should hold value (in hex) you want to push to the buffer
000011A6                           124  *
000011A6                           125  *-----------------------------------------------------------
000011A6                           126  VALUE_TO_BUFFER:  MACRO
000011A6                           127                    MOVE.L  \1, D2  
000011A6                           128                    JSR     NUMBER_OR_LETTER
000011A6                           129                    ENDM
000011A6                           130  *-----------------------------------------------------------
000011A6                           131  
000011A6                           132  *----------------------Size To Buffer-----------------------
000011A6                           133  * Description:
000011A6                           134  * Converts a binary size (Byte = 00, Word = 01, or Long = 10) 
000011A6                           135  * to a letter (B, W, L) and pushes it to the buffer
000011A6                           136  *
000011A6                           137  * Parameters:
000011A6                           138  *   \1 = should hold size (in binary) of the size you want
000011A6                           139  *        to push to the buffer
000011A6                           140  *
000011A6                           141  *-----------------------------------------------------------
000011A6                           142  SIZE_TO_BUFFER:   MACRO
000011A6                           143                    MOVE.L  \1, D3
000011A6                           144                    JSR     FIND_SIZE
000011A6                           145                    ENDM
000011A6                           146  *-----------------------------------------------------------
000011A6                           147  
000011A6                           148  
000011A6                           149  
000011A6                           150  
000011A6                           151  
000011A6                           152  
000011A6                           153  *----------------Decoding EA Mode and Register--------------
000011A6                           154  * Description:
000011A6                           155  * Decodes EA mode and register and pushes to buffer
000011A6                           156  * 
000011A6                           157  * Parameters:
000011A6                           158  *   \1 = high bit of ea
000011A6                           159  *   \2 = low bit of ea
000011A6                           160  *
000011A6                           161  * Registers Used:
000011A6                           162  *   D1 = temp variable
000011A6                           163  *
000011A6                           164  * For Example (most common): 
000011A6                           165  *   DECODE_EA    #5, #0
000011A6                           166  *
000011A6                           167  *-----------------------------------------------------------
000011A6                           168  DECODE_EA:  MACRO
000011A6                           169              CLR_D_REGS
000011A6                           170              MOVE.B      \1, D1
000011A6                           171              JSR         DECODE_EA_HELP
000011A6                           172              JSR         EA_TO_BUFFER
000011A6                           173              ENDM
000011A6                           174  
000011A6                           175  GET_EA_MODE: MACRO
000011A6                           176               GET_BITS        \1, \2
000011A6                           177               MOVE.B          D4, ea_mode
000011A6                           178               ENDM
000011A6                           179  
000011A6                           180  GET_EA_REG:  MACRO
000011A6                           181               GET_BITS        \1, \2
000011A6                           182               MOVE.B          D4, ea_register
000011A6                           183               ENDM
000011A6                           184  *-----------------------------------------------------------
000011A6                           185  
000011A6                           186  *-----------------------------------------------------------
000011A6                           187  DECODE_EA_HELP:
000011A6                           188          
000011A6  B23C 0005                189              CMP.B       #5, D1               * is this bits 5-0?
000011AA  6700 000A                190              BEQ         DECODE_6_TO_0
000011AE                           191  
000011AE  B23C 000B                192              CMP.B       #11, D1              * is this bits 11-6? 
000011B2  6700 0064                193              BEQ         DECODE_11_TO_6
000011B6                           194  
000011B6                           195  DECODE_6_TO_0:
000011B6                           196m             GET_EA_MODE #5, #3               * get ea mode
000011C6                           197mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011CC                           198mm             * GET HIGH BIT OFFSET
000011D2                           199mm             * SHIFT OUT HIGH BITS
000011D8                           200mm             *GET LOW BIT OFFSET
000011D8                           201mm             *16 - NUMBER OF BITS WE WANT
000011DE                           202mm             * SHIFT OUT LOW BITS
000011E4                           203m             GET_EA_REG  #2, #0               * get ea register
000011F4                           204mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011FC                           205mm             * GET HIGH BIT OFFSET
00001202                           206mm             * SHIFT OUT HIGH BITS
00001208                           207mm             *GET LOW BIT OFFSET
00001208                           208mm             *16 - NUMBER OF BITS WE WANT
0000120E                           209mm             * SHIFT OUT LOW BITS
00001214  6000 0064                210              BRA         EA_END
00001218                           211  
00001218                           212  DECODE_11_TO_6:
00001218                           213m             GET_EA_MODE #8, #6               * get ea mode
00001228                           214mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000122E                           215mm             * GET HIGH BIT OFFSET
00001234                           216mm             * SHIFT OUT HIGH BITS
0000123A                           217mm             *GET LOW BIT OFFSET
0000123A                           218mm             *16 - NUMBER OF BITS WE WANT
00001240                           219mm             * SHIFT OUT LOW BITS
00001246                           220m             GET_EA_REG  #11, #9              * get ea register
00001256                           221mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001260                           222mm             * GET HIGH BIT OFFSET
00001268                           223mm             * SHIFT OUT HIGH BITS
0000126E                           224mm             *GET LOW BIT OFFSET
0000126E                           225mm             *16 - NUMBER OF BITS WE WANT
00001274                           226mm             * SHIFT OUT LOW BITS
0000127A                           227  
0000127A                           228  EA_END:
0000127A  4E75                     229              RTS
0000127C                           230  
0000127C                           231  *-----------------------------------------------------------            
0000127C                           232  
0000127C                           233  
0000127C                           234  
0000127C                           235  
0000127C                           236  
0000127C                           237  *----------------------Buffer Macros------------------------
0000127C                           238  * Description:
0000127C                           239  * Pushes commonly used single characters to the buffer
0000127C                           240  *-----------------------------------------------------------
0000127C                           241  INSERT_SPACE:   MACRO
0000127C                           242                  MOVE.B  #' ',(A1)+          * add blank space to buffer
0000127C                           243                  ENDM
0000127C                           244  
0000127C                           245  INSERT_COMMA:   MACRO
0000127C                           246                  MOVE.B  #',',(A1)+          * add blank space to buffer
0000127C                           247                  ENDM
0000127C                           248  
0000127C                           249  INSERT_PERIOD:  MACRO
0000127C                           250                  MOVE.B  #'.',(A1)+          * add blank space to buffer
0000127C                           251                  ENDM
0000127C                           252  
0000127C                           253  INSERT_POUND:   MACRO
0000127C                           254                  MOVE.B  #'#',(A1)+          * add blank space to buffer
0000127C                           255                  ENDM
0000127C                           256  
0000127C                           257  INSERT_DOLLAR:  MACRO
0000127C                           258                  MOVE.B  #'$',(A1)+          * add blank space to buffer
0000127C                           259                  ENDM
0000127C                           260  *-----------------------------------------------------------
0000127C                           261  
0000127C                           262  
0000127C                           263  
0000127C                           264  
0000127C                           265  
0000127C                           266  
0000127C                           267  
0000127C                           268  
0000127C                           269  
0000127C                           270  *-----------------------------------------------------------
0000127C                           271  * Description:  
0000127C                           272  * Main routine
0000127C                           273  *-----------------------------------------------------------
0000127C                           274  
0000127C                           275  *-------------------------MAIN------------------------------
0000127C                           276  MAIN:
0000127C                           277m             PRINT_MSG    rule1
00001288                           278m             PRINT_MSG    rule1c                   
00001294                           279m             PRINT_MSG    rule2
000012A0                           280m             PRINT_MSG    rule3
000012AC                           281m             PRINT_MSG    rule3c
000012B8  6100 000A                282              BSR          GET_INPUT
000012BC  6100 0074                283              BSR          CHECK_ADDRESS
000012C0  6000 018C                284              BRA          LOAD_ADDRESSES
000012C4                           285  *-----------------------------------------------------------
000012C4                           286  
000012C4                           287  
000012C4                           288  
000012C4                           289  
000012C4                           290  
000012C4                           291  
000012C4                           292  
000012C4                           293  
000012C4                           294  *-----------------------------------------------------------
000012C4                           295  * Description:  
000012C4                           296  * Get User Input
000012C4                           297  *
000012C4                           298  * Registers Used:
000012C4                           299  *   D0 = task values
000012C4                           300  *   D1 = stores of size of ascii string in A1 from user input
000012C4                           301  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000012C4                           302  *   A1 = stores an ascii string from user input
000012C4                           303  *-----------------------------------------------------------
000012C4                           304  *-------------------------Get Input-------------------------
000012C4                           305  GET_INPUT:
000012C4                           306m             PRINT_MSG    startMsg
000012D0  6100 002C                307              BSR          GET_ADDRESS   
000012D4  21C7 1196                308              MOVE.L       D7, startAddr
000012D8                           309  
000012D8                           310m             CLR_D_REGS
000012E8                           311  
000012E8                           312m             PRINT_MSG    endMsg
000012F4  6100 0008                313              BSR          GET_ADDRESS   
000012F8  21C7 119A                314              MOVE.L       D7, endAddr
000012FC  4E75                     315              RTS 
000012FE                           316  *-----------------------------------------------------------
000012FE                           317  
000012FE                           318  *------------------------Get Address------------------------
000012FE                           319  GET_ADDRESS:
000012FE  43F8 118E                320              LEA.L   userAddr, A1
00001302  103C 0002                321              MOVE.B  #2, D0
00001306  4E4F                     322              TRAP    #15
00001308                           323  
00001308  6100 0008                324              BSR     CHECK_LENGTH
0000130C  6100 0054                325              BSR     CONVERT_TO_HEX
00001310  4E75                     326              RTS
00001312                           327  *-----------------------------------------------------------
00001312                           328  
00001312                           329  
00001312                           330  
00001312                           331  
00001312                           332  
00001312                           333  
00001312                           334  
00001312                           335  
00001312                           336  
00001312                           337  
00001312                           338  *-----------------------------------------------------------
00001312                           339  * Description:  Validate User Input
00001312                           340  * Constraints:  
00001312                           341  *   User input must be:
00001312                           342  *   Length 4 or Length 8
00001312                           343  *   ASCII character 0-9 or A-F
00001312                           344  *   Starting and ending address with value < $00FFFFFF 
00001312                           345  *   Starting address is before ending address
00001312                           346  *
00001312                           347  * Registers Used:
00001312                           348  *   D0 = task values
00001312                           349  *   D1 = stores of size of ascii string in A1 from user input
00001312                           350  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
00001312                           351  *   A1 = stores an ascii string from user input
00001312                           352  *-----------------------------------------------------------
00001312                           353  
00001312                           354  *----------------------VALIDATE INPUT---------------------------      
00001312                           355  CHECK_LENGTH:
00001312  B23C 0001                356              CMP.B      #1, D1               ; for task 2, length of string is in D1                
00001316  6D00 000C                357              BLT        INVALID_INPUT 
0000131A  B23C 0008                358              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
0000131E  6E00 0004                359              BGT        INVALID_INPUT
00001322  4E75                     360              RTS
00001324                           361  
00001324                           362  INVALID_INPUT:  
00001324                           363m             PRINT_MSG  badInput
00001330  6092                     364              BRA        GET_INPUT
00001332                           365  *-----------------------------------------------------------
00001332                           366  
00001332                           367  *----------------------VALIDATE INPUT---------------------------      
00001332                           368  CHECK_ADDRESS:
00001332  2A38 1196                369              MOVE.L     startAddr, D5
00001336  BAB8 119A                370              CMP.L      endAddr, D5          ; starting address >= ending address?
0000133A  6C00 0016                371              BGE        INVALID_ADDRESS
0000133E                           372  
0000133E  BABC 00006FFF            373              CMP.L      #$6FFF, D5
00001344  6FDE                     374              BLE        INVALID_INPUT 
00001346                           375              
00001346  0CB8 00FFFFFF 119A       376              CMP.L      #$FFFFFF, endAddr
0000134E  6CD4                     377              BGE        INVALID_INPUT
00001350  4E75                     378              RTS
00001352                           379  
00001352                           380  INVALID_ADDRESS:  
00001352                           381m             PRINT_MSG  badInput
0000135E  6000 FF64                382              BRA        GET_INPUT
00001362                           383  *-----------------------------------------------------------
00001362                           384  
00001362                           385  *----------------CONVERT FROM ASCII TO HEX------------------
00001362                           386  CONVERT_TO_HEX:
00001362  0C11 0030                387              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001366  6DBC                     388              BLT        INVALID_INPUT        
00001368                           389  
00001368  0C11 003A                390              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
0000136C  6D00 0012                391              BLT        NUM_TO_HEX      
00001370                           392  
00001370  0C11 0041                393              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001374  6DAE                     394              BLT        INVALID_INPUT             
00001376                           395  
00001376  0C11 0047                396              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
0000137A  6D00 000C                397              BLT        LETTER_TO_HEX
0000137E                           398  
0000137E  60A4                     399              BRA        INVALID_INPUT    
00001380                           400  
00001380                           401  NUM_TO_HEX:      
00001380  0411 0030                402              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001384  6000 000A                403              BRA        STORE_CHAR   
00001388                           404  
00001388                           405  LETTER_TO_HEX:     
00001388  0411 0037                406              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
0000138C  6000 0002                407              BRA        STORE_CHAR
00001390                           408  
00001390                           409  STORE_CHAR:       
00001390  D619                     410              ADD.B      (A1)+, D3           ; keep hex stored in D3           
00001392  6000 0002                411              BRA        ITERATE                 
00001396                           412  
00001396                           413  ITERATE:
00001396  5301                     414              SUB.B      #$1, D1
00001398  B23C 0000                415              CMP.B      #0, D1
0000139C  6700 0006                416              BEQ        STORE_INPUT
000013A0                           417  
000013A0  E98B                     418              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
000013A2  60BE                     419              BRA        CONVERT_TO_HEX
000013A4                           420  
000013A4                           421  STORE_INPUT:
000013A4  2E03                     422              MOVE.L     D3, D7
000013A6  4E75                     423              RTS
000013A8                           424  *-----------------------------------------------------------
000013A8                           425  
000013A8                           426  
000013A8                           427  
000013A8                           428  
000013A8                           429  
000013A8                           430  
000013A8                           431  
000013A8                           432  
000013A8                           433  
000013A8                           434  
000013A8                           435              
000013A8                           436  *--------------------------PRINT----------------------------
000013A8                           437  * Description:
000013A8                           438  * Prints hex addresses according to where we are in the .S file
000013A8                           439  * and source/destination effective addresses
000013A8                           440  *
000013A8                           441  * No Parameters
000013A8                           442  *
000013A8                           443  * Registers:
000013A8                           444  *   D0 = used for tasks and trap #15
000013A8                           445  *   D1 = size of comparison
000013A8                           446  *   D2 = destination for comparisons, holds an address
000013A8                           447  *   D3 = iterator
000013A8                           448  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000013A8                           449  *   A2 = current address (given by user)
000013A8                           450  *-----------------------------------------------------------
000013A8                           451  
000013A8                           452  *----------------------PRINT_ADDRESS------------------------
000013A8                           453  PRINT_ADDRESS:
000013A8                           454              * reset A1 to beginning of string
000013A8                           455m             CLR_D_REGS
000013B8                           456m             CLR_A_REG D0, A1
000013BC                           457              
000013BC                           458              * move current address to D2
000013BC  240A                     459              MOVE.L    A2, D2
000013BE                           460  
000013BE                           461              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
000013BE  223C 00008000            462              MOVE.L    #$8000, D1
000013C4  B481                     463              CMP.L     D1, D2
000013C6  6D00 000E                464              BLT       PRINT_WORD
000013CA                           465              
000013CA                           466              * if absolute long, print long. Range $8000 - $FFFF7FFF
000013CA  223C FFFF8000            467              MOVE.L    #$FFFF8000, D1
000013D0  B481                     468              CMP.L     D1, D2
000013D2  6C00 001C                469              BGE       PRINT_LONG                 
000013D6                           470  
000013D6                           471  PRINT_WORD:
000013D6                           472m             CLR_D_REGS
000013E6  123C 0001                473              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000013EA  3E0A                     474              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000013EC  6000 001C                475              BRA       FINISH_PRINT
000013F0                           476  
000013F0                           477  PRINT_LONG:
000013F0                           478m             CLR_D_REGS
00001400  123C 0003                479              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
00001404  2E0A                     480              MOVE.L    A2, D7
00001406  6000 0002                481              BRA       FINISH_PRINT
0000140A                           482  
0000140A                           483  FINISH_PRINT:
0000140A                           484              * convert hex values back to ASCII
0000140A  4EB9 0000207C            485              JSR       HEX_TO_ASCII
00001410                           486              
00001410                           487              * print out string
00001410  12BC 0000                488              MOVE.B    #00,(A1)
00001414                           489m             CLR_D_REGS
00001424                           490m             CLR_A_REG D0, A1
00001428  103C 000E                491              MOVE.B    #14, D0
0000142C  4E4F                     492              TRAP      #15
0000142E  4E75                     493              RTS
00001430                           494  *-----------------------------------------------------------
00001430                           495  
00001430                           496  *-------------------PRINT_INSTRUCTION-----------------------
00001430                           497  PRINT_INSTRUCTION:    
00001430                           498              * null terminator
00001430  12BC 0000                499              MOVE.B    #00,(A1)              
00001434                           500  
00001434                           501              * reset A1 to beginning of string
00001434  4280                     502              CLR.L     D0
00001436                           503m             CLR_A_REG D0, A1
0000143A                           504  
0000143A                           505              * print out string
0000143A  103C 000E                506              MOVE.B    #14, D0
0000143E  4E4F                     507              TRAP      #15
00001440                           508  
00001440                           509m             PRINT_MSG newline
0000144C  4E75                     510              RTS
0000144E                           511  *-----------------------------------------------------------
0000144E                           512  
0000144E                           513  
0000144E                           514  
0000144E                           515  
0000144E                           516  
0000144E                           517  
0000144E                           518  
0000144E                           519  
0000144E                           520  
0000144E                           521  
0000144E                           522  
0000144E                           523  
0000144E                           524  
0000144E                           525  
0000144E                           526  
0000144E                           527  
0000144E                           528  
0000144E                           529  
0000144E                           530  
0000144E                           531  
0000144E                           532  *---------------------LOAD ADDRESSES------------------------
0000144E                           533  * Description:
0000144E                           534  * Stores INITIAL values into appropriate address registers 
0000144E                           535  * which is necessary to complete before starting identify opcodes loop
0000144E                           536  * Also pushes reigsters onto the stack
0000144E                           537  *
0000144E                           538  * No Parameters
0000144E                           539  *
0000144E                           540  * Registers:
0000144E                           541  *   A2 = current address (given by user)
0000144E                           542  *   A3 = ending address (given by user)
0000144E                           543  *-----------------------------------------------------------
0000144E                           544  LOAD_ADDRESSES: 
0000144E                           545              * reset A1 to beginning of string
0000144E  4280                     546              CLR.L       D0
00001450                           547m             CLR_A_REG   D0, A1
00001454                           548  
00001454                           549              * load start and end registers and print starting address
00001454  2478 1196                550              MOVEA.L     startAddr, A2
00001458  2678 119A                551              MOVEA.L     endAddr, A3
0000145C  6100 FF4A                552              BSR         PRINT_ADDRESS
00001460                           553m             INSERT_SPACE
00001464                           554  
00001464  6100 0040                555              BSR         GRAB_NEXT_WORD
00001468  6100 0042                556              BSR         GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
0000146C                           557  
0000146C                           558              * Push current registers onto the stack (so we can have fresh registers)
0000146C  48E7 FF00                559              MOVEM.L D0-D7,-(SP)                  ; move the old registers onto the stack
00001470  6000 004C                560              BRA     FIND_OPCODE
00001474                           561  *-----------------------------------------------------------
00001474                           562  
00001474                           563  *-----------------------------------------------------------
00001474                           564  * Description:  IDENTIFY OPCODES LOOP
00001474                           565  * Registers:
00001474                           566  *   D0 = used for tasks and trap #15
00001474                           567  *   D1 = size of shifting bits
00001474                           568  *   D2 = destination for shifts
00001474                           569  *   D3 = size of opcode
00001474                           570  *   D4 = used to hold bits returned from SHIFT macro
00001474                           571  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001474                           572  *   A2 = current address (given by user)
00001474                           573  *   A3 = ending address (given by user)
00001474                           574  *-----------------------------------------------------------
00001474                           575  *-------------------IDENTIFY OPCODES------------------------
00001474                           576  * evaluates an opcode based on first four bits (aka opTag)
00001474                           577  * for now only works with one instruction
00001474                           578  *-----------------------------------------------------------
00001474                           579  IDENTIFY_OPCODE:
00001474                           580  
00001474                           581              * print opcode
00001474  61BA                     582              BSR     PRINT_INSTRUCTION
00001476                           583  
00001476                           584              * check if starting address >= ending address
00001476  B5CB                     585              CMPA.L  A3, A2
00001478  6C00 0CA8                586              BGE     DONE
0000147C                           587              
0000147C                           588              * print next address
0000147C  6100 FF2A                589              BSR     PRINT_ADDRESS
00001480                           590m             INSERT_SPACE
00001484                           591              
00001484                           592              ;BSR     RESTORE_REGS           need to fix
00001484                           593  
00001484                           594m             CLR_D_REGS
00001494  6100 0010                595              BSR     GRAB_NEXT_WORD          * grab opcode
00001498  6100 0012                596              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
0000149C                           597             
0000149C  6000 0020                598              BRA     FIND_OPCODE
000014A0                           599  *------------------------------------------------------------
000014A0                           600  
000014A0                           601  *----------------------RESTORE_REGS--------------------------
000014A0                           602  * Description:
000014A0                           603  * Move the old registers onto the stack
000014A0                           604  *------------------------------------------------------------
000014A0                           605  RESTORE_REGS:
000014A0  4CDF 00FF                606              MOVEM.L (SP)+, D0-D7            
000014A4  4E75                     607              RTS
000014A6                           608  *-----------------------------------------------------------
000014A6                           609  
000014A6                           610  *---------Useful Subroutines For Identifying Opcodes--------
000014A6                           611  GRAB_NEXT_WORD:
000014A6                           612              * load current word of bits into D7
000014A6  31DA 119E                613              MOVE.W (A2)+, opcode
000014AA  4E75                     614              RTS
000014AC                           615  
000014AC                           616  GRAB_FIRST_FOUR_BITS:
000014AC                           617              * find first four bits of opcode
000014AC  3438 119E                618              MOVE.W  opcode, D2
000014B0  123C 000C                619              MOVE.B  #12, D1
000014B4  E2AA                     620              LSR.L   D1, D2
000014B6  1002                     621              MOVE.B  D2, D0
000014B8  11C0 11A0                622              MOVE.B  D0, opTag
000014BC  4E75                     623              RTS
000014BE                           624  *-----------------------------------------------------------
000014BE                           625  
000014BE                           626  
000014BE                           627  
000014BE                           628  
000014BE                           629  
000014BE                           630  
000014BE                           631  
000014BE                           632  
000014BE                           633  
000014BE                           634  *----------------------FIND OPCODE--------------------------
000014BE                           635  * Description:
000014BE                           636  * Finds a matching opTag (first four bits of opcode) and 
000014BE                           637  * jumps to that opcode's encoding subroutine
000014BE                           638  *
000014BE                           639  * For example:
000014BE                           640  *               ADD's first four bits = 1101, so I put
000014BE                           641  *               CMP.B #%1101, D0
000014BE                           642  *
000014BE                           643  * No Parameters
000014BE                           644  *
000014BE                           645  * No Registers Used
000014BE                           646  *-----------------------------------------------------------        
000014BE                           647  FIND_OPCODE:
000014BE  0C38 0000 11A0           648              CMP.B   #%0000, opTag 
000014C4  6700 007A                649              BEQ     OPC_0000
000014C8                           650  
000014C8  0C38 0001 11A0           651              CMP.B   #%0001, opTag 
000014CE  6700 016C                652              BEQ     OPC_0001
000014D2                           653  
000014D2  0C38 0002 11A0           654              CMP.B   #%0010, opTag 
000014D8  6700 018C                655              BEQ     OPC_0010
000014DC                           656  
000014DC  0C38 0003 11A0           657              CMP.B   #%0011, opTag 
000014E2  6700 01AC                658              BEQ     OPC_0011
000014E6                           659  
000014E6  0C38 0004 11A0           660              CMP.B   #%0100, opTag 
000014EC  6700 0212                661              BEQ     OPC_0100
000014F0                           662              
000014F0  0C38 0006 11A0           663              CMP.B   #%0110, opTag
000014F6  6700 04AE                664              BEQ     OPC_0110
000014FA                           665  
000014FA  0C38 0005 11A0           666              CMP.B   #%0101, opTag 
00001500  6700 0396                667              BEQ     OPC_0101
00001504                           668  
00001504  0C38 0008 11A0           669              CMP.B   #%1000, opTag
0000150A  6700 035A                670              BEQ     OPC_1000
0000150E                           671  
0000150E  0C38 0009 11A0           672              CMP.B   #%1001, opTag
00001514  6700 062C                673              BEQ     OPC_1001
00001518                           674  
00001518  0C38 000C 11A0           675              CMP.B   #%1100, opTag
0000151E  6700 0636                676              BEQ     OPC_1100
00001522                           677  
00001522  0C38 000D 11A0           678              CMP.B   #%1101, opTag
00001528  6700 06A4                679              BEQ     OPC_1101
0000152C                           680              
0000152C  0C38 000E 11A0           681              CMP.B   #%1110, opTag
00001532  6700 06AE                682              BEQ     OPC_1110
00001536                           683  
00001536                           684              * error, bad opcode
00001536  6000 0002                685              BRA      BAD_OPCODE
0000153A                           686  
0000153A                           687  *-----------------------------------------------------------
0000153A                           688  
0000153A                           689  *-----------------------BAD OPCODE--------------------------
0000153A                           690  BAD_OPCODE:
0000153A  4EF9 00002122            691              JMP      DONE
00001540                           692  *-----------------------------------------------------------
00001540                           693  
00001540                           694  *------------------------OPC_0000---------------------------
00001540                           695  * First four bits = 0000
00001540                           696  * (ADDI, SUBI)
00001540                           697  *-----------------------------------------------------------
00001540                           698  OPC_0000:
00001540                           699m             GET_BITS  #11, #8
00001550                           700m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001558                           701m             * GET HIGH BIT OFFSET
00001560                           702m             * SHIFT OUT HIGH BITS
00001566                           703m             *GET LOW BIT OFFSET
00001566                           704m             *16 - NUMBER OF BITS WE WANT
0000156C                           705m             * SHIFT OUT LOW BITS
0000156E                           706              
0000156E                           707              * is the opcode ADDI?
0000156E  B83C 0006                708              CMP.B     #%0110, D4
00001572  6700 000E                709              BEQ       OPC_ADDI
00001576                           710  
00001576                           711              * is the opcode SUBI?
00001576  B83C 0004                712              CMP.B     #%0100, D4
0000157A  6700 001E                713              BEQ       OPC_SUBI
0000157E                           714  
0000157E  4EF8 153A                715              JMP       BAD_OPCODE
00001582                           716  
00001582                           717  *------------------------OPC_ADDI---------------------------
00001582                           718  OPC_ADDI:
00001582  12FC 0041                719              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001586  12FC 0044                720              MOVE.B  #'D',(A1)+
0000158A  12FC 0044                721              MOVE.B  #'D',(A1)+
0000158E  12FC 0049                722              MOVE.B  #'I',(A1)+
00001592                           723m             INSERT_PERIOD
00001596                           724  
00001596  6100 001A                725              BSR     DECODE_IMMEDIATE
0000159A                           726  
0000159A                           727  *------------------------OPC_SUBI---------------------------
0000159A                           728  OPC_SUBI:            
0000159A  12FC 0053                729              MOVE.B  #'S',(A1)+          * Put ADD into Buff
0000159E  12FC 0055                730              MOVE.B  #'U',(A1)+
000015A2  12FC 0042                731              MOVE.B  #'B',(A1)+
000015A6  12FC 0049                732              MOVE.B  #'I',(A1)+
000015AA                           733m             INSERT_PERIOD
000015AE                           734  
000015AE  6100 0002                735              BSR     DECODE_IMMEDIATE
000015B2                           736  
000015B2                           737  *--------------Subroutines for OPC_0000---------------------  
000015B2                           738  DECODE_IMMEDIATE:
000015B2                           739              * push size to buffer
000015B2                           740m             GET_BITS        #7, #6              * get size bits (gets returned to D4)
000015C2                           741m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000015C8                           742m             * GET HIGH BIT OFFSET
000015CE                           743m             * SHIFT OUT HIGH BITS
000015D4                           744m             *GET LOW BIT OFFSET
000015D4                           745m             *16 - NUMBER OF BITS WE WANT
000015DA                           746m             * SHIFT OUT LOW BITS
000015DC  11C4 11A1                747              MOVE.B          D4, opSize
000015E0                           748m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000015E8                           749  
000015E8                           750              * push #<data> to buffer
000015E8  4EB9 00001618            751              JSR             CHECK_IMMEDIATE
000015EE                           752  
000015EE                           753m             INSERT_COMMA
000015F2                           754m             INSERT_SPACE
000015F6                           755  
000015F6                           756              * push <ea> to buffer
000015F6                           757m             DECODE_EA       #5, #0
00001614  6000 FE5E                758              BRA             IDENTIFY_OPCODE
00001618                           759   
00001618                           760  CHECK_IMMEDIATE:
00001618                           761m             INSERT_POUND
0000161C                           762  
0000161C  B67C 0001                763              CMP     #1, D3
00001620  6F00 000A                764              BLE     IMMEDIATE_WORD
00001624                           765  
00001624  B67C 0002                766              CMP     #2, D3
00001628  6000 000A                767              BRA     IMMEDIATE_LONG
0000162C                           768  
0000162C                           769  IMMEDIATE_WORD:
0000162C  4EB9 00002030            770              JSR     EA_WORD
00001632  4E75                     771              RTS
00001634                           772  
00001634                           773  IMMEDIATE_LONG:
00001634  4EB9 00002044            774              JSR     EA_LONG      
0000163A  4E75                     775              RTS
0000163C                           776  *-----------------------------------------------------------
0000163C                           777  
0000163C                           778  *------------------------OPC_0001---------------------------
0000163C                           779  * First four bits = 0001
0000163C                           780  * (MOVE.B)
0000163C                           781  *-----------------------------------------------------------
0000163C                           782  OPC_0001:
0000163C  12FC 004D                783              MOVE.B   #'M',(A1)+          * Put ADD into Buff
00001640  12FC 004F                784              MOVE.B   #'O',(A1)+
00001644  12FC 0056                785              MOVE.B   #'V',(A1)+
00001648  12FC 0045                786              MOVE.B   #'E',(A1)+
0000164C  12FC 002E                787              MOVE.B   #'.',(A1)+
00001650  12FC 0042                788              MOVE.B   #'B',(A1)+
00001654                           789m             INSERT_SPACE
00001658                           790  
00001658  11FC 0000 11A1           791              MOVE.B   #0, opSize
0000165E                           792  
0000165E  6100 005A                793              BSR      DECODE_MOVE
00001662  6000 FE10                794              BRA      IDENTIFY_OPCODE
00001666                           795  *-----------------------------------------------------------
00001666                           796  
00001666                           797  *------------------------OPC_0010---------------------------
00001666                           798  * First four bits = 0010
00001666                           799  * (MOVE.L)
00001666                           800  *-----------------------------------------------------------
00001666                           801  OPC_0010:
00001666  12FC 004D                802              MOVE.B  #'M',(A1)+          * Put ADD into Buff
0000166A  12FC 004F                803              MOVE.B  #'O',(A1)+
0000166E  12FC 0056                804              MOVE.B  #'V',(A1)+
00001672  12FC 0045                805              MOVE.B  #'E',(A1)+
00001676  12FC 002E                806              MOVE.B  #'.',(A1)+
0000167A  12FC 004C                807              MOVE.B  #'L',(A1)+
0000167E                           808m             INSERT_SPACE
00001682                           809  
00001682  11FC 0002 11A1           810              MOVE.B   #2, opSize
00001688                           811  
00001688  6100 0030                812              BSR      DECODE_MOVE
0000168C  6000 FDE6                813              BRA      IDENTIFY_OPCODE
00001690                           814  *-----------------------------------------------------------
00001690                           815  
00001690                           816  *------------------------OPC_0011---------------------------
00001690                           817  * First four bits = 0011
00001690                           818  * (MOVE.W)
00001690                           819  *-----------------------------------------------------------
00001690                           820  OPC_0011:
00001690  12FC 004D                821              MOVE.B  #'M',(A1)+          * Put ADD into Buff
00001694  12FC 004F                822              MOVE.B  #'O',(A1)+
00001698  12FC 0056                823              MOVE.B  #'V',(A1)+
0000169C  12FC 0045                824              MOVE.B  #'E',(A1)+
000016A0  12FC 002E                825              MOVE.B  #'.',(A1)+
000016A4  12FC 0057                826              MOVE.B  #'W',(A1)+
000016A8                           827m             INSERT_SPACE
000016AC                           828  
000016AC  11FC 0001 11A1           829              MOVE.B   #1, opSize
000016B2                           830  
000016B2  6100 0006                831              BSR      DECODE_MOVE
000016B6  6000 FDBC                832              BRA      IDENTIFY_OPCODE
000016BA                           833  *-----------------------------------------------------------
000016BA                           834  
000016BA                           835  *---------------------Decode Move---------------------------
000016BA                           836  DECODE_MOVE:
000016BA                           837m             DECODE_EA       #5, #0
000016D8                           838              
000016D8                           839m             INSERT_COMMA
000016DC                           840m             INSERT_SPACE
000016E0                           841  
000016E0                           842m             DECODE_EA       #11, #6
000016FE  4E75                     843              RTS
00001700                           844  *-----------------------------------------------------------
00001700                           845  
00001700                           846  *------------------------OPC_0100---------------------------
00001700                           847  * First four bits = 0100
00001700                           848  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
00001700                           849  *-----------------------------------------------------------
00001700                           850  OPC_0100:
00001700                           851  
00001700                           852              * Check if the opcode is NOP
00001700  3438 119E                853              MOVE.W  opcode, D2              * Copy opcode to D2
00001704  B47C 4E71                854              CMP.W   #$4E71, D2              * Check if D2 is equal to NOP (0x4E71 in hex)
00001708  6700 0054                855              BEQ     OPC_NOP                 * If equal branch to label to handle the opcode NOP
0000170C                           856              
0000170C                           857              * Check if the opcode is NOT
0000170C  E082                     858              ASR.L   #8, D2                  * Shift bits to compare
0000170E  B43C 0046                859              CMP.B   #%01000110, D2
00001712  6700 005A                860              BEQ     OPC_NOT
00001716  4282                     861              CLR.L   D2
00001718                           862              
00001718                           863              * Check if the opcode is LEA
00001718  3838 119E                864              MOVE.W   opcode, D4             * Put opcode in D4 to use the macro get bits
0000171C                           865m             GET_BITS #8, #6 
0000172C                           866m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001732                           867m             * GET HIGH BIT OFFSET
00001738                           868m             * SHIFT OUT HIGH BITS
0000173E                           869m             *GET LOW BIT OFFSET
0000173E                           870m             *16 - NUMBER OF BITS WE WANT
00001744                           871m             * SHIFT OUT LOW BITS
00001746  B83C 0007                872              CMP.B    #%0111, D4              * if bits 6-8 are equal to 111, then the opocde is LEA
0000174A  6700 008A                873              BEQ      OPC_LEA
0000174E                           874  
0000174E                           875              * Check if the opcode is JSR
0000174E  B83C 0002                876              CMP.B   #%0010, D4              * if bits 6-8 are equal to 010, then the opocde is LEA
00001752  6700 00D0                877              BEQ     OPC_JSR
00001756                           878  
00001756                           879              * Check if the opcode is RTS
00001756  B83C 0001                880              CMP.B   #%0001, D4              * if bits 6-8 are equal to 001, then the opocde is LEA
0000175A  6700 00FA                881              BEQ     OPC_RTS
0000175E                           882  
0000175E                           883  *---------------------------OPC_NOP--------------------------------
0000175E                           884  
0000175E                           885  OPC_NOP:
0000175E                           886              * Put NOP into A1 buffer for printing
0000175E  12FC 004E                887              MOVE.B  #'N',(A1)+      
00001762  12FC 004F                888              MOVE.B  #'O',(A1)+ 
00001766  12FC 0050                889              MOVE.B  #'P',(A1)+ 
0000176A                           890              
0000176A  6000 FD08                891              BRA     IDENTIFY_OPCODE
0000176E                           892  
0000176E                           893  
0000176E                           894  *-----------------------------OPC_NOT------------------------------
0000176E                           895  
0000176E                           896  OPC_NOT:
0000176E                           897              * Put NOT into A1 buffer for printing
0000176E  12FC 004E                898              MOVE.B  #'N',(A1)+ 
00001772  12FC 004F                899              MOVE.B  #'O',(A1)+
00001776  12FC 0054                900              MOVE.B  #'T',(A1)+
0000177A                           901m             INSERT_PERIOD
0000177E                           902              
0000177E                           903              * Calculate Size (.b,.w.l)
0000177E                           904m             GET_BITS        #7, #6
0000178E                           905m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001794                           906m             * GET HIGH BIT OFFSET
0000179A                           907m             * SHIFT OUT HIGH BITS
000017A0                           908m             *GET LOW BIT OFFSET
000017A0                           909m             *16 - NUMBER OF BITS WE WANT
000017A6                           910m             * SHIFT OUT LOW BITS
000017A8  11C4 11A1                911              MOVE.B          D4, opSize
000017AC                           912m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000017B4                           913m             DECODE_EA       #5, #0
000017D2  6000 FCA0                914              BRA             IDENTIFY_OPCODE
000017D6                           915  
000017D6                           916  *-----------------------------OPC_LEA------------------------------
000017D6                           917  OPC_LEA:
000017D6                           918              * Put LEA into A1 buffer for printing
000017D6  12FC 004C                919              MOVE.B  #'L',(A1)+      
000017DA  12FC 0045                920              MOVE.B  #'E',(A1)+ 
000017DE  12FC 0041                921              MOVE.B  #'A',(A1)+
000017E2                           922m             INSERT_PERIOD
000017E6  12FC 004C                923              MOVE.B  #'L',(A1)+ 
000017EA                           924m             INSERT_SPACE
000017EE                           925  
000017EE  11FC 0002 11A1           926              MOVE.B          #2, opSize      * required to always be long operation
000017F4                           927                      
000017F4                           928m             DECODE_EA       #5, #0
00001812                           929m             INSERT_COMMA
00001816                           930m             INSERT_SPACE
0000181A  4EB9 00001F02            931              JSR GET_DATA_REG_NUM
00001820                           932  
00001820  6000 FC52                933              BRA IDENTIFY_OPCODE    
00001824                           934  
00001824                           935  
00001824                           936  *-----------------------------------------------------------
00001824                           937  
00001824                           938  *-----------------------------OPC_JSR------------------------------
00001824                           939  OPC_JSR:
00001824                           940              * Put LEA into A1 buffer for printing
00001824  12FC 004A                941              MOVE.B  #'J',(A1)+      
00001828  12FC 0053                942              MOVE.B  #'S',(A1)+ 
0000182C  12FC 0052                943              MOVE.B  #'R',(A1)+
00001830                           944m             INSERT_SPACE
00001834                           945              
00001834                           946m             DECODE_EA       #5, #0
00001852  6000 FC20                947              BRA             IDENTIFY_OPCODE  
00001856                           948  
00001856                           949  *-----------------------------OPC_RTS------------------------------
00001856                           950  OPC_RTS:
00001856                           951              * Put LEA into A1 buffer for printing
00001856  12FC 0052                952              MOVE.B  #'R',(A1)+      
0000185A  12FC 0054                953              MOVE.B  #'T',(A1)+ 
0000185E  12FC 0053                954              MOVE.B  #'S',(A1)+
00001862                           955          
00001862  6000 FC10                956              BRA IDENTIFY_OPCODE
00001866                           957  
00001866                           958  *-----------------------------------------------------------
00001866                           959  
00001866                           960  *---------------------------OPC_1000------------------------
00001866                           961  * First four bits = 1001
00001866                           962  * (DIVU)
00001866                           963  *-----------------------------------------------------------
00001866                           964  OPC_1000:   * keeping this in case there's more that start with 1000
00001866  6000 0002                965              BRA     OPC_DIVU
0000186A                           966              
0000186A                           967  OPC_DIVU:
0000186A  12FC 0044                968              MOVE.B  #'D',(A1)+
0000186E  12FC 0049                969              MOVE.B  #'I',(A1)+
00001872  12FC 0056                970              MOVE.B  #'V',(A1)+
00001876  12FC 0055                971              MOVE.B  #'U',(A1)+
0000187A                           972m             INSERT_PERIOD
0000187E  12FC 0057                973              MOVE.B  #'W',(A1)+  * always size word
00001882                           974m             INSERT_SPACE
00001886                           975  
00001886  11FC 0001 11A1           976              MOVE.B  #1, opSize
0000188C                           977              
0000188C                           978              * set the valid bits (since there's only one adressing mode)
0000188C  11FC 00BF 11A2           979              MOVE.B  #%10111111, valid
00001892                           980              
00001892  4EF9 00001ECA            981              JMP     EA_TO_D
00001898                           982  
00001898                           983  *-----------------------------------------------------------
00001898                           984  
00001898                           985  
00001898                           986  
00001898                           987  *-----------------------OPC_0101----------------------------
00001898                           988  * First four bits = 0101
00001898                           989  * (ADDQ, SUBQ)
00001898                           990  *-----------------------------------------------------------
00001898                           991  OPC_0101:
00001898                           992m             GET_BITS  #8, #8
000018A8                           993m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000018AE                           994m             * GET HIGH BIT OFFSET
000018B4                           995m             * SHIFT OUT HIGH BITS
000018BA                           996m             *GET LOW BIT OFFSET
000018BA                           997m             *16 - NUMBER OF BITS WE WANT
000018C0                           998m             * SHIFT OUT LOW BITS
000018C2                           999              
000018C2                          1000              * is the opcode ADDQ?
000018C2  B83C 0000               1001              CMP.B     #%0000, D4
000018C6  6700 000E               1002              BEQ       OPC_ADDQ
000018CA                          1003  
000018CA                          1004              * is the opcode SUBI?
000018CA  B83C 0001               1005              CMP.B     #%0001, D4
000018CE  6700 001E               1006              BEQ       OPC_SUBQ
000018D2                          1007  
000018D2  4EF8 153A               1008              JMP       BAD_OPCODE
000018D6                          1009  
000018D6                          1010  *------------------------OPC_ADDQ---------------------------
000018D6                          1011  OPC_ADDQ:
000018D6  12FC 0041               1012              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000018DA  12FC 0044               1013              MOVE.B  #'D',(A1)+
000018DE  12FC 0044               1014              MOVE.B  #'D',(A1)+
000018E2  12FC 0051               1015              MOVE.B  #'Q',(A1)+
000018E6                          1016m             INSERT_PERIOD
000018EA                          1017  
000018EA  6100 001A               1018              BSR     DECODE_QUICK
000018EE                          1019  
000018EE                          1020  *------------------------OPC_SUBI---------------------------
000018EE                          1021  OPC_SUBQ:            
000018EE  12FC 0053               1022              MOVE.B  #'S',(A1)+          * Put ADD into Buff
000018F2  12FC 0055               1023              MOVE.B  #'U',(A1)+
000018F6  12FC 0042               1024              MOVE.B  #'B',(A1)+
000018FA  12FC 0051               1025              MOVE.B  #'Q',(A1)+
000018FE                          1026m             INSERT_PERIOD
00001902                          1027  
00001902  6100 0002               1028              BSR     DECODE_QUICK
00001906                          1029  
00001906                          1030  *------------------Subroutines for OPC_0101-----------------
00001906                          1031  DECODE_QUICK:            
00001906                          1032              * Get size of operation and push to buffer
00001906  4284                    1033              CLR.L           D4
00001908                          1034m             GET_BITS        #7, #6
00001918                          1035m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000191E                          1036m             * GET HIGH BIT OFFSET
00001924                          1037m             * SHIFT OUT HIGH BITS
0000192A                          1038m             *GET LOW BIT OFFSET
0000192A                          1039m             *16 - NUMBER OF BITS WE WANT
00001930                          1040m             * SHIFT OUT LOW BITS
00001932  11C4 11A1               1041              MOVE.B          D4, opSize
00001936                          1042m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
0000193E                          1043  
0000193E                          1044              * push value of #<data> to buffer
0000193E  4284                    1045              CLR.L            D4
00001940                          1046m             GET_BITS         #11, #9
00001950                          1047m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000195A                          1048m             * GET HIGH BIT OFFSET
00001962                          1049m             * SHIFT OUT HIGH BITS
00001968                          1050m             *GET LOW BIT OFFSET
00001968                          1051m             *16 - NUMBER OF BITS WE WANT
0000196E                          1052m             * SHIFT OUT LOW BITS
00001970                          1053m             INSERT_POUND
00001974                          1054m             VALUE_TO_BUFFER  D4
0000197C                          1055  
0000197C                          1056m             INSERT_COMMA
00001980                          1057m             INSERT_SPACE
00001984                          1058  
00001984                          1059              * push <ea> to buffer
00001984                          1060m             DECODE_EA       #5, #0
000019A2  6000 FAD0               1061              BRA             IDENTIFY_OPCODE
000019A6                          1062  *-----------------------------------------------------------
000019A6                          1063  
000019A6                          1064  
000019A6                          1065  *-----------------------OPC_0110----------------------------
000019A6                          1066  * First four bits = 0110
000019A6                          1067  * BRA or Bcc condtions
000019A6                          1068  *-----------------------------------------------------------
000019A6                          1069  OPC_0110:
000019A6                          1070m             GET_BITS #12, #8
000019B6                          1071m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019BE                          1072m             * GET HIGH BIT OFFSET
000019C6                          1073m             * SHIFT OUT HIGH BITS
000019CC                          1074m             *GET LOW BIT OFFSET
000019CC                          1075m             *16 - NUMBER OF BITS WE WANT
000019D2                          1076m             * SHIFT OUT LOW BITS
000019D4  B83C 0000               1077              CMP.B   #0,D4 *Check if opcode is BRA
000019D8  6700 00DE               1078              BEQ     OPC_BRA
000019DC                          1079              
000019DC                          1080m             GET_BITS #11, #8 *Check if opcode is a Bcc condition
000019EC                          1081m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019F4                          1082m             * GET HIGH BIT OFFSET
000019FC                          1083m             * SHIFT OUT HIGH BITS
00001A02                          1084m             *GET LOW BIT OFFSET
00001A02                          1085m             *16 - NUMBER OF BITS WE WANT
00001A08                          1086m             * SHIFT OUT LOW BITS
00001A0A                          1087              
00001A0A  B83C 000D               1088              CMP.B   #%1101, D4 *Check if opcode is BLT
00001A0E  6700 0016               1089              BEQ     BLT
00001A12                          1090              
00001A12  B83C 000C               1091              CMP.B   #%1100, D4 *Check if opcode is BGE
00001A16  6700 0022               1092              BEQ     BGE
00001A1A                          1093              
00001A1A  B83C 0007               1094              CMP.B   #%0111, D4 *Check if opcode is BEQ
00001A1E  6700 002E               1095              BEQ     BEQ
00001A22                          1096              
00001A22  4EF8 153A               1097              JMP     BAD_OPCODE *If no match if found, we have an error
00001A26                          1098              
00001A26                          1099              
00001A26                          1100              
00001A26                          1101  BLT:
00001A26  12FC 0042               1102              MOVE.B  #'B',(A1)+          * Put BLT into Buff
00001A2A  12FC 004C               1103              MOVE.B  #'L',(A1)+
00001A2E  12FC 0054               1104              MOVE.B  #'T',(A1)+
00001A32  12FC 002E               1105              MOVE.B  #'.',(A1)+
00001A36  6000 002A               1106              BRA     BCC_DISPLACEMENT
00001A3A                          1107  
00001A3A                          1108  BGE:
00001A3A  12FC 0042               1109              MOVE.B  #'B',(A1)+          * Put BGE into Buff
00001A3E  12FC 0047               1110              MOVE.B  #'G',(A1)+
00001A42  12FC 0045               1111              MOVE.B  #'E',(A1)+
00001A46  12FC 002E               1112              MOVE.B  #'.',(A1)+
00001A4A  6000 0016               1113              BRA     BCC_DISPLACEMENT
00001A4E                          1114  
00001A4E                          1115  BEQ:
00001A4E  12FC 0042               1116              MOVE.B  #'B',(A1)+          * Put BEQ into Buff
00001A52  12FC 0045               1117              MOVE.B  #'E',(A1)+
00001A56  12FC 0051               1118              MOVE.B  #'Q',(A1)+
00001A5A  12FC 002E               1119              MOVE.B  #'.',(A1)+
00001A5E  6000 0002               1120              BRA     BCC_DISPLACEMENT
00001A62                          1121  
00001A62                          1122  BCC_DISPLACEMENT:
00001A62                          1123m             GET_BITS #7,#0 *Get displacement bits
00001A72                          1124m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001A7A                          1125m             * GET HIGH BIT OFFSET
00001A80                          1126m             * SHIFT OUT HIGH BITS
00001A86                          1127m             *GET LOW BIT OFFSET
00001A86                          1128m             *16 - NUMBER OF BITS WE WANT
00001A8C                          1129m             * SHIFT OUT LOW BITS
00001A8E                          1130              
00001A8E  B83C 0000               1131              CMP.B   #0,D4 *Check if we have 16 bit dispalcement, branch if true
00001A92  6700 008A               1132              BEQ     SIXTEEN_BIT_DISPLACEMENT
00001A96                          1133              
00001A96  12FC 0042               1134              MOVE.B  #'B',(A1)+
00001A9A                          1135m             INSERT_SPACE 
00001A9E  12FC 0024               1136              MOVE.B  #'$',(A1)+
00001AA2                          1137              
00001AA2  2E0A                    1138              MOVE.L  A2,D7  *Get the current address
00001AA4                          1139              
00001AA4  4884                    1140              EXT.W   D4 *Sign extend to long for addition
00001AA6  48C4                    1141              EXT.L   D4 *Sign extend again, must extend from byte to word and then word to long
00001AA8  DE84                    1142              ADD.L   D4,D7  *Add the displacement
00001AAA                          1143  
00001AAA  123C 0003               1144              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001AAE  4EB9 0000207C           1145              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001AB4                          1146              
00001AB4  6000 F9BE               1147              BRA IDENTIFY_OPCODE   
00001AB8                          1148  
00001AB8                          1149               
00001AB8                          1150                         
00001AB8                          1151  OPC_BRA:
00001AB8  12FC 0042               1152              MOVE.B  #'B',(A1)+          * Put BRA into Buff
00001ABC  12FC 0052               1153              MOVE.B  #'R',(A1)+
00001AC0  12FC 0041               1154              MOVE.B  #'A',(A1)+
00001AC4  12FC 002E               1155              MOVE.B  #'.',(A1)+
00001AC8                          1156              
00001AC8                          1157m             GET_BITS #7,#0 *Get displacement bits
00001AD8                          1158m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001AE0                          1159m             * GET HIGH BIT OFFSET
00001AE6                          1160m             * SHIFT OUT HIGH BITS
00001AEC                          1161m             *GET LOW BIT OFFSET
00001AEC                          1162m             *16 - NUMBER OF BITS WE WANT
00001AF2                          1163m             * SHIFT OUT LOW BITS
00001AF4                          1164              
00001AF4  B83C 0000               1165              CMP.B   #0,D4 *Check if we have 16 bit dispalcement, branch if true
00001AF8  6700 0024               1166              BEQ     SIXTEEN_BIT_DISPLACEMENT
00001AFC                          1167             
00001AFC  12FC 0042               1168              MOVE.B  #'B',(A1)+
00001B00                          1169m             INSERT_SPACE 
00001B04  12FC 0024               1170              MOVE.B  #'$',(A1)+
00001B08                          1171              
00001B08  2E0A                    1172              MOVE.L  A2,D7  *Get the current address
00001B0A                          1173              
00001B0A  4884                    1174              EXT.W   D4 *Sign extend to long for addition
00001B0C  48C4                    1175              EXT.L   D4 *Sign extend again, must extend from byte to word and then word to long
00001B0E  DE84                    1176              ADD.L   D4,D7  *Add the displacement
00001B10                          1177  
00001B10  123C 0003               1178              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001B14  4EB9 0000207C           1179              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001B1A                          1180              
00001B1A  6000 F958               1181              BRA IDENTIFY_OPCODE   
00001B1E                          1182              
00001B1E                          1183  SIXTEEN_BIT_DISPLACEMENT: 
00001B1E  12FC 0057               1184              MOVE.B  #'W',(A1)+
00001B22                          1185m             INSERT_SPACE 
00001B26  12FC 0024               1186              MOVE.B  #'$',(A1)+
00001B2A                          1187              
00001B2A  2E0A                    1188              MOVE.L  A2,D7  *Get the current address
00001B2C                          1189              
00001B2C  4284                    1190              CLR.L D4 *Clear the contents of D4
00001B2E  381A                    1191              MOVE.W  (A2)+,D4 *Increment A2 to get 16 bit displacement value
00001B30                          1192              
00001B30  48C4                    1193              EXT.L   D4  *Sign extend to long for addition
00001B32  DE84                    1194              ADD.L   D4,D7  *Add the displacement 
00001B34                          1195                        
00001B34  123C 0003               1196              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001B38  4EB9 0000207C           1197              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001B3E                          1198              
00001B3E  6000 F934               1199              BRA IDENTIFY_OPCODE 
00001B42                          1200              
00001B42                          1201  
00001B42                          1202  *-----------------------OPC_1001----------------------------
00001B42                          1203  * First four bits = 1001
00001B42                          1204  * (SUB)
00001B42                          1205  *-----------------------------------------------------------
00001B42                          1206  OPC_1001:
00001B42                          1207              * fill in A1 register
00001B42  12FC 0053               1208              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001B46  12FC 0055               1209              MOVE.B  #'U',(A1)+
00001B4A  12FC 0042               1210              MOVE.B  #'B',(A1)+
00001B4E                          1211m             INSERT_PERIOD
00001B52  6000 02D6               1212              BRA     PROCESS_ROEA
00001B56                          1213  *-----------------------------------------------------------
00001B56                          1214  
00001B56                          1215  
00001B56                          1216  
00001B56                          1217  *-----------------------OPC_1100----------------------------
00001B56                          1218  * First four bits = 1100
00001B56                          1219  * (AND, MULS)
00001B56                          1220  *-----------------------------------------------------------
00001B56                          1221  OPC_1100:   
00001B56                          1222              ; check to see if bits 8-6 are 111
00001B56                          1223              ; if they are, then branch to PARSE_MULS
00001B56                          1224              ; else, keep going to parse AND
00001B56                          1225  
00001B56                          1226m             GET_BITS #8, #6
00001B66                          1227m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B6C                          1228m             * GET HIGH BIT OFFSET
00001B72                          1229m             * SHIFT OUT HIGH BITS
00001B78                          1230m             *GET LOW BIT OFFSET
00001B78                          1231m             *16 - NUMBER OF BITS WE WANT
00001B7E                          1232m             * SHIFT OUT LOW BITS
00001B80  B83C 0007               1233              CMP.B    #%00000111, D4
00001B84  6700 001A               1234              BEQ      OPC_MULS
00001B88  6600 0002               1235              BNE      OPC_AND
00001B8C                          1236  
00001B8C                          1237  *---------------------------OPC_AND------------------------
00001B8C                          1238  OPC_AND:    ; AND opcode subroutine
00001B8C                          1239  
00001B8C                          1240              ;-----------------------------
00001B8C                          1241              ; fill A1 with the opcode name
00001B8C  12FC 0041               1242              MOVE.B  #'A',(A1)+
00001B90  12FC 004E               1243              MOVE.B  #'N',(A1)+
00001B94  12FC 0044               1244              MOVE.B  #'D',(A1)+
00001B98                          1245m             INSERT_PERIOD
00001B9C  6000 028C               1246              BRA     PROCESS_ROEA
00001BA0                          1247  
00001BA0                          1248  *---------------------------OPC_MULS------------------------
00001BA0                          1249  OPC_MULS:  * MULS opcode subroutine
00001BA0                          1250  
00001BA0                          1251              * load the command name into the output
00001BA0  12FC 004D               1252              MOVE.B  #'M',(A1)+
00001BA4  12FC 0055               1253              MOVE.B  #'U',(A1)+
00001BA8  12FC 004C               1254              MOVE.B  #'L',(A1)+
00001BAC  12FC 0053               1255              MOVE.B  #'S',(A1)+
00001BB0                          1256m             INSERT_PERIOD
00001BB4  12FC 0057               1257              MOVE.B  #'W',(A1)+ * always size word
00001BB8                          1258m             INSERT_SPACE
00001BBC                          1259  
00001BBC  11FC 0001 11A1          1260              MOVE.B   #1, opSize
00001BC2                          1261              
00001BC2  11FC 00BF 11A2          1262              MOVE.B  #%10111111, valid   * set the valid mode bits (to be used later)
00001BC8                          1263              
00001BC8  4EF9 00001ECA           1264              JMP     EA_TO_D
00001BCE                          1265  *-----------------------------------------------------------
00001BCE                          1266  
00001BCE                          1267  
00001BCE                          1268  *---------------------------opc_1101------------------------
00001BCE                          1269  * First four bits = 1101
00001BCE                          1270  * (ADD)
00001BCE                          1271  *-----------------------------------------------------------
00001BCE                          1272  OPC_1101:
00001BCE                          1273              * fill in A1 register
00001BCE  12FC 0041               1274              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001BD2  12FC 0044               1275              MOVE.B  #'D',(A1)+
00001BD6  12FC 0044               1276              MOVE.B  #'D',(A1)+
00001BDA                          1277m             INSERT_PERIOD
00001BDE  6000 024A               1278              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
00001BE2                          1279  
00001BE2                          1280  *-----------------------------------------------------------
00001BE2                          1281              
00001BE2                          1282  *---------------------------opc_1110------------------------
00001BE2                          1283  * First four bits = 1110
00001BE2                          1284  * (LSL, LSR, ASL, ASR)
00001BE2                          1285  *-----------------------------------------------------------
00001BE2                          1286  OPC_1110:
00001BE2  11FC 003E 11A2          1287              MOVE.B  #%00111110, valid ; valid bits are the same for all shifts
00001BE8                          1288              
00001BE8                          1289              ; check for LSL/LSR vs ASL/ASR
00001BE8                          1290m             GET_BITS #4,#3
00001BF8                          1291m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001BFE                          1292m             * GET HIGH BIT OFFSET
00001C04                          1293m             * SHIFT OUT HIGH BITS
00001C0A                          1294m             *GET LOW BIT OFFSET
00001C0A                          1295m             *16 - NUMBER OF BITS WE WANT
00001C10                          1296m             * SHIFT OUT LOW BITS
00001C12  B83C 0000               1297              CMP.B   #0,D4
00001C16  6700 0006               1298              BEQ     A_SHIFT     ; if bits 4-3 are 00, ASL/ASR
00001C1A  6000 0040               1299              BRA     L_SHIFT     ; if bits 4-3 are 01, LSL/LSR
00001C1E                          1300  
00001C1E                          1301  ;======================================================
00001C1E                          1302  ; getting the opcode name
00001C1E                          1303  A_SHIFT:
00001C1E  12FC 0041               1304              MOVE.B  #'A',(A1)+
00001C22  12FC 0053               1305              MOVE.B  #'S',(A1)+ 
00001C26                          1306m             GET_BITS #8,#8      ; check for shifting left or right
00001C36                          1307m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001C3C                          1308m             * GET HIGH BIT OFFSET
00001C42                          1309m             * SHIFT OUT HIGH BITS
00001C48                          1310m             *GET LOW BIT OFFSET
00001C48                          1311m             *16 - NUMBER OF BITS WE WANT
00001C4E                          1312m             * SHIFT OUT LOW BITS
00001C50  B83C 0001               1313              CMP.B   #01,D4
00001C54  6700 0044               1314              BEQ     L_TO_BUFF
00001C58  6000 004C               1315              BRA     R_TO_BUFF
00001C5C                          1316              
00001C5C                          1317  L_SHIFT:
00001C5C  12FC 004C               1318              MOVE.B  #'L',(A1)+
00001C60  12FC 0053               1319              MOVE.B  #'S',(A1)+
00001C64                          1320m             GET_BITS #8,#8      ; check for shifting left or right
00001C74                          1321m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001C7A                          1322m             * GET HIGH BIT OFFSET
00001C80                          1323m             * SHIFT OUT HIGH BITS
00001C86                          1324m             *GET LOW BIT OFFSET
00001C86                          1325m             *16 - NUMBER OF BITS WE WANT
00001C8C                          1326m             * SHIFT OUT LOW BITS
00001C8E  B83C 0001               1327              CMP.B   #01,D4
00001C92  6700 0006               1328              BEQ     L_TO_BUFF
00001C96  6000 000E               1329              BRA     R_TO_BUFF
00001C9A                          1330              
00001C9A                          1331              
00001C9A                          1332  L_TO_BUFF:
00001C9A  12FC 004C               1333              MOVE.B  #'L',(A1)+
00001C9E  12FC 002E               1334              MOVE.B  #'.',(A1)+
00001CA2                          1335              
00001CA2  6000 000E               1336              BRA     SHIFT_MODES
00001CA6                          1337  
00001CA6                          1338  
00001CA6                          1339  R_TO_BUFF:
00001CA6  12FC 0052               1340              MOVE.B  #'R',(A1)+
00001CAA  12FC 002E               1341              MOVE.B  #'.',(A1)+
00001CAE                          1342  
00001CAE  6000 0002               1343              BRA     SHIFT_MODES
00001CB2                          1344  
00001CB2                          1345  
00001CB2                          1346  ;======================================================
00001CB2                          1347  ; determining which mode to use
00001CB2                          1348  SHIFT_MODES:
00001CB2                          1349m             GET_BITS #7,#6
00001CC2                          1350m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001CC8                          1351m             * GET HIGH BIT OFFSET
00001CCE                          1352m             * SHIFT OUT HIGH BITS
00001CD4                          1353m             *GET LOW BIT OFFSET
00001CD4                          1354m             *16 - NUMBER OF BITS WE WANT
00001CDA                          1355m             * SHIFT OUT LOW BITS
00001CDC  B83C 0003               1356              CMP.B   #3,D4
00001CE0  6600 0006               1357              BNE     SHIFT_REG_OR_IMM    ; jump to register/immediate mode if the bits aren't #%11
00001CE4  6000 011A               1358              BRA     SHIFT_MEM_MODE      ; otherwise, jump to memory mode if the bits are #%11
00001CE8                          1359  
00001CE8                          1360  
00001CE8                          1361  SHIFT_REG_OR_IMM: ; register and immediate shifts
00001CE8                          1362              
00001CE8                          1363              ; get the size
00001CE8                          1364m             SIZE_TO_BUFFER D4
00001CF0                          1365              
00001CF0                          1366              
00001CF0                          1367              ; get the i/r bit to determine immediate/register
00001CF0                          1368m             GET_BITS #5,#5
00001D00                          1369m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001D06                          1370m             * GET HIGH BIT OFFSET
00001D0C                          1371m             * SHIFT OUT HIGH BITS
00001D12                          1372m             *GET LOW BIT OFFSET
00001D12                          1373m             *16 - NUMBER OF BITS WE WANT
00001D18                          1374m             * SHIFT OUT LOW BITS
00001D1A                          1375              ; if i/r is 0, it's an immediate shift
00001D1A                          1376              ; if i/r is 1, it's a register shift
00001D1A  B83C 0000               1377              CMP.B   #0,D4
00001D1E  6700 0006               1378              BEQ     SHIFT_IMMEDIATE_MODE
00001D22  6000 005E               1379              BRA     SHIFT_REGISTER_MODE
00001D26                          1380              
00001D26                          1381  
00001D26                          1382  ;======================================================
00001D26                          1383  ; shifting modes (immediate data, from a register, from memory)
00001D26                          1384  SHIFT_IMMEDIATE_MODE:
00001D26  12FC 0023               1385              MOVE.B  #'#',(A1)+
00001D2A                          1386              
00001D2A  4EB9 00001D3C           1387              JSR     SHIFT_COUNT
00001D30                          1388              
00001D30  12FC 002C               1389              MOVE.B  #',',(A1)+
00001D34  12FC 0020               1390              MOVE.B  #' ',(A1)+
00001D38                          1391              
00001D38  6000 0088               1392              BRA     SHIFT_DEST_REG   ; get the destination register
00001D3C                          1393  
00001D3C                          1394  SHIFT_COUNT: ; moves the size to the buffer
00001D3C                          1395m             GET_BITS #11,#9
00001D4C                          1396m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001D56                          1397m             * GET HIGH BIT OFFSET
00001D5E                          1398m             * SHIFT OUT HIGH BITS
00001D64                          1399m             *GET LOW BIT OFFSET
00001D64                          1400m             *16 - NUMBER OF BITS WE WANT
00001D6A                          1401m             * SHIFT OUT LOW BITS
00001D6C                          1402              
00001D6C  B83C 0000               1403              CMP.B   #0,D4   ; shift bits = 0, shifting 8 bits
00001D70  6700 000A               1404              BEQ     EIGHT_TO_BUFF
00001D74                          1405              
00001D74  0604 0030               1406              ADD.B   #$30,D4
00001D78  12C4                    1407              MOVE.B  D4,(A1)+
00001D7A  4E75                    1408              RTS
00001D7C                          1409              
00001D7C                          1410  EIGHT_TO_BUFF:
00001D7C  12FC 0038               1411              MOVE.B  #'8',(A1)+
00001D80  4E75                    1412              RTS
00001D82                          1413              
00001D82                          1414              
00001D82                          1415  SHIFT_REGISTER_MODE:
00001D82  12FC 0044               1416              MOVE.B  #'D',(A1)+
00001D86                          1417              
00001D86                          1418m             GET_BITS #7, #6
00001D96                          1419m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001D9C                          1420m             * GET HIGH BIT OFFSET
00001DA2                          1421m             * SHIFT OUT HIGH BITS
00001DA8                          1422m             *GET LOW BIT OFFSET
00001DA8                          1423m             *16 - NUMBER OF BITS WE WANT
00001DAE                          1424m             * SHIFT OUT LOW BITS
00001DB0                          1425              
00001DB0  0604 0030               1426              ADD.B   #$30,D4         ; push the register to the buffer
00001DB4  12C4                    1427              MOVE.B  D4,(A1)+
00001DB6  12FC 002C               1428              MOVE.B  #',',(A1)+
00001DBA  12FC 0020               1429              MOVE.B  #' ',(A1)+
00001DBE                          1430              
00001DBE  6000 0002               1431              BRA     SHIFT_DEST_REG   ; get the destination register
00001DC2                          1432  
00001DC2                          1433  SHIFT_DEST_REG:
00001DC2  12FC 0044               1434              MOVE.B  #'D',(A1)+
00001DC6                          1435m             GET_BITS #2,#0
00001DD6                          1436m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001DDE                          1437m             * GET HIGH BIT OFFSET
00001DE4                          1438m             * SHIFT OUT HIGH BITS
00001DEA                          1439m             *GET LOW BIT OFFSET
00001DEA                          1440m             *16 - NUMBER OF BITS WE WANT
00001DF0                          1441m             * SHIFT OUT LOW BITS
00001DF2                          1442              ; add 30 to the register bits
00001DF2  0604 0030               1443              ADD.B   #$30,D4
00001DF6  12C4                    1444              MOVE.B  D4,(A1)+
00001DF8                          1445              
00001DF8  12FC 0000               1446              MOVE.B  #0,(A1)+        ; add the null terminator
00001DFC                          1447              
00001DFC  6000 F676               1448              BRA     IDENTIFY_OPCODE
00001E00                          1449              
00001E00                          1450              
00001E00                          1451  SHIFT_MEM_MODE: ; memory shifts
00001E00  12FC 0057               1452              MOVE.B  #'W',(A1)+      ; always word sized
00001E04  12FC 0020               1453              MOVE.B  #' ',(A1)+
00001E08                          1454              
00001E08                          1455m             DECODE_EA #5, #0
00001E26  6000 F64C               1456              BRA     IDENTIFY_OPCODE
00001E2A                          1457  
00001E2A                          1458  
00001E2A                          1459  *--------------Process Register->Opmode->EA-----------------
00001E2A                          1460  * Description:
00001E2A                          1461  * Parses bits for opcodes that share bit placements:
00001E2A                          1462  * ROEA stands for Register, Opmode, and Effective Address,
00001E2A                          1463  * because the opcodes below share this bit order.
00001E2A                          1464  *
00001E2A                          1465  * Used by: (ADD, SUB, MULS)
00001E2A                          1466  *
00001E2A                          1467  *-----------------------------------------------------------
00001E2A                          1468  PROCESS_ROEA:
00001E2A                          1469m             GET_BITS        #7, #6              * retrieve size
00001E3A                          1470m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001E40                          1471m             * GET HIGH BIT OFFSET
00001E46                          1472m             * SHIFT OUT HIGH BITS
00001E4C                          1473m             *GET LOW BIT OFFSET
00001E4C                          1474m             *16 - NUMBER OF BITS WE WANT
00001E52                          1475m             * SHIFT OUT LOW BITS
00001E54  11C4 11A1               1476              MOVE.B          D4, opSize
00001E58                          1477m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001E60                          1478  
00001E60                          1479m             GET_BITS        #8, #8              * retrieve type  
00001E70                          1480m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001E76                          1481m             * GET HIGH BIT OFFSET
00001E7C                          1482m             * SHIFT OUT HIGH BITS
00001E82                          1483m             *GET LOW BIT OFFSET
00001E82                          1484m             *16 - NUMBER OF BITS WE WANT
00001E88                          1485m             * SHIFT OUT LOW BITS
00001E8A  B83C 0001               1486              CMP.B           #1, D4              * is this Dn + <ea> -> <ea>?
00001E8E  6700 000A               1487              BEQ             D_TO_EA
00001E92  B83C 0000               1488              CMP.B           #0, D4              * is this <ea> + Dn -> <ea>?
00001E96  6700 0032               1489              BEQ             EA_TO_D
00001E9A                          1490  
00001E9A                          1491  D_TO_EA:
00001E9A  4EB9 00001F02           1492              JSR             GET_DATA_REG_NUM
00001EA0                          1493m             INSERT_COMMA
00001EA4                          1494m             INSERT_SPACE
00001EA8                          1495m             DECODE_EA       #5, #0
00001EC6  6000 0032               1496              BRA             ROEA_DONE
00001ECA                          1497  
00001ECA                          1498  EA_TO_D:
00001ECA                          1499m             DECODE_EA       #5, #0
00001EE8                          1500m             INSERT_COMMA
00001EEC                          1501m             INSERT_SPACE
00001EF0  4EB9 00001F02           1502              JSR             GET_DATA_REG_NUM
00001EF6  6000 0002               1503              BRA             ROEA_DONE
00001EFA                          1504  
00001EFA                          1505  ROEA_DONE:
00001EFA                          1506m             INSERT_SPACE
00001EFE  6000 F574               1507              BRA     IDENTIFY_OPCODE
00001F02                          1508  
00001F02                          1509  GET_DATA_REG_NUM:
00001F02  4284                    1510              CLR.L    D4
00001F04                          1511m             GET_BITS #11, #9                     * retrieve high data register number
00001F14                          1512m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001F1E                          1513m             * GET HIGH BIT OFFSET
00001F26                          1514m             * SHIFT OUT HIGH BITS
00001F2C                          1515m             *GET LOW BIT OFFSET
00001F2C                          1516m             *16 - NUMBER OF BITS WE WANT
00001F32                          1517m             * SHIFT OUT LOW BITS
00001F34                          1518  
00001F34                          1519              * store in appropriate register
00001F34  12FC 0044               1520              MOVE.B            #'D',(A1)+                  * add "D" to buffer
00001F38                          1521m             VALUE_TO_BUFFER   D4          
00001F40  4E75                    1522              RTS
00001F42                          1523  *-----------------------------------------------------------
00001F42                          1524  
00001F42                          1525  
00001F42                          1526  
00001F42                          1527  
00001F42                          1528  
00001F42                          1529  
00001F42                          1530  
00001F42                          1531  
00001F42                          1532  
00001F42                          1533  
00001F42                          1534  
00001F42                          1535  
00001F42                          1536  *----------------------EA_TO_BUFFER------------------
00001F42                          1537  * Description:
00001F42                          1538  * Evaluates the ea mode and register of an opcode 
00001F42                          1539  * (usually last 6 bits of instruction format),
00001F42                          1540  * and adds it to A1 to be printed out
00001F42                          1541  *
00001F42                          1542  * No Parameters
00001F42                          1543  *
00001F42                          1544  * Registers Used:
00001F42                          1545  *   D1 = amount to shift the opcode
00001F42                          1546  *   D2 = destination for shifts
00001F42                          1547  *-----------------------------------------------------------
00001F42                          1548  EA_TO_BUFFER:                            
00001F42  0C38 0000 11A3          1549              CMP.B   #%0000, ea_mode        * Direct Data Register
00001F48  6700 004C               1550              BEQ     EA_000
00001F4C                          1551  
00001F4C  0C38 0001 11A3          1552              CMP.B   #%0001, ea_mode        * Direct Address Register
00001F52  6700 0052               1553              BEQ     EA_001
00001F56                          1554  
00001F56  0C38 0002 11A3          1555              CMP.B   #%0010, ea_mode        * Indirect Address Register
00001F5C  6700 0058               1556              BEQ     EA_010
00001F60                          1557  
00001F60  0C38 0003 11A3          1558              CMP.B   #%0011, ea_mode        * Post Increment
00001F66  6700 0066               1559              BEQ     EA_011
00001F6A                          1560  
00001F6A  0C38 0004 11A3          1561              CMP.B   #%0100, ea_mode        * Pre Decrement
00001F70  6700 0078               1562              BEQ     EA_100
00001F74                          1563  
00001F74  0C38 0005 11A3          1564              CMP.B   #%0101, ea_mode        * Not necessary, go to bad EA
00001F7A  6700 008A               1565              BEQ     EA_101
00001F7E                          1566  
00001F7E  0C38 0006 11A3          1567              CMP.B   #%0110, ea_mode        * Not necessary, go to bad EA
00001F84  6700 0084               1568              BEQ     EA_110
00001F88                          1569  
00001F88  0C38 0007 11A3          1570              CMP.B   #%0111, ea_mode        * Absolute or immediate address
00001F8E  6700 007E               1571              BEQ     EA_111
00001F92                          1572  
00001F92  6000 00E2               1573              BRA    INVALID_EA
00001F96                          1574  
00001F96                          1575  *----------------------------Direct Data Register------------------------
00001F96                          1576  EA_000:
00001F96  12FC 0044               1577              MOVE.B      #'D',(A1)+              * add "D" to buffer
00001F9A  0638 0030 11A4          1578              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001FA0  12F8 11A4               1579              MOVE.B      ea_register, (A1)+      * register # to buffer                  
00001FA4  4E75                    1580              RTS                                
00001FA6                          1581  
00001FA6                          1582  *----------------------------Direct Address Register------------------------
00001FA6                          1583  EA_001:
00001FA6  12FC 0041               1584              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001FAA  0638 0030 11A4          1585              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001FB0  12F8 11A4               1586              MOVE.B      ea_register, (A1)+      * register # to buffer               
00001FB4  4E75                    1587              RTS                            
00001FB6                          1588  
00001FB6                          1589  *----------------------------Indirect Address Register------------------------
00001FB6                          1590  EA_010:
00001FB6  12FC 0028               1591              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001FBA  12FC 0041               1592              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001FBE  0638 0030 11A4          1593              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001FC4  12F8 11A4               1594              MOVE.B      ea_register, (A1)+      * register # to buffer     
00001FC8  12FC 0029               1595              MOVE.B      #')',(A1)+              * add ")" to buffer
00001FCC  4E75                    1596              RTS                            
00001FCE                          1597  
00001FCE                          1598  *----------------------------Post Increment------------------------
00001FCE                          1599  EA_011:
00001FCE  12FC 0028               1600              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001FD2  12FC 0041               1601              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001FD6  0638 0030 11A4          1602              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001FDC  12F8 11A4               1603              MOVE.B      ea_register, (A1)+      * register # to buffer 
00001FE0  12FC 0029               1604              MOVE.B      #')',(A1)+              * add ")" to buffer
00001FE4  12FC 002B               1605              MOVE.B      #'+',(A1)+              * add "+" to buffer 
00001FE8  4E75                    1606              RTS                              
00001FEA                          1607  
00001FEA                          1608  *----------------------------Pre Decrement------------------------
00001FEA                          1609  EA_100:
00001FEA  12FC 002D               1610              MOVE.B      #'-',(A1)+              * add "-" to buffer
00001FEE  12FC 0028               1611              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001FF2  12FC 0041               1612              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001FF6  0638 0030 11A4          1613              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001FFC  12F8 11A4               1614              MOVE.B      ea_register, (A1)+      * register # to buffer 
00002000  12FC 0029               1615              MOVE.B      #')',(A1)+              * add ")" to buffer
00002004  4E75                    1616              RTS
00002006                          1617  
00002006                          1618  *----------------------------Not necessary, go to bad EA------------------------
00002006                          1619  EA_101:
00002006  6000 006E               1620              BRA         INVALID_EA        
0000200A                          1621  
0000200A                          1622  *----------------------------Not necessary, go to bad EA------------------------
0000200A                          1623  EA_110:
0000200A  6000 006A               1624              BRA         INVALID_EA        
0000200E                          1625  
0000200E                          1626  *----------------------------Absolute or immediate address------------------------
0000200E                          1627  EA_111:
0000200E                          1628              * D405      0 0003456  23345245
0000200E                          1629              * ADD.L     $1234, D0
0000200E                          1630  
0000200E                          1631              * 8 bit value
0000200E                          1632              * 11111111
0000200E                          1633  
0000200E                          1634              * 11111011 - Direct data register would be Invalid
0000200E                          1635              * 00000100
0000200E                          1636              * 00000000 -> invalid code
0000200E                          1637  
0000200E                          1638              * and.b     #$F, Dn        ---->  10000000
0000200E                          1639              * cmp.b     #%10000000, Dn  
0000200E                          1640  
0000200E                          1641              * check against valid bits
0000200E                          1642                  * if invalid, branch to invalid opcode subroutine
0000200E                          1643                      * if the mode is 111, then go back and print out addresses
0000200E                          1644  
0000200E  0C38 0000 11A4          1645              CMP.B       #%000, ea_register                * compare to determine if it's a word
00002014  6700 001A               1646              BEQ         EA_WORD                  * put word address in buffer
00002018                          1647  
00002018  0C38 0001 11A4          1648              CMP.B       #%001, ea_register                * compare to determine if it's a long
0000201E  6700 0024               1649              BEQ         EA_LONG                  * put long address in buffer
00002022                          1650              
00002022  0C38 0004 11A4          1651              CMP.B       #%100, ea_register
00002028  6700 002E               1652              BEQ         EA_IMMEDIATE             * always print a long if it's immediate data
0000202C                          1653  
0000202C                          1654              * Invalid EA mode/register
0000202C  6000 0048               1655              BRA         INVALID_EA
00002030                          1656  
00002030                          1657  EA_WORD:
00002030  12FC 0024               1658              MOVE.B      #'$', (A1)+
00002034  4281                    1659              CLR.L       D1
00002036  123C 0001               1660              MOVE.B      #1, D1
0000203A  3E1A                    1661              MOVE.W      (A2)+, D7
0000203C  6100 003E               1662              BSR         HEX_TO_ASCII
00002040  6000 0032               1663              BRA         GET_EA_DONE
00002044                          1664  
00002044                          1665  EA_LONG:
00002044  12FC 0024               1666              MOVE.B      #'$', (A1)+
00002048  4281                    1667              CLR.L       D1
0000204A  123C 0003               1668              MOVE.B      #3, D1
0000204E  2E1A                    1669              MOVE.L      (A2)+, D7   
00002050  6100 002A               1670              BSR         HEX_TO_ASCII
00002054  6000 001E               1671              BRA         GET_EA_DONE
00002058                          1672  
00002058                          1673  EA_IMMEDIATE:
00002058  12FC 0023               1674              MOVE.B      #'#', (A1)+
0000205C                          1675  
0000205C  0C38 0000 11A1          1676              CMP.B       #0, opSize          
00002062  67CC                    1677              BEQ         EA_WORD
00002064                          1678  
00002064  0C38 0001 11A1          1679              CMP.B       #1, opSize          
0000206A  67C4                    1680              BEQ         EA_WORD          
0000206C                          1681              
0000206C  0C38 0002 11A1          1682              CMP.B       #2, opSize
00002072  60D0                    1683              BRA         EA_LONG             
00002074                          1684  
00002074                          1685  GET_EA_DONE:
00002074  4E75                    1686              RTS
00002076                          1687  
00002076                          1688  *------------------Invalid Effective Address----------------
00002076                          1689  INVALID_EA:
00002076  4EF9 00002122           1690              JMP      DONE
0000207C                          1691  *-----------------------------------------------------------
0000207C                          1692  
0000207C                          1693  
0000207C                          1694  
0000207C                          1695  
0000207C                          1696  
0000207C                          1697  
0000207C                          1698  
0000207C                          1699  
0000207C                          1700  
0000207C                          1701  *----------------------HEX TO ASCII-------------------------
0000207C                          1702  * Description:
0000207C                          1703  * Converts a Hex numbered address (1-9 or A-F) back to an
0000207C                          1704  * ASCII value for printing
0000207C                          1705  *
0000207C                          1706  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
0000207C                          1707  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
0000207C                          1708  *   D7 = holds the original address to parse (either word or long, for example: $7000)
0000207C                          1709  *
0000207C                          1710  *
0000207C                          1711  * Registers Used:
0000207C                          1712  *   D0 = number of bits to remove
0000207C                          1713  *   D2 = holds either top four bits or bottom four bits of each byte in D6
0000207C                          1714  *   D3 = holds temp data
0000207C                          1715  *   D6 = holds part of address (used as temp variable)
0000207C                          1716  *   A1 = used for buffer
0000207C                          1717  *-----------------------------------------------------------
0000207C                          1718  HEX_TO_ASCII:
0000207C  1001                    1719              MOVE.B   D1, D0             * current number of bytes to remove
0000207E  C1FC 0008               1720              MULS.W   #8, D0             * number of bits to remove
00002082                          1721  
00002082  2C07                    1722              MOVE.L   D7, D6             * load original address to parse
00002084  E0AE                    1723              LSR.L    D0, D6             * remove lowest byte(s)
00002086                          1724  
00002086                          1725              * isolate first four bits
00002086  1406                    1726              MOVE.B   D6, D2
00002088  E80A                    1727              LSR.B    #4, D2 
0000208A  6100 0018               1728              BSR      NUMBER_OR_LETTER
0000208E                          1729  
0000208E                          1730              * isolate second set of four bits
0000208E  1406                    1731              MOVE.B   D6, D2
00002090  E90A                    1732              LSL.B    #4, D2 
00002092  E80A                    1733              LSR.B    #4, D2 
00002094  6100 000E               1734              BSR      NUMBER_OR_LETTER
00002098                          1735  
00002098  5301                    1736              SUB.B    #1, D1             * iterate
0000209A  B23C 0000               1737              CMP.B    #0, D1             * done if equal
0000209E  6D00 0036               1738              BLT      ATH_DONE
000020A2                          1739  
000020A2  60D8                    1740              BRA      HEX_TO_ASCII
000020A4                          1741  
000020A4                          1742  NUMBER_OR_LETTER:
000020A4  1602                    1743              MOVE.B   D2, D3
000020A6  0603 0030               1744              ADD.B    #$30, D3           
000020AA  B63C 0039               1745              CMP.B    #$39, D3           * is byte in D2 a number?
000020AE  6F00 0012               1746              BLE      NUMBER_TO_ASCII
000020B2                          1747              
000020B2  1602                    1748              MOVE.B   D2, D3
000020B4  0603 0037               1749              ADD.B    #$37, D3           
000020B8  B63C 0039               1750              CMP.B    #$39, D3           * is byte in D2 a letter?
000020BC  6C00 000C               1751              BGE      LETTER_TO_ASCII
000020C0                          1752  
000020C0  60B4                    1753              BRA      INVALID_EA
000020C2                          1754  
000020C2                          1755  NUMBER_TO_ASCII:
000020C2  0602 0030               1756              ADD.B    #$30, D2           * Get the hex range from '0-9'
000020C6  6000 000A               1757              BRA      ADD_TO_BUFFER
000020CA                          1758  
000020CA                          1759  LETTER_TO_ASCII:
000020CA  0602 0037               1760              ADD.B    #$37, D2           * Get the hex range from 'A-F'
000020CE  6000 0002               1761              BRA      ADD_TO_BUFFER
000020D2                          1762  
000020D2                          1763  ADD_TO_BUFFER:
000020D2  12C3                    1764              MOVE.B   D3, (A1)+          * add part of address to buffer    
000020D4  4E75                    1765              RTS
000020D6                          1766  
000020D6                          1767  ATH_DONE:
000020D6                          1768m             CLR_D_REGS
000020E6  4E75                    1769              RTS
000020E8                          1770  *-----------------------------------------------------------
000020E8                          1771  
000020E8                          1772  
000020E8                          1773  
000020E8                          1774  
000020E8                          1775  
000020E8                          1776  
000020E8                          1777  
000020E8                          1778  
000020E8                          1779  
000020E8                          1780  *---------------------SIZE TO BUFFER------------------------
000020E8                          1781  * Description:
000020E8                          1782  * Evaluates the size of an opcode and adds it to A1 to be printed out
000020E8                          1783  *
000020E8                          1784  * Parameters:
000020E8                          1785  *   D3 = size of opcode
000020E8                          1786  *
000020E8                          1787  * Registers Used:
000020E8                          1788  *   A1: adding words/numbers to buffer
000020E8                          1789  *-----------------------------------------------------------
000020E8                          1790  FIND_SIZE: 
000020E8  B63C 0000               1791              CMP.B   #%0000,D3            
000020EC  6700 0016               1792              BEQ     BYTE_TO_BUFFER              
000020F0                          1793  
000020F0  B63C 0001               1794              CMP.B   #%0001,D3             * is this a word?
000020F4  6700 0016               1795              BEQ     WORD_TO_BUFFER
000020F8                          1796  
000020F8  B63C 0002               1797              CMP.B   #%0010,D3             * is this a long?
000020FC  6700 0016               1798              BEQ     LONG_TO_BUFFER             
00002100                          1799        
00002100  4EF8 153A               1800              JMP     BAD_OPCODE  
00002104                          1801              
00002104                          1802  BYTE_TO_BUFFER:
00002104  12FC 0042               1803              MOVE.B  #'B', (A1)+           * add B to buffer
00002108  6000 0012               1804              BRA     STB_END             
0000210C                          1805              
0000210C                          1806  WORD_TO_BUFFER:
0000210C  12FC 0057               1807              MOVE.B  #'W', (A1)+          * add W to buffer
00002110  6000 000A               1808              BRA     STB_END             
00002114                          1809  
00002114                          1810  LONG_TO_BUFFER:
00002114  12FC 004C               1811              MOVE.B  #'L',(A1)+          * add L to buffer
00002118  6000 0002               1812              BRA     STB_END             
0000211C                          1813  
0000211C                          1814  STB_END:
0000211C  12FC 0020               1815              MOVE.B  #' ',(A1)+          * add blank space to buffer
00002120  4E75                    1816              RTS                         
00002122                          1817  *-----------------------------------------------------------
00002122                          1818  
00002122                          1819  
00002122                          1820  
00002122                          1821  
00002122                          1822  
00002122                          1823  
00002122                          1824  *-------------------------DONE-------------------------------
00002122                          1825  DONE:
00002122                          1826m             CLR_A_REG D0, A1
00002126                          1827  
00002126                          1828              * add 'SIMHAULT' to buffer
00002126  12FC 0053               1829              MOVE.B  #'S',(A1)+      
0000212A  12FC 0049               1830              MOVE.B  #'I',(A1)+         
0000212E  12FC 004D               1831              MOVE.B  #'M',(A1)+         
00002132  12FC 0048               1832              MOVE.B  #'H',(A1)+        
00002136  12FC 0041               1833              MOVE.B  #'A',(A1)+                 
0000213A  12FC 004C               1834              MOVE.B  #'L',(A1)+          
0000213E  12FC 0054               1835              MOVE.B  #'T',(A1)+         
00002142  12FC 0000               1836              MOVE.B  #00,(A1)+         
00002146                          1837  
00002146                          1838m             CLR_A_REG D0, A1
0000214A                          1839              
0000214A                          1840              * print out string
0000214A  103C 000E               1841              MOVE.B    #14, D0
0000214E  4E4F                    1842              TRAP      #15
00002150                          1843              
00002150                          1844m             CLR_A_REG D0, A1
00002154                          1845  
00002154                          1846  
00002154                          1847              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       20D2
ATH_DONE            20D6
A_SHIFT             1C1E
BADINPUT            117A
BAD_OPCODE          153A
BCC_DISPLACEMENT    1A62
BEQ                 1A4E
BGE                 1A3A
BLT                 1A26
BYTE_TO_BUFFER      2104
CHECK_ADDRESS       1332
CHECK_IMMEDIATE     1618
CHECK_LENGTH        1312
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      1362
CR                  D
DECODE_11_TO_6      1218
DECODE_6_TO_0       11B6
DECODE_EA           57B
DECODE_EA_HELP      11A6
DECODE_IMMEDIATE    15B2
DECODE_MOVE         16BA
DECODE_QUICK        1906
DONE                2122
DONEMSG             116D
D_TO_EA             1E9A
EA_000              1F96
EA_001              1FA6
EA_010              1FB6
EA_011              1FCE
EA_100              1FEA
EA_101              2006
EA_110              200A
EA_111              200E
EA_END              127A
EA_IMMEDIATE        2058
EA_LONG             2044
EA_MODE             11A3
EA_REGISTER         11A4
EA_TO_BUFFER        1F42
EA_TO_D             1ECA
EA_VALID            11A5
EA_WORD             2030
EIGHT_TO_BUFF       1D7C
ENDADDR             119A
ENDMSG              114A
FIND_OPCODE         14BE
FIND_SIZE           20E8
FINISH_PRINT        140A
GET_ADDRESS         12FE
GET_BITS            1C5
GET_DATA_REG_NUM    1F02
GET_EA_DONE         2074
GET_EA_MODE         613
GET_EA_REG          675
GET_INPUT           12C4
GRAB_FIRST_FOUR_BITS  14AC
GRAB_NEXT_WORD      14A6
HEX_TO_ASCII        207C
IDENTIFY_OPCODE     1474
IMMEDIATE_LONG      1634
IMMEDIATE_WORD      162C
INSERT_COMMA        73A
INSERT_DOLLAR       857
INSERT_PERIOD       799
INSERT_POUND        7F8
INSERT_SPACE        6DB
INVALID_ADDRESS     1352
INVALID_EA          2076
INVALID_INPUT       1324
ITERATE             1396
LETTER_TO_ASCII     20CA
LETTER_TO_HEX       1388
LF                  A
LOAD_ADDRESSES      144E
LONG_TO_BUFFER      2114
L_SHIFT             1C5C
L_TO_BUFF           1C9A
MAIN                127C
NEWLINE             118A
NUMBER_OR_LETTER    20A4
NUMBER_TO_ASCII     20C2
NUM_TO_HEX          1380
OPCODE              119E
OPC_0000            1540
OPC_0001            163C
OPC_0010            1666
OPC_0011            1690
OPC_0100            1700
OPC_0101            1898
OPC_0110            19A6
OPC_1000            1866
OPC_1001            1B42
OPC_1100            1B56
OPC_1101            1BCE
OPC_1110            1BE2
OPC_ADDI            1582
OPC_ADDQ            18D6
OPC_AND             1B8C
OPC_BRA             1AB8
OPC_DIVU            186A
OPC_JSR             1824
OPC_LEA             17D6
OPC_MULS            1BA0
OPC_NOP             175E
OPC_NOT             176E
OPC_RTS             1856
OPC_SUBI            159A
OPC_SUBQ            18EE
OPSIZE              11A1
OPTAG               11A0
PRINT_ADDRESS       13A8
PRINT_INSTRUCTION   1430
PRINT_LONG          13F0
PRINT_MSG           0
PRINT_WORD          13D6
PROCESS_ROEA        1E2A
RESTORE_REGS        14A0
ROEA_DONE           1EFA
RULE1               1000
RULE1C              1038
RULE2               1059
RULE3               109B
RULE3C              10DD
R_TO_BUFF           1CA6
SHIFT_COUNT         1D3C
SHIFT_DEST_REG      1DC2
SHIFT_IMMEDIATE_MODE  1D26
SHIFT_MEM_MODE      1E00
SHIFT_MODES         1CB2
SHIFT_REGISTER_MODE  1D82
SHIFT_REG_OR_IMM    1CE8
SIXTEEN_BIT_DISPLACEMENT  1B1E
SIZE_TO_BUFFER      51C
STARTADDR           1196
STARTMSG            1125
STB_END             211C
STORE_CHAR          1390
STORE_INPUT         13A4
USERADDR            118E
VALID               11A2
VALUE_TO_BUFFER     4B4
WORD_TO_BUFFER      210C
