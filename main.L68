0000107E Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/4/2021 9:50:37 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00001000                            11              ORG     $1000
00001000                            12  
00001000  =0000000D                 13  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 14  LF          EQU     $0A 
00001000                            15  
00001000= 50 6C 65 61 73 65 ...     16  startMsg:   DC.B    'Please enter a starting address ', CR, LF, 0
00001023= 50 6C 65 61 73 65 ...     17  endMsg:     DC.B    'Please enter an ending address ', CR, LF, 0
00001045= 65 78 69 74 69 6E ...     18  doneMsg:    DC.B    'exiting...', CR, LF, 0
00001052= 49 6E 76 61 6C 69 ...     19  badInput:   DC.B    'Invalid Input', CR, LF, 0
00001062= 0D 0A 00                  20  newline:    DC.B    '', CR, LF, 0
00001065                            21  
00001066                            22  userAddr:   DS.L    1
0000106A                            23  startAddr:  DS.L    1
0000106E                            24  endAddr:    DS.L    1
00001072                            25  
00001072                            26  opOutput:   DS.L    2
0000107A                            27  
0000107A                            28  opcode:     DS.W    1   
0000107C                            29  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
0000107D                            30  valid:      DS.B    1
0000107E                            31  
0000107E                            32  
0000107E                            33  
0000107E                            34  
0000107E                            35  
0000107E                            36  
0000107E                            37  *-----------------------------------------------------------
0000107E                            38  * Macros:
0000107E                            39  *-----------------------------------------------------------
0000107E                            40  
0000107E                            41  PRINT_MSG:  MACRO 
0000107E                            42              CLR.L   D0
0000107E                            43              LEA     \1, A1      ; \1 acts as a parameter
0000107E                            44              MOVE.B  #14, D0     
0000107E                            45              TRAP    #15
0000107E                            46              ENDM
0000107E                            47  
0000107E                            48  CLR_D_REGS: MACRO
0000107E                            49              CLR.L   D0
0000107E                            50              CLR.L   D1
0000107E                            51              CLR.L   D2
0000107E                            52              CLR.L   D3
0000107E                            53              CLR.L   D4
0000107E                            54              CLR.L   D5
0000107E                            55              CLR.L   D6
0000107E                            56              CLR.L   D7
0000107E                            57              ENDM
0000107E                            58  
0000107E                            59  CLR_A_REG:  MACRO
0000107E                            60              CLR.L   \1
0000107E                            61              MOVE.L  \1, \2
0000107E                            62              ENDM              
0000107E                            63  
0000107E                            64  *-----------------------------------------------------------
0000107E                            65  * \1 should be highest bit in range
0000107E                            66  * \2 should be lowest bit in range
0000107E                            67  * Result will be returned in D4
0000107E                            68  * Example: #11, #9
0000107E                            69  *
0000107E                            70  * Return Value:
0000107E                            71  *   D4 = value held within bits \1 and \2
0000107E                            72  *
0000107E                            73  * Registers:
0000107E                            74  *   D4 = holds opcode
0000107E                            75  *   D5 = highest bit in range 
0000107E                            76  *   D6 = lowest bit in range 
0000107E                            77  *   D7 = number of bits we want
0000107E                            78  *-----------------------------------------------------------
0000107E                            79  GET_BITS:   MACRO
0000107E                            80              * Subtract value to find amount to shift by 
0000107E                            81              ADD.B   \1, D7          
0000107E                            82              SUB.B   \2, D7 
0000107E                            83              ADD.B   #1, D7  * add 1 because we start our count from 0
0000107E                            84  
0000107E                            85              * Get high bit offset
0000107E                            86              ADD.B   #15, D5
0000107E                            87              SUB.B   \1, D5
0000107E                            88              
0000107E                            89              * shift out high bits
0000107E                            90              MOVE.W  opcode, D4
0000107E                            91              LSL.W   D5, D4
0000107E                            92              
0000107E                            93              *get low bit offset
0000107E                            94              *16 - NUMBER OF BITS WE WANT
0000107E                            95              ADD.B   #16, D6         * 16 total bits
0000107E                            96              SUB.L   D7, D6          * subtract numBits from 16
0000107E                            97              
0000107E                            98              * shift out low bits
0000107E                            99              LSR.W   D6, D4          * isolate bits
0000107E                           100              ENDM
0000107E                           101  
0000107E                           102  
0000107E                           103  *-----------------------------------------------------------
0000107E                           104  * Description:  
0000107E                           105  * Main routine
0000107E                           106  *-----------------------------------------------------------
0000107E                           107  
0000107E                           108  *-------------------------MAIN------------------------------
0000107E                           109  MAIN:
0000107E  6100 0006                110              BSR     GET_INPUT
00001082  6000 01C8                111              BRA     LOAD_ADDRESSES
00001086                           112  *-----------------------------------------------------------
00001086                           113  
00001086                           114  
00001086                           115  
00001086                           116  
00001086                           117  
00001086                           118  
00001086                           119  
00001086                           120  
00001086                           121  *-----------------------------------------------------------
00001086                           122  * Description:  
00001086                           123  * Get User Input
00001086                           124  *
00001086                           125  * Registers Used:
00001086                           126  *   D0 = task values
00001086                           127  *   D1 = stores of size of ascii string in A1 from user input
00001086                           128  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
00001086                           129  *   A1 = stores an ascii string from user input
00001086                           130  *-----------------------------------------------------------
00001086                           131  *-------------------------Get Input-------------------------
00001086                           132  GET_INPUT:
00001086  B87C 0000                133              CMP      #0, D4
0000108A  6700 000C                134              BEQ      GET_START_ADDRESS
0000108E                           135                 
0000108E  21C6 106A                136              MOVE.L   D6, startAddr
00001092  21C7 106E                137              MOVE.L   D7, endAddr
00001096  4E75                     138              RTS 
00001098                           139  *-----------------------------------------------------------
00001098                           140  
00001098                           141  *----------------------Get Starting Address-----------------
00001098                           142  GET_START_ADDRESS:
00001098  4280                     143              CLR.L   D0
0000109A  43F8 1000                144              LEA.L   startMsg, A1      
0000109E  103C 000E                145              MOVE.B  #14, D0     
000010A2  4E4F                     146              TRAP    #15
000010A4                           147  
000010A4  43F8 1066                148              LEA.L   userAddr, A1
000010A8  103C 0002                149              MOVE.B  #2, D0
000010AC  4E4F                     150              TRAP    #15
000010AE                           151              ;MOVE.B  D1, startSize
000010AE  6000 001C                152              BRA     VALIDATE_INPUT
000010B2                           153  *-----------------------------------------------------------
000010B2                           154  
000010B2                           155  *----------------------Get Ending Address-------------------
000010B2                           156  GET_END_ADDRESS:
000010B2  4280                     157              CLR.L   D0
000010B4  43F8 1023                158              LEA.L   endMsg, A1      
000010B8  103C 000E                159              MOVE.B  #14, D0     
000010BC  4E4F                     160              TRAP    #15
000010BE                           161  
000010BE  43F8 1066                162              LEA.L   userAddr, A1
000010C2  103C 0002                163              MOVE.B  #2, D0
000010C6  4E4F                     164              TRAP    #15
000010C8                           165              ;MOVE.B  D1, endSize
000010C8  6000 0012                166              BRA     CHECK_LENGTH
000010CC                           167  *-----------------------------------------------------------
000010CC                           168  
000010CC                           169  
000010CC                           170  
000010CC                           171  
000010CC                           172  
000010CC                           173  
000010CC                           174  
000010CC                           175  
000010CC                           176  
000010CC                           177  
000010CC                           178  *-----------------------------------------------------------
000010CC                           179  * Description:  Validate User Input
000010CC                           180  * Constraints:  
000010CC                           181  *   User input must be:
000010CC                           182  *   Length 4 or Length 8
000010CC                           183  *   ASCII character 0-9 or A-F
000010CC                           184  *   Starting and ending address with value < $00FFFFFF 
000010CC                           185  *   Starting address is before ending address
000010CC                           186  *
000010CC                           187  * Registers Used:
000010CC                           188  *   D0 = task values
000010CC                           189  *   D1 = stores of size of ascii string in A1 from user input
000010CC                           190  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000010CC                           191  *   A1 = stores an ascii string from user input
000010CC                           192  *-----------------------------------------------------------
000010CC                           193  
000010CC                           194  *----------------------VALIDATE INPUT---------------------------      
000010CC                           195  
000010CC                           196  VALIDATE_INPUT:        
000010CC  B83C 0000                197              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
000010D0  6700 000A                198              BEQ        CHECK_LENGTH         ; if equal, parse START address 
000010D4  B83C 0001                199              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
000010D8  67D8                     200              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
000010DA  60AA                     201              BRA        GET_INPUT            ; done parsing, D4 = 2
000010DC                           202  
000010DC                           203  CHECK_LENGTH:
000010DC  B23C 0004                204              CMP.B      #4, D1               ; for task 2, length of string is in D1                
000010E0  6700 002C                205              BEQ        CONVERT_TO_HEX 
000010E4  B23C 0008                206              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
000010E8  6700 0024                207              BEQ        CONVERT_TO_HEX
000010EC  6000 0002                208              BRA        INVALID_INPUT
000010F0                           209  
000010F0                           210  INVALID_INPUT:  
000010F0  4283                     211              CLR.L      D3
000010F2                           212m             PRINT_MSG  badInput
000010FE  B83C 0000                213              CMP.B      #0, D4 
00001102  6794                     214              BEQ        GET_START_ADDRESS  
00001104  B83C 0001                215              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001108  67A8                     216              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
0000110A  6000 FF72                217              BRA        MAIN
0000110E                           218  *-----------------------------------------------------------
0000110E                           219  
0000110E                           220  *----------------CONVERT FROM ASCII TO HEX------------------
0000110E                           221  CONVERT_TO_HEX:
0000110E  0C11 0030                222              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001112  6DDC                     223              BLT        INVALID_INPUT        
00001114                           224  
00001114  0C11 003A                225              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001118  6D00 0012                226              BLT        NUM_TO_HEX      
0000111C                           227  
0000111C  0C11 0041                228              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001120  6DCE                     229              BLT        INVALID_INPUT             
00001122                           230  
00001122  0C11 0047                231              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001126  6D00 000C                232              BLT        LETTER_TO_HEX
0000112A                           233  
0000112A  60C4                     234              BRA        INVALID_INPUT    
0000112C                           235  
0000112C                           236  NUM_TO_HEX:      
0000112C  0411 0030                237              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001130  6000 000A                238              BRA        STORE_CHAR   
00001134                           239  
00001134                           240  LETTER_TO_HEX:     
00001134  0411 0037                241              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001138  6000 0002                242              BRA        STORE_CHAR
0000113C                           243  
0000113C                           244  STORE_CHAR:       
0000113C  D619                     245              ADD.B     (A1)+, D3            ; keep hex stored in D3           
0000113E  6000 0002                246              BRA        ITERATE                 
00001142                           247  
00001142                           248  ITERATE:
00001142  5301                     249              SUB.B      #$1, D1
00001144  B23C 0000                250              CMP.B      #0, D1
00001148  6700 0006                251              BEQ        STORE_INPUT
0000114C                           252  
0000114C  E98B                     253              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000114E  60BE                     254              BRA        CONVERT_TO_HEX
00001150                           255  
00001150                           256  STORE_INPUT:
00001150  B83C 0000                257              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
00001154  6700 000A                258              BEQ        STORE_START          ; if equal, parse START address 
00001158                           259              
00001158  B83C 0001                260              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
0000115C  6700 0022                261              BEQ        STORE_END         
00001160                           262  
00001160                           263  STORE_START:
00001160  2C03                     264              MOVE.L     D3, D6
00001162  5204                     265              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001164                           266              ;CLR        D3
00001164                           267              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001164                           268  
00001164                           269              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001164  4281                     270              CLR.L       D1
00001166  2203                     271              MOVE.L      D3, D1   
00001168  103C 0003                272              MOVE.B      #3, D0     
0000116C  4E4F                     273              TRAP        #15
0000116E                           274m             PRINT_MSG   newline
0000117A                           275              
0000117A  4243                     276              CLR         D3
0000117C  6000 FF4E                277              BRA         VALIDATE_INPUT
00001180                           278  
00001180                           279  STORE_END:
00001180  2E03                     280              MOVE.L     D3, D7
00001182  5204                     281              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001184                           282              ;CLR        D3
00001184                           283              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001184                           284  
00001184                           285              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001184  4281                     286              CLR.L       D1
00001186  2203                     287              MOVE.L      D3, D1   
00001188  103C 0003                288              MOVE.B      #3, D0     
0000118C  4E4F                     289              TRAP        #15
0000118E                           290m             PRINT_MSG   newline
0000119A                           291  
0000119A  4243                     292              CLR         D3
0000119C  6000 FF2E                293              BRA         VALIDATE_INPUT
000011A0                           294  *-----------------------------------------------------------
000011A0                           295  
000011A0                           296  
000011A0                           297  
000011A0                           298  
000011A0                           299  
000011A0                           300  
000011A0                           301  
000011A0                           302  
000011A0                           303  
000011A0                           304  
000011A0                           305  
000011A0                           306  *--------------------------PRINT----------------------------
000011A0                           307  * Description:
000011A0                           308  * Prints hex addresses according to where we are in the .S file
000011A0                           309  * and source/destination effective addresses
000011A0                           310  *
000011A0                           311  * No Parameters
000011A0                           312  *
000011A0                           313  * Registers:
000011A0                           314  *   D0 = used for tasks and trap #15
000011A0                           315  *   D1 = size of comparison
000011A0                           316  *   D2 = destination for comparisons, holds an address
000011A0                           317  *   D3 = iterator
000011A0                           318  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000011A0                           319  *   A2 = current address (given by user)
000011A0                           320  *-----------------------------------------------------------
000011A0                           321  
000011A0                           322  *----------------------PRINT_ADDRESS------------------------
000011A0                           323  PRINT_ADDRESS:
000011A0                           324              * reset A1 to beginning of string
000011A0                           325m             CLR_D_REGS
000011B0                           326m             CLR_A_REG D0, A1
000011B4                           327              
000011B4                           328              * move current address to D2
000011B4  240A                     329              MOVE.L    A2, D2
000011B6                           330  
000011B6                           331              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
000011B6  223C 00008000            332              MOVE.L    #$8000, D1
000011BC  B481                     333              CMP.L     D1, D2
000011BE  6D00 000E                334              BLT       PRINT_WORD
000011C2                           335              
000011C2                           336              * if absolute long, print long. Range $8000 - $FFFF7FFF
000011C2  223C FFFF8000            337              MOVE.L    #$FFFF8000, D1
000011C8  B481                     338              CMP.L     D1, D2
000011CA  6C00 0022                339              BGE       PRINT_LONG                 
000011CE                           340  
000011CE                           341  PRINT_WORD:
000011CE                           342m             CLR_D_REGS
000011DE  123C 0001                343              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000011E2  3E0A                     344              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000011E4  4EB9 0000166C            345              JSR       HEX_TO_ASCII
000011EA  6000 0022                346              BRA       FINISH_PRINT
000011EE                           347  
000011EE                           348  PRINT_LONG:
000011EE                           349m             CLR_D_REGS
000011FE  123C 0003                350              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
00001202  2E0A                     351              MOVE.L    A2, D7
00001204  4EB9 0000166C            352              JSR       HEX_TO_ASCII
0000120A  6000 0002                353              BRA       FINISH_PRINT
0000120E                           354  
0000120E                           355  FINISH_PRINT:
0000120E                           356              * print out string
0000120E  12BC 0000                357              MOVE.B    #00,(A1)
00001212                           358m             CLR_D_REGS
00001222                           359m             CLR_A_REG D0, A1
00001226  103C 000E                360              MOVE.B    #14, D0
0000122A  4E4F                     361              TRAP      #15
0000122C  4E75                     362              RTS
0000122E                           363  *-----------------------------------------------------------
0000122E                           364  
0000122E                           365  *-------------------PRINT_INSTRUCTION-----------------------
0000122E                           366  PRINT_INSTRUCTION:    
0000122E                           367              * null terminator
0000122E  12BC 0000                368              MOVE.B    #00,(A1)              
00001232                           369  
00001232                           370              * reset A1 to beginning of string
00001232  4280                     371              CLR.L     D0
00001234                           372m             CLR_A_REG D0, A1
00001238                           373  
00001238                           374              * print out string
00001238  103C 000E                375              MOVE.B    #14, D0
0000123C  4E4F                     376              TRAP      #15
0000123E                           377  
0000123E                           378m             PRINT_MSG newline
0000124A  4E75                     379              RTS
0000124C                           380  *-----------------------------------------------------------
0000124C                           381  
0000124C                           382  
0000124C                           383  
0000124C                           384  
0000124C                           385  
0000124C                           386  
0000124C                           387  
0000124C                           388  
0000124C                           389  
0000124C                           390  
0000124C                           391  
0000124C                           392  *---------------------LOAD ADDRESSES------------------------
0000124C                           393  * Description:
0000124C                           394  * Stores INITIAL values into appropriate address registers 
0000124C                           395  * which is necessary to complete before starting identify opcodes loop
0000124C                           396  * Also pushes reigsters onto the stack
0000124C                           397  *
0000124C                           398  * No Parameters
0000124C                           399  *
0000124C                           400  * Registers:
0000124C                           401  *   A2 = current address (given by user)
0000124C                           402  *   A3 = ending address (given by user)
0000124C                           403  *-----------------------------------------------------------
0000124C                           404  LOAD_ADDRESSES: 
0000124C                           405              * reset A1 to beginning of string
0000124C  4280                     406              CLR.L     D0
0000124E                           407m             CLR_A_REG D0, A1
00001252                           408  
00001252                           409              * load start and end registers and print starting address
00001252  2478 106A                410              MOVEA.L startAddr, A2
00001256  2678 106E                411              MOVEA.L endAddr, A3
0000125A  6100 FF44                412              BSR     PRINT_ADDRESS
0000125E  4EB9 000016D8            413              JSR     INSERT_SPACE
00001264                           414  
00001264  6100 0042                415              BSR     GRAB_NEXT_WORD
00001268  6100 0044                416              BSR     GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
0000126C                           417  
0000126C                           418              * Push current registers onto the stack (so we can have fresh registers)
0000126C  48E7 FF00                419              MOVEM.L D0-D7,-(SP)              ; move the old registers onto the stack
00001270  6000 004E                420              BRA     FIND_OPCODE
00001274                           421  *-----------------------------------------------------------
00001274                           422  
00001274                           423  *-----------------------------------------------------------
00001274                           424  * Description:  IDENTIFY OPCODES LOOP
00001274                           425  * Registers:
00001274                           426  *   D0 = used for tasks and trap #15
00001274                           427  *   D1 = size of shifting bits
00001274                           428  *   D2 = destination for shifts
00001274                           429  *   D3 = size of opcode
00001274                           430  *   D4 = used to hold bits returned from SHIFT macro
00001274                           431  *   D7 = holds address (word in length)
00001274                           432  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001274                           433  *   A2 = current address (given by user)
00001274                           434  *   A3 = ending address (given by user)
00001274                           435  *-----------------------------------------------------------
00001274                           436  *-------------------IDENTIFY OPCODES------------------------
00001274                           437  * evaluates an opcode based on first four bits (aka opTag)
00001274                           438  * for now only works with one instruction
00001274                           439  *-----------------------------------------------------------
00001274                           440  IDENTIFY_OPCODE:
00001274                           441  
00001274                           442              * print opcode
00001274  61B8                     443              BSR     PRINT_INSTRUCTION
00001276                           444  
00001276                           445              * check if starting address >= ending address
00001276  B5CB                     446              CMPA.L  A3, A2
00001278  6C00 049E                447              BGE     DONE
0000127C                           448              
0000127C                           449              * print next address
0000127C  6100 FF22                450              BSR     PRINT_ADDRESS
00001280  4EB9 000016D8            451              JSR     INSERT_SPACE
00001286                           452              
00001286                           453              ;BSR     RESTORE_REGS           need to fix
00001286                           454  
00001286                           455m             CLR_D_REGS
00001296  6100 0010                456              BSR     GRAB_NEXT_WORD          * grab opcode
0000129A  6100 0012                457              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
0000129E                           458             
0000129E  6000 0020                459              BRA     FIND_OPCODE
000012A2                           460  *------------------------------------------------------------
000012A2                           461  
000012A2                           462  *----------------------RESTORE_REGS--------------------------
000012A2                           463  * Description:
000012A2                           464  * Move the old registers onto the stack
000012A2                           465  *------------------------------------------------------------
000012A2                           466  RESTORE_REGS:
000012A2  4CDF 00FF                467              MOVEM.L (SP)+, D0-D7            
000012A6  4E75                     468              RTS
000012A8                           469  *-----------------------------------------------------------
000012A8                           470  
000012A8                           471  *---------Useful Subroutines For Identifying Opcodes--------
000012A8                           472  GRAB_NEXT_WORD:
000012A8                           473              * load current word of bits into D7
000012A8  31DA 107A                474              MOVE.W (A2)+, opcode
000012AC  4E75                     475              RTS
000012AE                           476  
000012AE                           477  GRAB_FIRST_FOUR_BITS:
000012AE                           478              * find first four bits of opcode
000012AE  3438 107A                479              MOVE.W  opcode, D2
000012B2  123C 000C                480              MOVE.B  #12, D1
000012B6  E2AA                     481              LSR.L   D1, D2
000012B8  1002                     482              MOVE.B  D2, D0
000012BA  11C0 107C                483              MOVE.B  D0, opTag
000012BE  4E75                     484              RTS
000012C0                           485  *-----------------------------------------------------------
000012C0                           486  
000012C0                           487  
000012C0                           488  
000012C0                           489  
000012C0                           490  
000012C0                           491  
000012C0                           492  
000012C0                           493  
000012C0                           494  
000012C0                           495  *----------------------FIND OPCODE--------------------------
000012C0                           496  * Description:
000012C0                           497  * Finds a matching opTag (first four bits of opcode) and 
000012C0                           498  * jumps to that opcode's encoding subroutine
000012C0                           499  *
000012C0                           500  * For example:
000012C0                           501  *               ADD's first four bits = 1101, so I put
000012C0                           502  *               CMP.B #%1101, D0
000012C0                           503  *
000012C0                           504  * No Parameters
000012C0                           505  *
000012C0                           506  * No Registers Used
000012C0                           507  *-----------------------------------------------------------        
000012C0                           508  FIND_OPCODE:
000012C0  0C38 0000 107C           509              CMP.B   #%0000, opTag 
000012C6  6700 0034                510              BEQ     OPC_0000
000012CA                           511  
000012CA  0C38 0004 107C           512              CMP.B   #%0100, opTag 
000012D0  6700 009C                513              BEQ     OPC_0100
000012D4                           514  
000012D4  0C38 0009 107C           515              CMP.B   #%1001, opTag
000012DA  6700 012C                516              BEQ     OPC_1001
000012DE                           517  
000012DE  0C38 000C 107C           518              CMP.B   #%1100, opTag
000012E4  6700 0136                519              BEQ     OPC_1100
000012E8                           520  
000012E8  0C38 000D 107C           521              CMP.B   #%1101, opTag
000012EE  6700 0154                522              BEQ     OPC_1101
000012F2                           523  
000012F2                           524              * error, bad opcode
000012F2  6000 0002                525              BRA      BAD_OPCODE
000012F6                           526  
000012F6                           527  *-----------------------------------------------------------
000012F6                           528  
000012F6                           529  *-----------------------BAD OPCODE--------------------------
000012F6                           530  BAD_OPCODE:
000012F6  4EF9 00001718            531              JMP      DONE
000012FC                           532  *-----------------------------------------------------------
000012FC                           533  
000012FC                           534  *------------------------OPC_0000---------------------------
000012FC                           535  * First four bits = 0000
000012FC                           536  * (ADDI)
000012FC                           537  *-----------------------------------------------------------
000012FC                           538  OPC_0000:
000012FC  12FC 0041                539              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001300  12FC 0044                540              MOVE.B  #'D',(A1)+
00001304  12FC 0044                541              MOVE.B  #'D',(A1)+
00001308  12FC 0049                542              MOVE.B  #'I',(A1)+
0000130C  12FC 002E                543              MOVE.B  #'.',(A1)+
00001310                           544  
00001310                           545m             GET_BITS #7, #6             * get size bits (gets returned to D4)
00001310                           546m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001316                           547m             * GET HIGH BIT OFFSET
0000131C                           548m             * SHIFT OUT HIGH BITS
00001322                           549m             *GET LOW BIT OFFSET
00001322                           550m             *16 - NUMBER OF BITS WE WANT
00001328                           551m             * SHIFT OUT LOW BITS
0000132A  3604                     552              MOVE    D4, D3              * load parameter for SIZE_TO_BUFFER
0000132C  4EB9 000016DE            553              JSR     SIZE_TO_BUFFER      * put operation size in buffer
00001332  6100 0016                554              BSR     CHECK_IMMEDIATE
00001336  12FC 002C                555              MOVE.B  #',',(A1)+
0000133A  4EB9 000016D8            556              JSR     INSERT_SPACE
00001340  4EB9 00001502            557              JSR     GET_EA_MODE
00001346  6000 FF2C                558              BRA     IDENTIFY_OPCODE
0000134A                           559  
0000134A                           560  CHECK_IMMEDIATE:
0000134A  12FC 0023                561              MOVE.B  #'#', (A1)+
0000134E                           562  
0000134E  B67C 0001                563              CMP     #1, D3
00001352  6F00 000A                564              BLE     IMMEDIATE_WORD
00001356                           565  
00001356  B67C 0002                566              CMP     #2, D3
0000135A  6000 000A                567              BRA     IMMEDIATE_LONG
0000135E                           568  
0000135E                           569  IMMEDIATE_WORD:
0000135E  4EB9 00001636            570              JSR     EA_WORD
00001364  4E75                     571              RTS
00001366                           572  
00001366                           573  IMMEDIATE_LONG:
00001366  4EB9 0000164A            574              JSR     EA_LONG      
0000136C  4E75                     575              RTS
0000136E                           576  
0000136E                           577  
0000136E                           578  *------------------------OPC_0100---------------------------
0000136E                           579  * First four bits = 0100
0000136E                           580  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
0000136E                           581  *-----------------------------------------------------------
0000136E                           582  OPC_0100:
0000136E                           583  
0000136E                           584              ;Check if the opcode is NOP
0000136E  3438 107A                585              MOVE.W  opcode, D2          ;Copy opcode to D2
00001372  B47C 4E71                586              CMP.W   #$4E71, D2          ;Check if D2 is equal to NOP (0x4E71 in hex)
00001376  6700 0038                587              BEQ     OPC_NOP             ;If equal branch to label to handle the opcode NOP
0000137A                           588              
0000137A                           589              ;Check if the opcode is NOT
0000137A  E082                     590              ASR.L   #8, D2 ;Shift bits to compare
0000137C  B43C 0046                591              CMP.B   #%01000110, D2
00001380  6700 003E                592              BEQ     OPC_NOT
00001384  4282                     593              CLR.L   D2
00001386                           594              
00001386                           595              ;Check if the opcode is LEA
00001386  3838 107A                596              MOVE.W  opcode, D4 ;Put opcode in D4 to use the macro get bits
0000138A                           597m             GET_BITS #8, #6 
0000138A                           598m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001390                           599m             * GET HIGH BIT OFFSET
00001396                           600m             * SHIFT OUT HIGH BITS
0000139C                           601m             *GET LOW BIT OFFSET
0000139C                           602m             *16 - NUMBER OF BITS WE WANT
000013A2                           603m             * SHIFT OUT LOW BITS
000013A4  B83C 0007                604              CMP.B #%00000111, D4 ;if bits 6-8 are equal to 111, then the opocde is LEA
000013A8  6700 0052                605              BEQ     OPC_LEA
000013AC  4282                     606              CLR.L   D2 ;If opcode doesn't match clear appropriate registers 
000013AE  4284                     607              CLR.L   D4
000013B0                           608  
000013B0                           609  OPC_NOP:
000013B0                           610              * Put NOP into A1 buffer for printing
000013B0  12FC 004E                611              MOVE.B  #'N',(A1)+      
000013B4  12FC 004F                612              MOVE.B  #'O',(A1)+ 
000013B8  12FC 0050                613              MOVE.B  #'P',(A1)+ 
000013BC                           614              
000013BC  6000 FEB6                615              BRA     IDENTIFY_OPCODE
000013C0                           616  
000013C0                           617  
000013C0                           618  OPC_NOT:
000013C0                           619              * Put NOT into A1 buffer for printing
000013C0  12FC 004E                620              MOVE.B  #'N',(A1)+ 
000013C4  12FC 004F                621              MOVE.B  #'O',(A1)+
000013C8  12FC 0054                622              MOVE.B  #'T',(A1)+
000013CC  12FC 002E                623              MOVE.B  #'.',(A1)+
000013D0                           624              
000013D0                           625              * Calculate Size (.b,.w.l)
000013D0  4EB9 000013E6            626              JSR     GET_NOT_SIZE
000013D6  4EB9 000016DE            627              JSR     SIZE_TO_BUFFER 
000013DC  4EB9 00001502            628              JSR     GET_EA_MODE
000013E2  6000 FE90                629              BRA     IDENTIFY_OPCODE
000013E6                           630              
000013E6                           631  GET_NOT_SIZE:
000013E6  4282                     632              CLR.L   D2
000013E8  3438 107A                633              MOVE.W  opcode, D2
000013EC                           634  
000013EC                           635              * shift left to get rid of opTag
000013EC  123C 0008                636              MOVE.B  #8, D1
000013F0  E36A                     637              LSL.W   D1, D2
000013F2                           638  
000013F2                           639              * shift right to get rid of opmode, mode, and register bits
000013F2  123C 000E                640              MOVE.B  #14, D1
000013F6  E26A                     641              LSR.W   D1, D2
000013F8                           642  
000013F8                           643              * store in appropriate register
000013F8  1602                     644              MOVE.B  D2, D3
000013FA  4E75                     645              RTS
000013FC                           646  
000013FC                           647  OPC_LEA:
000013FC  12FC 004C                648              MOVE.B  #'L',(A1)+      
00001400  12FC 0045                649              MOVE.B  #'E',(A1)+ 
00001404  12FC 0041                650              MOVE.B  #'A',(A1)+     
00001408                           651               
00001408                           652  
00001408                           653              
00001408                           654  *-----------------------------------------------------------
00001408                           655  
00001408                           656  *-----------------------OPC_1001----------------------------
00001408                           657  * First four bits = 1001
00001408                           658  * (SUB)
00001408                           659  *-----------------------------------------------------------
00001408                           660  OPC_1001:
00001408                           661              * fill in A1 register
00001408  12FC 0053                662              MOVE.B  #'S',(A1)+          * Put ADD into Buff
0000140C  12FC 0055                663              MOVE.B  #'U',(A1)+
00001410  12FC 0042                664              MOVE.B  #'B',(A1)+
00001414  12FC 002E                665              MOVE.B  #'.',(A1)+
00001418  6000 003E                666              BRA     PROCESS_ROEA
0000141C                           667  *-----------------------------------------------------------
0000141C                           668  
0000141C                           669  *-----------------------OPC_1100----------------------------
0000141C                           670  * First four bits = 1100
0000141C                           671  * (AND, MULS)
0000141C                           672  *-----------------------------------------------------------
0000141C                           673  OPC_1100:   ; AND opcode subroutine
0000141C                           674              
0000141C                           675              ; check to see if bits 8-6 are 111
0000141C                           676              ; if they are, then branch to PARSE_MULS
0000141C                           677              ; else, keep going to parse AND
0000141C                           678  
0000141C                           679  OPC_AND:
0000141C                           680              ; fill A1 with the opcode name
0000141C  12FC 0041                681              MOVE.B  #'A',(A1)+
00001420  12FC 004E                682              MOVE.B  #'N',(A1)+
00001424  12FC 0044                683              MOVE.B  #'D',(A1)+
00001428  12FC 002E                684              MOVE.B  #'.',(A1)+
0000142C  6000 002A                685              BRA     PROCESS_ROEA
00001430                           686  
00001430                           687  OPC_MULS:
00001430                           688              ; load the command name into the output
00001430  12FC 004D                689              MOVE.B  #'M',(A1)+
00001434  12FC 0055                690              MOVE.B  #'U',(A1)+
00001438  12FC 004C                691              MOVE.B  #'L',(A1)+
0000143C  12FC 0053                692              MOVE.B  #'S',(A1)+
00001440  12FC 002E                693              MOVE.B  #'.',(A1)+
00001444                           694  
00001444                           695  
00001444                           696  *---------------------------opc_1101------------------------
00001444                           697  * First four bits = 1101
00001444                           698  * (ADD)
00001444                           699  *-----------------------------------------------------------
00001444                           700  OPC_1101:
00001444                           701              * fill in A1 register
00001444  12FC 0041                702              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001448  12FC 0044                703              MOVE.B  #'D',(A1)+
0000144C  12FC 0044                704              MOVE.B  #'D',(A1)+
00001450  12FC 002E                705              MOVE.B  #'.',(A1)+
00001454  6000 0002                706              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
00001458                           707  
00001458                           708  *-----------------------------------------------------------
00001458                           709  
00001458                           710  
00001458                           711  
00001458                           712  
00001458                           713  
00001458                           714  
00001458                           715  
00001458                           716  
00001458                           717  
00001458                           718  
00001458                           719  *--------------Process Register->Opmode->EA-----------------
00001458                           720  * Description:
00001458                           721  * Parses bits for opcodes that share bit placements:
00001458                           722  * ROEA stands for Register, Opmode, and Effective Address,
00001458                           723  * because the opcodes below share this bit order.
00001458                           724  *
00001458                           725  * Used by: (ADD, SUB, MULS)
00001458                           726  *
00001458                           727  *-----------------------------------------------------------
00001458                           728  PROCESS_ROEA:
00001458  4EB9 000014B6            729              JSR     GET_SIZE
0000145E  4EB9 000016DE            730              JSR     SIZE_TO_BUFFER
00001464  4EB9 000014CC            731              JSR     OPMODE_TYPE         * 0 or 1 value (either <ea> -> Dn or Dn -> <ea>)  
0000146A  B83C 0001                732              CMP.B   #1, D4              * is this Dn + <ea> -> <ea>?
0000146E  6700 000A                733              BEQ     D_TO_EA
00001472  B83C 0000                734              CMP.B   #0, D4              * is this Dn + <ea> -> <ea>?
00001476  6700 001C                735              BEQ     EA_TO_D
0000147A                           736  
0000147A                           737  D_TO_EA:
0000147A  4EB9 000014E2            738              JSR     GET_DATA_REG_NUM
00001480  12FC 002C                739              MOVE.B  #',',(A1)+
00001484  4EB9 000016D8            740              JSR     INSERT_SPACE
0000148A  4EB9 00001502            741              JSR     GET_EA_MODE
00001490  6000 001C                742              BRA     ROEA_DONE
00001494                           743  
00001494                           744  EA_TO_D:
00001494  4EB9 00001502            745              JSR     GET_EA_MODE
0000149A  12FC 002C                746              MOVE.B  #',',(A1)+
0000149E  4EB9 000016D8            747              JSR     INSERT_SPACE
000014A4  4EB9 000014E2            748              JSR     GET_DATA_REG_NUM
000014AA  6000 0002                749              BRA     ROEA_DONE
000014AE                           750  
000014AE                           751  ROEA_DONE:
000014AE  12FC 0020                752              MOVE.B  #' ',(A1)+
000014B2  6000 FDC0                753              BRA     IDENTIFY_OPCODE
000014B6                           754              
000014B6                           755  
000014B6                           756  GET_SIZE:
000014B6                           757              * copy current instruction to shift
000014B6  4282                     758              CLR.L   D2
000014B8  3438 107A                759              MOVE.W  opcode ,D2          
000014BC                           760              
000014BC                           761              * shift left to get rid of opTag
000014BC  123C 0008                762              MOVE.B  #8, D1
000014C0  E36A                     763              LSL.W   D1, D2
000014C2                           764  
000014C2                           765              * shift right to get rid of opmode, mode, and register bits
000014C2  123C 000E                766              MOVE.B  #14, D1
000014C6  E26A                     767              LSR.W   D1, D2
000014C8                           768  
000014C8                           769              * store in appropriate register
000014C8  1602                     770              MOVE.B  D2, D3
000014CA                           771              
000014CA  4E75                     772              RTS
000014CC                           773  
000014CC                           774  OPMODE_TYPE:
000014CC                           775              * copy current instruction to shift
000014CC  4282                     776              CLR.L   D2
000014CE  3438 107A                777              MOVE.W  opcode ,D2          
000014D2                           778  
000014D2                           779              * shift left to identify
000014D2  123C 0007                780              MOVE.B  #7, D1
000014D6  E36A                     781              LSL.W   D1, D2
000014D8                           782              
000014D8                           783              * shift left to identify
000014D8  123C 000F                784              MOVE.B  #15, D1
000014DC  E26A                     785              LSR.W   D1, D2
000014DE                           786  
000014DE                           787              * store in appropriate register
000014DE  1802                     788              MOVE.B  D2, D4
000014E0                           789  
000014E0  4E75                     790              RTS
000014E2                           791  
000014E2                           792  GET_DATA_REG_NUM:
000014E2                           793              * D3 should hold the size of the opcode operation
000014E2  4282                     794              CLR.L   D2
000014E4  3438 107A                795              MOVE.W  opcode, D2  
000014E8                           796  
000014E8                           797              * shift left to identify
000014E8  123C 0004                798              MOVE.B  #4, D1
000014EC  E36A                     799              LSL.W   D1, D2
000014EE                           800              
000014EE                           801              * shift right to isolate high register bits
000014EE  123C 000D                802              MOVE.B  #13, D1
000014F2  E26A                     803              LSR.W   D1, D2
000014F4                           804  
000014F4                           805              * store in appropriate register
000014F4  12FC 0044                806              MOVE.B  #'D',(A1)+              * add "D" to buffer
000014F8  0602 0030                807              ADD.B   #$30,D2                   * convert data register # to hex digit
000014FC  12C2                     808              MOVE.B  D2,(A1)+                * register # to buffer             
000014FE  1C02                     809              MOVE.B  D2, D6
00001500                           810  
00001500  4E75                     811              RTS
00001502                           812  *-----------------------------------------------------------
00001502                           813  
00001502                           814  
00001502                           815  
00001502                           816  
00001502                           817  
00001502                           818  
00001502                           819  
00001502                           820  
00001502                           821  *----------------------------GET_EA_MODE------------------------
00001502                           822  * Description:
00001502                           823  * Evaluates the ea mode and register of an opcode 
00001502                           824  * (usually last 6 bits of instruction format),
00001502                           825  * and adds it to A1 to be printed out
00001502                           826  *
00001502                           827  * No Parameters
00001502                           828  *
00001502                           829  * Registers Used:
00001502                           830  *   D1 = amount to shift the opcode
00001502                           831  *   D2 = destination for shifts
00001502                           832  *   D5 = addressing mode
00001502                           833  *-----------------------------------------------------------
00001502                           834  GET_EA_MODE:
00001502                           835m             CLR_D_REGS
00001512                           836              * move size of opcode to be manipulated
00001512  4282                     837              CLR.L   D2
00001514  3438 107A                838              MOVE.W  opcode, D2     
00001518                           839  
00001518                           840              * shift left to identify
00001518  123C 000A                841              MOVE.B  #10, D1
0000151C  E36A                     842              LSL.W   D1, D2
0000151E                           843              
0000151E                           844              * shift right to isolate mode bits for EA 
0000151E  123C 000D                845              MOVE.B  #13, D1
00001522  E26A                     846              LSR.W   D1, D2
00001524                           847  
00001524                           848              * store in appropriate register
00001524  1A02                     849              MOVE.B  D2, D5
00001526                           850              
00001526  6000 0002                851              BRA     FIND_MODE
0000152A                           852  
0000152A                           853  *----------------------------FIND_MODE------------------------
0000152A                           854  FIND_MODE:                            
0000152A  BA3C 0000                855              CMP.B   #%0000, D5        * Direct Data Register
0000152E  6700 003E                856              BEQ     ea_000
00001532                           857  
00001532  BA3C 0001                858              CMP.B   #%0001, D5        * Direct Address Register
00001536  6700 004E                859              BEQ     ea_001
0000153A                           860  
0000153A  BA3C 0002                861              CMP.B   #%0010, D5        * Indirect Address Register
0000153E  6700 005E                862              BEQ     ea_010
00001542                           863  
00001542  BA3C 0003                864              CMP.B   #%0011, D5        * Post Increment
00001546  6700 0076                865              BEQ     ea_011
0000154A                           866  
0000154A  BA3C 0004                867              CMP.B   #%0100, D5        * Pre Decrement
0000154E  6700 0092                868              BEQ     ea_100
00001552                           869  
00001552  BA3C 0005                870              CMP.B   #%0101, D5        * Not necessary, go to bad ea
00001556  6700 00AE                871              BEQ     ea_101
0000155A                           872  
0000155A  BA3C 0006                873              CMP.B   #%0110, D5        * Not necessary, go to bad ea
0000155E  6700 00AA                874              BEQ     ea_110
00001562                           875  
00001562  BA3C 0007                876              CMP.B   #%0111, D5        * Absolute or immediate address
00001566  6700 00A6                877              BEQ     ea_111
0000156A                           878  
0000156A  6000 00FA                879              BRA    INVALID_EA
0000156E                           880  
0000156E                           881  *----------------------------Direct Data Register------------------------
0000156E                           882  ea_000:
0000156E  3438 107A                883              MOVE.W      opcode, D2              * move current working word into temp storage
00001572  12FC 0044                884              MOVE.B      #'D',(A1)+              * add "D" to buffer
00001576                           885              
00001576  123C 000D                886              MOVE.B      #13, D1
0000157A  E36A                     887              LSL.W       D1,D2                   * isolate register bits (last 3)
0000157C  E26A                     888              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
0000157E  0602 0030                889              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001582                           890  
00001582  12C2                     891              MOVE.B      D2,(A1)+                * register # to buffer                  
00001584                           892              
00001584  4E75                     893              RTS                                
00001586                           894  
00001586                           895  *----------------------------Direct Address Register------------------------
00001586                           896  ea_001:
00001586  3438 107A                897              MOVE.W      opcode, D2              * move current working word into temp storage
0000158A  12FC 0041                898              MOVE.B      #'A',(A1)+              * add "A" to buffer
0000158E                           899              
0000158E  123C 000D                900              MOVE.B      #13, D1
00001592  E36A                     901              LSL.W       D1,D2                   * isolate register bits (last 3)
00001594  E26A                     902              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
00001596  0602 0030                903              ADD.B       #$30,D2                 * convert data register # to ASCII digit
0000159A                           904  
0000159A  12C2                     905              MOVE.B      D2,(A1)+                * register # to buffer               
0000159C                           906                
0000159C  4E75                     907              RTS                            
0000159E                           908  
0000159E                           909  *----------------------------Indirect Address Register------------------------
0000159E                           910  ea_010:
0000159E  3438 107A                911              MOVE.W      opcode, D2              * move current working word into temp storage
000015A2  12FC 0028                912              MOVE.B      #'(',(A1)+              * add "(" to buffer
000015A6  12FC 0041                913              MOVE.B      #'A',(A1)+              * add "A" to buffer
000015AA                           914  
000015AA  123C 000D                915              MOVE.B      #13, D1
000015AE  E36A                     916              LSL.W       D1,D2                   * isolate register bits (last 3)
000015B0  E26A                     917              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
000015B2  0602 0030                918              ADD.B       #$30,D2                 * convert data register # to ASCII digit
000015B6  12C2                     919              MOVE.B      D2,(A1)+                * register # to buffer     
000015B8                           920  
000015B8  12FC 0029                921              MOVE.B      #')',(A1)+              * add ")" to buffer
000015BC                           922               
000015BC  4E75                     923              RTS                            
000015BE                           924  
000015BE                           925  *----------------------------Post Increment------------------------
000015BE                           926  ea_011:
000015BE  3438 107A                927              MOVE.W      opcode, D2              * move current working word into temp storage
000015C2                           928  
000015C2  12FC 0028                929              MOVE.B      #'(',(A1)+              * add "(" to buffer
000015C6  12FC 0041                930              MOVE.B      #'A',(A1)+              * add "A" to buffer
000015CA                           931              
000015CA  123C 000D                932              MOVE.B      #13, D1
000015CE  E36A                     933              LSL.W       D1,D2                   * isolate register bits (last 3)
000015D0  E26A                     934              LSR.W       D1,D2                  
000015D2  0602 0030                935              ADD.B       #$30,D2                 * convert data register # to ASCII digit
000015D6  12C2                     936              MOVE.B      D2,(A1)+                * register # to buffer     
000015D8                           937  
000015D8  12FC 0029                938              MOVE.B      #')',(A1)+              * add ")" to buffer
000015DC  12FC 002B                939              MOVE.B      #'+',(A1)+              * add "+" to buffer
000015E0                           940                   
000015E0  4E75                     941              RTS                              
000015E2                           942  
000015E2                           943  *----------------------------Pre Decrement------------------------
000015E2                           944  ea_100:
000015E2  3438 107A                945              MOVE.W      opcode, D2              * move current working word into temp storage
000015E6                           946  
000015E6  12FC 002D                947              MOVE.B      #'-',(A1)+              * add "-" to buffer
000015EA  12FC 0028                948              MOVE.B      #'(',(A1)+              * add "(" to buffer
000015EE  12FC 0041                949              MOVE.B      #'A',(A1)+              * add "A" to buffer
000015F2                           950              
000015F2  123C 000D                951              MOVE.B      #13, D1
000015F6  E36A                     952              LSL.W       D1, D2                   * isolate register bits (last 3)
000015F8  E26A                     953              LSR.W       D1, D2                   * D2 now holds the mode of the opcode
000015FA  0602 0030                954              ADD.B       #$30, D2                 * convert data register # to ASCII digit
000015FE  12C2                     955              MOVE.B      D2, (A1)+                * register # to buffer     
00001600                           956  
00001600  12FC 0029                957              MOVE.B      #')',(A1)+               * add ")" to buffer
00001604                           958              
00001604  4E75                     959              RTS
00001606                           960  
00001606                           961  *----------------------------Not necessary, go to bad ea------------------------
00001606                           962  ea_101:
00001606  6000 005E                963              BRA         INVALID_EA        
0000160A                           964  
0000160A                           965  
0000160A                           966  *----------------------------Not necessary, go to bad ea------------------------
0000160A                           967  ea_110:
0000160A  6000 005A                968              BRA         INVALID_EA        
0000160E                           969  
0000160E                           970  
0000160E                           971  *----------------------------Absolute or immediate address------------------------
0000160E                           972  ea_111:
0000160E                           973              * D405      0 0003456  23345245
0000160E                           974              * ADD.L     $1234, D0
0000160E                           975  
0000160E                           976              * 8 bit value
0000160E                           977              * 11111111
0000160E                           978  
0000160E                           979              * 11111011 - Direct data register would be Invalid
0000160E                           980              * 00000100
0000160E                           981              * 00000000 -> invalid code
0000160E                           982  
0000160E                           983              * and.b     #$F, Dn        ---->  10000000
0000160E                           984              * cmp.b     #%10000000, Dn  
0000160E                           985  
0000160E                           986              * check against valid bits
0000160E                           987                  * if invalid, branch to invalid opcode subroutine
0000160E                           988                      * if the mode is 111, then go back and print out addresses
0000160E                           989  
0000160E  3438 107A                990              MOVE.W      opcode, D2
00001612  123C 000D                991              MOVE.B      #13, D1
00001616  E36A                     992              LSL.W       D1, D2                   * isolate register bits (last 3)
00001618  E26A                     993              LSR.W       D1, D2                   * isolate register bits (last 3)
0000161A                           994  
0000161A  B43C 0000                995              CMP.B       #%000, D2                * compare to determine if it's a word
0000161E  6700 0016                996              BEQ         EA_WORD                  * put word address in buffer
00001622                           997  
00001622  B43C 0001                998              CMP.B       #%001, D2                * compare to determine if it's a long
00001626  6700 0022                999              BEQ         EA_LONG                  * put long address in buffer
0000162A                          1000              
0000162A  B43C 0004               1001              CMP.B       #%100, D2
0000162E  6700 002E               1002              BEQ         EA_IMMEDIATE             * always print a long if it's immediate data
00001632                          1003  
00001632                          1004              * Invalid EA mode/register
00001632  6000 0032               1005              BRA         INVALID_EA
00001636                          1006  
00001636                          1007  EA_WORD:
00001636  12FC 0024               1008              MOVE.B      #'$', (A1)+
0000163A  4281                    1009              CLR.L       D1
0000163C  123C 0001               1010              MOVE.B      #1, D1
00001640  3E1A                    1011              MOVE.W      (A2)+, D7
00001642  6100 0028               1012              BSR         HEX_TO_ASCII
00001646  6000 001C               1013              BRA         GET_EA_DONE
0000164A                          1014  
0000164A                          1015  EA_LONG:
0000164A  12FC 0024               1016              MOVE.B      #'$', (A1)+
0000164E  4281                    1017              CLR.L       D1
00001650  123C 0003               1018              MOVE.B      #3, D1
00001654  2E1A                    1019              MOVE.L      (A2)+, D7   
00001656  6100 0014               1020              BSR         HEX_TO_ASCII
0000165A  6000 0008               1021              BRA         GET_EA_DONE
0000165E                          1022  
0000165E                          1023  EA_IMMEDIATE:
0000165E  12FC 0023               1024              MOVE.B      #'#', (A1)+
00001662  60E6                    1025              BRA         EA_LONG
00001664                          1026  
00001664                          1027  GET_EA_DONE:
00001664  4E75                    1028              RTS
00001666                          1029  
00001666                          1030  *------------------Invalid Effective Address----------------
00001666                          1031  INVALID_EA:
00001666  4EF9 00001718           1032              JMP      DONE
0000166C                          1033  *-----------------------------------------------------------
0000166C                          1034  
0000166C                          1035  
0000166C                          1036  
0000166C                          1037  
0000166C                          1038  
0000166C                          1039  
0000166C                          1040  
0000166C                          1041  
0000166C                          1042  *----------------------HEX TO ASCII-------------------------
0000166C                          1043  * Description:
0000166C                          1044  * Converts a Hex numbered address (1-9 or A-F) back to an
0000166C                          1045  * ASCII value for printing
0000166C                          1046  *
0000166C                          1047  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
0000166C                          1048  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
0000166C                          1049  *   D7 = holds the original address to parse (either word or long, for example: $7000)
0000166C                          1050  *
0000166C                          1051  * Parameters (if calling NUMBER_OR_LETTER (usually done in opcode sections)):
0000166C                          1052  *   D2 = should hold value (in hex) you want to push to the buffer
0000166C                          1053  *
0000166C                          1054  * Registers Used:
0000166C                          1055  *   D0 = number of bits to remove
0000166C                          1056  *   D2 = holds either top four bits or bottom four bits of each byte in D6
0000166C                          1057  *   D3 = holds temp data
0000166C                          1058  *   D6 = holds part of address (used as temp variable)
0000166C                          1059  *   A1 = used for buffer
0000166C                          1060  *-----------------------------------------------------------
0000166C                          1061  HEX_TO_ASCII:
0000166C  1001                    1062              MOVE.B   D1, D0             * current number of bytes to remove
0000166E  C1FC 0008               1063              MULS.W   #8, D0             * number of bits to remove
00001672                          1064  
00001672  2C07                    1065              MOVE.L   D7, D6             * load original address to parse
00001674  E0AE                    1066              LSR.L    D0, D6             * remove lowest byte(s)
00001676                          1067  
00001676                          1068              * isolate first four bits
00001676  1406                    1069              MOVE.B   D6, D2
00001678  E80A                    1070              LSR.B    #4, D2 
0000167A  6100 0018               1071              BSR      NUMBER_OR_LETTER
0000167E                          1072  
0000167E                          1073              * isolate second set of four bits
0000167E  1406                    1074              MOVE.B   D6, D2
00001680  E90A                    1075              LSL.B    #4, D2 
00001682  E80A                    1076              LSR.B    #4, D2 
00001684  6100 000E               1077              BSR      NUMBER_OR_LETTER
00001688                          1078  
00001688  5301                    1079              SUB.B    #1, D1             * iterate
0000168A  B23C 0000               1080              CMP.B    #0, D1             * done if equal
0000168E  6D00 0036               1081              BLT      ATH_DONE
00001692                          1082  
00001692  60D8                    1083              BRA      HEX_TO_ASCII
00001694                          1084  
00001694                          1085  NUMBER_OR_LETTER:
00001694  1602                    1086              MOVE.B   D2, D3
00001696  0603 0030               1087              ADD.B    #$30, D3           
0000169A  B63C 0039               1088              CMP.B    #$39, D3           * is byte in D2 a number?
0000169E  6F00 0012               1089              BLE      NUMBER_TO_ASCII
000016A2                          1090              
000016A2  1602                    1091              MOVE.B   D2, D3
000016A4  0603 0037               1092              ADD.B    #$37, D3           
000016A8  B63C 0039               1093              CMP.B    #$39, D3           * is byte in D2 a letter?
000016AC  6C00 000C               1094              BGE      LETTER_TO_ASCII
000016B0                          1095  
000016B0  60B4                    1096              BRA      INVALID_EA
000016B2                          1097  
000016B2                          1098  NUMBER_TO_ASCII:
000016B2  0602 0030               1099              ADD.B    #$30, D2           * Get the hex range from '0-9'
000016B6  6000 000A               1100              BRA      ADD_TO_BUFFER
000016BA                          1101  
000016BA                          1102  LETTER_TO_ASCII:
000016BA  0602 0037               1103              ADD.B    #$37, D2           * Get the hex range from 'A-F'
000016BE  6000 0002               1104              BRA      ADD_TO_BUFFER
000016C2                          1105  
000016C2                          1106  ADD_TO_BUFFER:
000016C2  12C3                    1107              MOVE.B   D3, (A1)+          * add part of address to buffer    
000016C4  4E75                    1108              RTS
000016C6                          1109  
000016C6                          1110  ATH_DONE:
000016C6                          1111m             CLR_D_REGS
000016D6  4E75                    1112              RTS
000016D8                          1113  *-----------------------------------------------------------
000016D8                          1114  
000016D8                          1115  INSERT_SPACE:
000016D8  12FC 0020               1116              MOVE.B  #' ',(A1)+          * add blank space to buffer
000016DC  4E75                    1117              RTS
000016DE                          1118  
000016DE                          1119  
000016DE                          1120  
000016DE                          1121  
000016DE                          1122  
000016DE                          1123  
000016DE                          1124  
000016DE                          1125  
000016DE                          1126  
000016DE                          1127  *---------------------SIZE TO BUFFER------------------------
000016DE                          1128  * Description:
000016DE                          1129  * Evaluates the size of an opcode and adds it to A1 to be printed out
000016DE                          1130  *
000016DE                          1131  * Parameters:
000016DE                          1132  *   D3 = size of opcode
000016DE                          1133  *
000016DE                          1134  * Registers Used:
000016DE                          1135  *   A1: adding words/numbers to buffer
000016DE                          1136  *-----------------------------------------------------------
000016DE                          1137  SIZE_TO_BUFFER: 
000016DE  B63C 0000               1138              CMP.B   #%0000,D3            
000016E2  6700 0016               1139              BEQ     BYTE_TO_BUFFER              
000016E6                          1140  
000016E6  B63C 0001               1141              CMP.B   #%0001,D3             * is this a word?
000016EA  6700 0016               1142              BEQ     WORD_TO_BUFFER
000016EE                          1143  
000016EE  B63C 0002               1144              CMP.B   #%0010,D3             * is this a long?
000016F2  6700 0016               1145              BEQ     LONG_TO_BUFFER             
000016F6                          1146        
000016F6  4EF8 12F6               1147              JMP     BAD_OPCODE  
000016FA                          1148              
000016FA                          1149  BYTE_TO_BUFFER:
000016FA  12FC 0042               1150              MOVE.B  #'B', (A1)+           * add B to buffer
000016FE  6000 0012               1151              BRA     STB_END             
00001702                          1152              
00001702                          1153  WORD_TO_BUFFER:
00001702  12FC 0057               1154              MOVE.B  #'W', (A1)+          * add W to buffer
00001706  6000 000A               1155              BRA     STB_END             
0000170A                          1156  
0000170A                          1157  LONG_TO_BUFFER:
0000170A  12FC 004C               1158              MOVE.B  #'L',(A1)+          * add L to buffer
0000170E  6000 0002               1159              BRA     STB_END             
00001712                          1160  
00001712                          1161  STB_END:
00001712  12FC 0020               1162              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001716  4E75                    1163              RTS                         
00001718                          1164  
00001718                          1165  
00001718                          1166  
00001718                          1167  
00001718                          1168  
00001718                          1169  
00001718                          1170  
00001718                          1171  *-------------------------DONE-------------------------------
00001718                          1172  DONE:
00001718                          1173m             CLR_A_REG D0, A1
0000171C                          1174  
0000171C                          1175              * add 'SIMHAULT' to buffer
0000171C  12FC 0053               1176              MOVE.B  #'S',(A1)+      
00001720  12FC 0049               1177              MOVE.B  #'I',(A1)+         
00001724  12FC 004D               1178              MOVE.B  #'M',(A1)+         
00001728  12FC 0048               1179              MOVE.B  #'H',(A1)+        
0000172C  12FC 0041               1180              MOVE.B  #'A',(A1)+         
00001730  12FC 0055               1181              MOVE.B  #'U',(A1)+         
00001734  12FC 004C               1182              MOVE.B  #'L',(A1)+          
00001738  12FC 0054               1183              MOVE.B  #'T',(A1)+         
0000173C  12FC 0000               1184              MOVE.B  #00,(A1)+         
00001740                          1185  
00001740                          1186m             CLR_A_REG D0, A1
00001744                          1187              
00001744                          1188              * print out string
00001744  103C 000E               1189              MOVE.B    #14, D0
00001748  4E4F                    1190              TRAP      #15
0000174A                          1191  
0000174A                          1192              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       16C2
ATH_DONE            16C6
BADINPUT            1052
BAD_OPCODE          12F6
BYTE_TO_BUFFER      16FA
CHECK_IMMEDIATE     134A
CHECK_LENGTH        10DC
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      110E
CR                  D
DONE                1718
DONEMSG             1045
D_TO_EA             147A
EA_000              156E
EA_001              1586
EA_010              159E
EA_011              15BE
EA_100              15E2
EA_101              1606
EA_110              160A
EA_111              160E
EA_IMMEDIATE        165E
EA_LONG             164A
EA_TO_D             1494
EA_WORD             1636
ENDADDR             106E
ENDMSG              1023
FIND_MODE           152A
FIND_OPCODE         12C0
FINISH_PRINT        120E
GET_BITS            1C5
GET_DATA_REG_NUM    14E2
GET_EA_DONE         1664
GET_EA_MODE         1502
GET_END_ADDRESS     10B2
GET_INPUT           1086
GET_NOT_SIZE        13E6
GET_SIZE            14B6
GET_START_ADDRESS   1098
GRAB_FIRST_FOUR_BITS  12AE
GRAB_NEXT_WORD      12A8
HEX_TO_ASCII        166C
IDENTIFY_OPCODE     1274
IMMEDIATE_LONG      1366
IMMEDIATE_WORD      135E
INSERT_SPACE        16D8
INVALID_EA          1666
INVALID_INPUT       10F0
ITERATE             1142
LETTER_TO_ASCII     16BA
LETTER_TO_HEX       1134
LF                  A
LOAD_ADDRESSES      124C
LONG_TO_BUFFER      170A
MAIN                107E
NEWLINE             1062
NUMBER_OR_LETTER    1694
NUMBER_TO_ASCII     16B2
NUM_TO_HEX          112C
OPCODE              107A
OPC_0000            12FC
OPC_0100            136E
OPC_1001            1408
OPC_1100            141C
OPC_1101            1444
OPC_AND             141C
OPC_LEA             13FC
OPC_MULS            1430
OPC_NOP             13B0
OPC_NOT             13C0
OPMODE_TYPE         14CC
OPOUTPUT            1072
OPTAG               107C
PRINT_ADDRESS       11A0
PRINT_INSTRUCTION   122E
PRINT_LONG          11EE
PRINT_MSG           0
PRINT_WORD          11CE
PROCESS_ROEA        1458
RESTORE_REGS        12A2
ROEA_DONE           14AE
SIZE_TO_BUFFER      16DE
STARTADDR           106A
STARTMSG            1000
STB_END             1712
STORE_CHAR          113C
STORE_END           1180
STORE_INPUT         1150
STORE_START         1160
USERADDR            1066
VALID               107D
VALIDATE_INPUT      10CC
WORD_TO_BUFFER      1702
