000012B6 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/18/2021 9:40:04 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00000000                            11              
00001000                            12              ORG     $1000
00001000                            13  
00001000  =0000000D                 14  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 15  LF          EQU     $0A 
00001000                            16  
00001000= 31 2E 20 41 64 64 ...     17  rule1:      DC.B    '1. Addresses must be in the range $FFFFFF > x > $6FFF', CR, LF, 0 ' 
00001038= 77 68 65 72 65 20 ...     18  rule1c:     DC.B    'where x is your given address.', CR, LF, 0 '
00001059= 32 2E 20 49 66 20 ...     19  rule2:      DC.B    '2. If you use any letters (A-F), make sure they are upper case.', CR, LF, 0
0000109B= 33 2E 20 49 66 20 ...     20  rule3:      DC.B    '3. If you use constants (DC), make sure you give addresses that', CR, LF, 0 
000010DD= 64 6F 20 6E 6F 74 ...     21  rule3c:     DC.B    'do not include that part of memory (only want to parse instructions).', CR, LF, 0
00001125= 50 6C 65 61 73 65 ...     22  startMsg:   DC.B    'Please enter a starting address. ', CR, LF, 0
00001149= 50 6C 65 61 73 65 ...     23  endMsg:     DC.B    'Please enter an ending address. ', CR, LF, 0
0000116C= 44 69 73 61 73 73 ...     24  doneMsg:    DC.B    'Disassembly complete, saved to file "dasmOutput.txt."', CR, LF, 0
000011A4= 49 6E 76 61 6C 69 ...     25  badInput:   DC.B    'Invalid Input', CR, LF, 0
000011B4= 0D 0A 00                  26  newline:    DC.B    '', CR, LF, 0
000011B7= 64 61 73 6D 4F 75 ...     27  fileName    DC.B     'dasmOutput.txt',0
000011C6                            28  
000011C6                            29  printAddrEnd     DS.L    0
000011C6                            30  printAddrStart   DS.L    0
000011C6                            31  
000011C6                            32  userAddr:   DS.L    1
000011CA= 00000000                  33              DC.L    0               * Null termination for userAddr
000011CE                            34  startAddr:  DS.L    1
000011D2                            35  endAddr:    DS.L    1
000011D6                            36  
000011D6                            37  opcode:     DS.W    1   
000011D8                            38  opTag:      DS.B    1               * a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
000011D9                            39  opSize:     DS.B    1
000011DA                            40  valid:      DS.B    1
000011DB                            41  
000011DB                            42  ea_mode     DS.B    1
000011DC                            43  ea_register DS.B    1
000011DD                            44  ea_valid    DS.B    1
000011DE                            45  list_mask   DS.W    1
000011E0                            46  
000011E0                            47  
000011E0                            48  
000011E0                            49  
000011E0                            50  
000011E0                            51  
000011E0                            52  
000011E0                            53  *-----------------------------------------------------------
000011E0                            54  * Macros:
000011E0                            55  *-----------------------------------------------------------
000011E0                            56  
000011E0                            57  PRINT_MSG:  MACRO 
000011E0                            58              CLR.L   D0
000011E0                            59              LEA     \1, A1      ; \1 acts as a parameter
000011E0                            60              MOVE.B  #14, D0     
000011E0                            61              TRAP    #15
000011E0                            62              ENDM
000011E0                            63  
000011E0                            64  CLR_D_REGS: MACRO
000011E0                            65              CLR.L   D0
000011E0                            66              CLR.L   D1
000011E0                            67              CLR.L   D2
000011E0                            68              CLR.L   D3
000011E0                            69              CLR.L   D4
000011E0                            70              CLR.L   D5
000011E0                            71              CLR.L   D6
000011E0                            72              CLR.L   D7
000011E0                            73              ENDM
000011E0                            74  
000011E0                            75  CLR_A_REG:  MACRO
000011E0                            76              CLR.L   \1
000011E0                            77              MOVE.L  \1, \2
000011E0                            78              ENDM              
000011E0                            79  
000011E0                            80  *-----------------------------------------------------------
000011E0                            81  * Parameters:
000011E0                            82  *   \1 should be highest bit in range
000011E0                            83  *   \2 should be lowest bit in range
000011E0                            84  * 
000011E0                            85  * Example: #11, #9
000011E0                            86  *
000011E0                            87  * Return Value:
000011E0                            88  *   D4 = value held within bits \1 and \2
000011E0                            89  *
000011E0                            90  * Registers:
000011E0                            91  *   D4 = holds opcode
000011E0                            92  *   D5 = highest bit in range 
000011E0                            93  *   D6 = lowest bit in range 
000011E0                            94  *   D7 = number of bits we want
000011E0                            95  *-----------------------------------------------------------
000011E0                            96  GET_BITS:   MACRO
000011E0                            97  
000011E0                            98              CLR_D_REGS
000011E0                            99  
000011E0                           100              * Subtract value to find amount to shift by 
000011E0                           101              ADD.B   \1, D7          
000011E0                           102              SUB.B   \2, D7 
000011E0                           103              ADD.B   #1, D7  * add 1 because we start our count from 0
000011E0                           104  
000011E0                           105              * Get high bit offset
000011E0                           106              ADD.B   #15, D5
000011E0                           107              SUB.B   \1, D5
000011E0                           108              
000011E0                           109              * shift out high bits
000011E0                           110              MOVE.W  opcode, D4
000011E0                           111              LSL.W   D5, D4
000011E0                           112              
000011E0                           113              *get low bit offset
000011E0                           114              *16 - NUMBER OF BITS WE WANT
000011E0                           115              ADD.B   #16, D6         * 16 total bits
000011E0                           116              SUB.L   D7, D6          * subtract numBits from 16
000011E0                           117              
000011E0                           118              * shift out low bits
000011E0                           119              LSR.W   D6, D4          * isolate bits
000011E0                           120              ENDM
000011E0                           121  
000011E0                           122  *----------------------Value To Buffer----------------------
000011E0                           123  * Description:
000011E0                           124  * Converts a Hex numbered address (1-9 or A-F) back to an
000011E0                           125  * ASCII value and pushes it to the buffer for printing
000011E0                           126  *
000011E0                           127  * Parameters:
000011E0                           128  *   \1 = should hold value (in hex) you want to push to the buffer
000011E0                           129  *
000011E0                           130  *-----------------------------------------------------------
000011E0                           131  VALUE_TO_BUFFER:  MACRO
000011E0                           132                    MOVE.L  \1, D2  
000011E0                           133                    JSR     NUMBER_OR_LETTER
000011E0                           134                    ENDM
000011E0                           135  *-----------------------------------------------------------
000011E0                           136  
000011E0                           137  *----------------------Size To Buffer-----------------------
000011E0                           138  * Description:
000011E0                           139  * Converts a binary size (Byte = 00, Word = 01, or Long = 10) 
000011E0                           140  * to a letter (B, W, L) and pushes it to the buffer
000011E0                           141  *
000011E0                           142  * Parameters:
000011E0                           143  *   \1 = should hold size (in binary) of the size you want
000011E0                           144  *        to push to the buffer
000011E0                           145  *
000011E0                           146  *-----------------------------------------------------------
000011E0                           147  SIZE_TO_BUFFER:   MACRO
000011E0                           148                    MOVE.L  \1, D3
000011E0                           149                    JSR     FIND_SIZE
000011E0                           150                    ENDM
000011E0                           151  *-----------------------------------------------------------
000011E0                           152  
000011E0                           153  
000011E0                           154  
000011E0                           155  
000011E0                           156  
000011E0                           157  
000011E0                           158  *----------------Decoding EA Mode and Register--------------
000011E0                           159  * Description:
000011E0                           160  * Decodes EA mode and register and pushes to buffer
000011E0                           161  * 
000011E0                           162  * Parameters:
000011E0                           163  *   \1 = high bit of ea
000011E0                           164  *   \2 = low bit of ea
000011E0                           165  *
000011E0                           166  * Registers Used:
000011E0                           167  *   D1 = temp variable
000011E0                           168  *
000011E0                           169  * For Example (most common): 
000011E0                           170  *   DECODE_EA    #5, #0
000011E0                           171  *
000011E0                           172  *-----------------------------------------------------------
000011E0                           173  DECODE_EA:  MACRO
000011E0                           174              CLR_D_REGS
000011E0                           175              MOVE.B      \1, D1
000011E0                           176              JSR         DECODE_EA_HELP
000011E0                           177              JSR         EA_TO_BUFFER
000011E0                           178              ENDM
000011E0                           179  
000011E0                           180  GET_EA_MODE: MACRO
000011E0                           181               GET_BITS        \1, \2
000011E0                           182               MOVE.B          D4, ea_mode
000011E0                           183               ENDM
000011E0                           184  
000011E0                           185  GET_EA_REG:  MACRO
000011E0                           186               GET_BITS        \1, \2
000011E0                           187               MOVE.B          D4, ea_register
000011E0                           188               ENDM
000011E0                           189  *-----------------------------------------------------------
000011E0                           190  
000011E0                           191  *-----------------------------------------------------------
000011E0                           192  DECODE_EA_HELP:
000011E0                           193          
000011E0  B23C 0005                194              CMP.B       #5, D1               * is this bits 5-0?
000011E4  6700 000A                195              BEQ         DECODE_6_TO_0
000011E8                           196  
000011E8  B23C 000B                197              CMP.B       #11, D1              * is this bits 11-6? 
000011EC  6700 0064                198              BEQ         DECODE_11_TO_6
000011F0                           199  
000011F0                           200  DECODE_6_TO_0:
000011F0                           201m             GET_EA_MODE #5, #3               * get ea mode
00001200                           202mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001206                           203mm             * GET HIGH BIT OFFSET
0000120C                           204mm             * SHIFT OUT HIGH BITS
00001212                           205mm             *GET LOW BIT OFFSET
00001212                           206mm             *16 - NUMBER OF BITS WE WANT
00001218                           207mm             * SHIFT OUT LOW BITS
0000121E                           208m             GET_EA_REG  #2, #0               * get ea register
0000122E                           209mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001236                           210mm             * GET HIGH BIT OFFSET
0000123C                           211mm             * SHIFT OUT HIGH BITS
00001242                           212mm             *GET LOW BIT OFFSET
00001242                           213mm             *16 - NUMBER OF BITS WE WANT
00001248                           214mm             * SHIFT OUT LOW BITS
0000124E  6000 0064                215              BRA         EA_END
00001252                           216  
00001252                           217  DECODE_11_TO_6:
00001252                           218m             GET_EA_MODE #8, #6               * get ea mode
00001262                           219mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001268                           220mm             * GET HIGH BIT OFFSET
0000126E                           221mm             * SHIFT OUT HIGH BITS
00001274                           222mm             *GET LOW BIT OFFSET
00001274                           223mm             *16 - NUMBER OF BITS WE WANT
0000127A                           224mm             * SHIFT OUT LOW BITS
00001280                           225m             GET_EA_REG  #11, #9              * get ea register
00001290                           226mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000129A                           227mm             * GET HIGH BIT OFFSET
000012A2                           228mm             * SHIFT OUT HIGH BITS
000012A8                           229mm             *GET LOW BIT OFFSET
000012A8                           230mm             *16 - NUMBER OF BITS WE WANT
000012AE                           231mm             * SHIFT OUT LOW BITS
000012B4                           232  
000012B4                           233  EA_END:
000012B4  4E75                     234              RTS
000012B6                           235  
000012B6                           236  *-----------------------------------------------------------            
000012B6                           237  
000012B6                           238  
000012B6                           239  
000012B6                           240  
000012B6                           241  
000012B6                           242  *----------------------Buffer Macros------------------------
000012B6                           243  * Description:
000012B6                           244  * Pushes commonly used single characters to the buffer
000012B6                           245  *-----------------------------------------------------------
000012B6                           246  INSERT_SPACE:   MACRO
000012B6                           247                  MOVE.B  #' ',(A1)+          * add blank space to buffer
000012B6                           248                  ENDM
000012B6                           249  
000012B6                           250  INSERT_COMMA:   MACRO
000012B6                           251                  MOVE.B  #',',(A1)+          * add blank space to buffer
000012B6                           252                  ENDM
000012B6                           253  
000012B6                           254  INSERT_PERIOD:  MACRO
000012B6                           255                  MOVE.B  #'.',(A1)+          * add blank space to buffer
000012B6                           256                  ENDM
000012B6                           257  
000012B6                           258  INSERT_POUND:   MACRO
000012B6                           259                  MOVE.B  #'#',(A1)+          * add blank space to buffer
000012B6                           260                  ENDM
000012B6                           261  
000012B6                           262  INSERT_DOLLAR:  MACRO
000012B6                           263                  MOVE.B  #'$',(A1)+          * add blank space to buffer
000012B6                           264                  ENDM
000012B6                           265  *-----------------------------------------------------------
000012B6                           266  
000012B6                           267  
000012B6                           268  
000012B6                           269  
000012B6                           270  
000012B6                           271  
000012B6                           272  
000012B6                           273  
000012B6                           274  
000012B6                           275  *-----------------------------------------------------------
000012B6                           276  * Description:  
000012B6                           277  * Main routine
000012B6                           278  *-----------------------------------------------------------
000012B6                           279              
000012B6                           280  *-------------------------MAIN------------------------------
000012B6                           281  MAIN:
000012B6  103C 0032                282              MOVE.B #50,D0 *Use this at the start of any program with file handling
000012BA  4E4F                     283              TRAP   #15
000012BC                           284              
000012BC  43F8 11B7                285              LEA    fileName, A1 *Load the name of the file
000012C0  103C 0034                286              MOVE.B #52, D0 *Create file or overwrite existing
000012C4  4E4F                     287              TRAP   #15
000012C6                           288              
000012C6  4280                     289              CLR.L  D0
000012C8                           290              
000012C8                           291m             PRINT_MSG    rule1
000012D4                           292m             PRINT_MSG    rule1c
000012E0                           293m             PRINT_MSG    rule2
000012EC                           294m             PRINT_MSG    rule3
000012F8                           295m             PRINT_MSG    rule3c
00001304  6100 0006                296              BSR          GET_INPUT
00001308  6000 01B6                297              BRA          LOAD_ADDRESSES
0000130C                           298  *-----------------------------------------------------------
0000130C                           299  
0000130C                           300  
0000130C                           301  
0000130C                           302  
0000130C                           303  
0000130C                           304  
0000130C                           305  
0000130C                           306  
0000130C                           307  *-----------------------------------------------------------
0000130C                           308  * Description:  
0000130C                           309  * Get User Input
0000130C                           310  *
0000130C                           311  * Registers Used:
0000130C                           312  *   D0 = task values
0000130C                           313  *   D1 = stores of size of ascii string in A1 from user input
0000130C                           314  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
0000130C                           315  *   A1 = stores an ascii string from user input
0000130C                           316  *-----------------------------------------------------------
0000130C                           317  *-------------------------Get Input-------------------------
0000130C                           318  GET_INPUT:
0000130C  4283                     319              CLR.L        D3
0000130E  4284                     320              CLR.L        D4
00001310                           321m             PRINT_MSG    startMsg
0000131C  6100 003E                322              BSR          GET_ADDRESS   
00001320  B87C 0001                323              CMP          #1, D4
00001324  6700 0034                324              BEQ          RESTART_INPUT
00001328  21C7 11CE                325              MOVE.L       D7, startAddr
0000132C                           326  
0000132C                           327  
0000132C  4283                     328              CLR.L        D3
0000132E  4284                     329              CLR.L        D4
00001330                           330m             PRINT_MSG    endMsg
0000133C  6100 001E                331              BSR          GET_ADDRESS   
00001340  B87C 0001                332              CMP          #1, D4
00001344  6700 0014                333              BEQ          RESTART_INPUT
00001348  21C7 11D2                334              MOVE.L       D7, endAddr
0000134C                           335  
0000134C  6100 005C                336              BSR          CHECK_ADDRESS
00001350  B87C 0001                337              CMP          #1, D4
00001354  6700 0004                338              BEQ          RESTART_INPUT
00001358                           339  
00001358  4E75                     340              RTS
0000135A                           341  
0000135A                           342  RESTART_INPUT:
0000135A  60B0                     343              BRA        GET_INPUT
0000135C                           344  *-----------------------------------------------------------
0000135C                           345  
0000135C                           346  *------------------------Get Address------------------------
0000135C                           347  GET_ADDRESS:
0000135C                           348              * ask for input
0000135C  43F8 11C6                349              LEA.L   userAddr, A1
00001360  103C 0002                350              MOVE.B  #2, D0
00001364  4E4F                     351              TRAP    #15
00001366                           352  
00001366                           353              * error checking - length
00001366  6100 001C                354              BSR     CHECK_LENGTH
0000136A  B87C 0001                355              CMP     #1, D4
0000136E  6700 0012                356              BEQ     RETURN_TO_INPUT
00001372                           357  
00001372                           358              * error checking - valid characters
00001372  6100 0068                359              BSR     CONVERT_TO_HEX
00001376  B87C 0001                360              CMP     #1, D4
0000137A  6700 0006                361              BEQ     RETURN_TO_INPUT
0000137E                           362  
0000137E  4284                     363              CLR.L   D4
00001380  4E75                     364              RTS
00001382                           365  
00001382                           366  RETURN_TO_INPUT:
00001382  4E75                     367              RTS
00001384                           368  *-----------------------------------------------------------
00001384                           369  
00001384                           370  
00001384                           371  
00001384                           372  
00001384                           373  
00001384                           374  
00001384                           375  
00001384                           376  
00001384                           377  
00001384                           378  
00001384                           379  *-----------------------------------------------------------
00001384                           380  * Description:  Validate User Input
00001384                           381  * Constraints:  
00001384                           382  *   User input must be:
00001384                           383  *   Length 4 or Length 8
00001384                           384  *   ASCII character 0-9 or A-F
00001384                           385  *   Starting and ending address with value < $00FFFFFF 
00001384                           386  *   Starting address is before ending address
00001384                           387  *
00001384                           388  * Registers Used:
00001384                           389  *   D0 = task values
00001384                           390  *   D1 = stores of size of ascii string in A1 from user input
00001384                           391  *   D4 = bool check (1 = FALSE, 0 = TRUE)
00001384                           392  *   A1 = stores an ascii string from user input
00001384                           393  *-----------------------------------------------------------
00001384                           394  
00001384                           395  *----------------------VALIDATE INPUT---------------------------      
00001384                           396  CHECK_LENGTH:
00001384  4284                     397              CLR.L      D4
00001386                           398  
00001386  B23C 0001                399              CMP.B      #1, D1               ; for task 2, length of string is in D1                
0000138A  6D00 000C                400              BLT        INVALID_INPUT 
0000138E                           401  
0000138E  B23C 0006                402              CMP.B      #6, D1               ; address can either be 4 or 8 bits in length  
00001392  6E00 0004                403              BGT        INVALID_INPUT
00001396                           404  
00001396  4E75                     405              RTS
00001398                           406  
00001398                           407  INVALID_INPUT:  
00001398                           408m             PRINT_MSG  badInput
000013A4  183C 0001                409              MOVE.B     #1, D4
000013A8  4E75                     410              RTS
000013AA                           411  *-----------------------------------------------------------
000013AA                           412  
000013AA                           413  *----------------------CHECK ADDRESS------------------------      
000013AA                           414  CHECK_ADDRESS:
000013AA  2A38 11CE                415              MOVE.L     startAddr, D5
000013AE  BAB8 11D2                416              CMP.L      endAddr, D5          ; starting address >= ending address?
000013B2  6C00 0016                417              BGE        INVALID_ADDRESS
000013B6                           418  
000013B6  BABC 00000100            419              CMP.L      #$100, D5
000013BC  6DDA                     420              BLT        INVALID_INPUT 
000013BE                           421              
000013BE  0CB8 00FFFFFF 11D2       422              CMP.L      #$FFFFFF, endAddr
000013C6  6ED0                     423              BGT        INVALID_INPUT
000013C8  4E75                     424              RTS
000013CA                           425  
000013CA                           426  INVALID_ADDRESS:  
000013CA                           427m             PRINT_MSG  badInput
000013D6  183C 0001                428              MOVE.B     #1, D4
000013DA  4E75                     429              RTS
000013DC                           430  *-----------------------------------------------------------
000013DC                           431  
000013DC                           432  *----------------CONVERT FROM ASCII TO HEX------------------
000013DC                           433  CONVERT_TO_HEX:
000013DC  0C11 0030                434              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
000013E0  6DB6                     435              BLT        INVALID_INPUT        
000013E2                           436  
000013E2  0C11 003A                437              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
000013E6  6D00 0012                438              BLT        NUM_TO_HEX      
000013EA                           439  
000013EA  0C11 0041                440              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
000013EE  6DA8                     441              BLT        INVALID_INPUT             
000013F0                           442  
000013F0  0C11 0047                443              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
000013F4  6D00 000C                444              BLT        LETTER_TO_HEX
000013F8                           445  
000013F8  609E                     446              BRA        INVALID_INPUT    
000013FA                           447  
000013FA                           448  NUM_TO_HEX:      
000013FA  0411 0030                449              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
000013FE  6000 000A                450              BRA        STORE_CHAR   
00001402                           451  
00001402                           452  LETTER_TO_HEX:     
00001402  0411 0037                453              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001406  6000 0002                454              BRA        STORE_CHAR
0000140A                           455  
0000140A                           456  STORE_CHAR:       
0000140A  D619                     457              ADD.B      (A1)+, D3           ; keep hex stored in D3           
0000140C  6000 0002                458              BRA        ITERATE                 
00001410                           459  
00001410                           460  ITERATE:
00001410  5301                     461              SUB.B      #$1, D1
00001412  B23C 0000                462              CMP.B      #0, D1
00001416  6700 0006                463              BEQ        STORE_INPUT
0000141A                           464  
0000141A  E98B                     465              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000141C  60BE                     466              BRA        CONVERT_TO_HEX
0000141E                           467  
0000141E                           468  STORE_INPUT:
0000141E  2E03                     469              MOVE.L     D3, D7
00001420  4E75                     470              RTS
00001422                           471  *-----------------------------------------------------------
00001422                           472  
00001422                           473  
00001422                           474  
00001422                           475  
00001422                           476  
00001422                           477  
00001422                           478  
00001422                           479  
00001422                           480  
00001422                           481  
00001422                           482              
00001422                           483  *--------------------------PRINT----------------------------
00001422                           484  * Description:
00001422                           485  * Prints hex addresses according to where we are in the .S file
00001422                           486  * and source/destination effective addresses
00001422                           487  *
00001422                           488  * No Parameters
00001422                           489  *
00001422                           490  * Registers:
00001422                           491  *   D0 = used for tasks and trap #15
00001422                           492  *   D1 = size of comparison
00001422                           493  *   D2 = destination for comparisons, holds an address
00001422                           494  *   D3 = iterator
00001422                           495  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001422                           496  *   A2 = current address (given by user)
00001422                           497  *-----------------------------------------------------------
00001422                           498  
00001422                           499  *----------------------PRINT_ADDRESS------------------------
00001422                           500  PRINT_ADDRESS:
00001422                           501  
00001422                           502              *Copy end adress to data register, used for calculating # of bytes to write to file
00001422                           503              *MOVE.L  A1,printAddrEnd
00001422                           504              *MOVE.L  A1,d1 
00001422                           505  
00001422                           506              * reset A1 to beginning of string
00001422                           507m             CLR_A_REG D0, A1
00001426                           508              
00001426                           509              *Copy start address
00001426                           510              *MOVE.L  A1,printAddrStart 
00001426                           511              *MOVE.L  A1,d2 
00001426                           512              
00001426                           513              * move current address to D2
00001426  240A                     514              MOVE.L    A2, D2
00001428                           515             
00001428                           516              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
00001428  223C 00008000            517              MOVE.L    #$8000, D1
0000142E  B481                     518              CMP.L     D1, D2
00001430  6D00 000E                519              BLT       PRINT_WORD
00001434                           520              
00001434                           521              * if absolute long, print long. Range $8000 - $FFFF7FFF
00001434  223C FFFF8000            522              MOVE.L    #$FFFF8000, D1
0000143A  B481                     523              CMP.L     D1, D2
0000143C  6C00 000C                524              BGE       PRINT_LONG                 
00001440                           525  
00001440                           526  PRINT_WORD:
00001440  123C 0001                527              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
00001444  3E0A                     528              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
00001446  6000 000C                529              BRA       FINISH_PRINT
0000144A                           530  
0000144A                           531  PRINT_LONG:
0000144A  123C 0003                532              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
0000144E  2E0A                     533              MOVE.L    A2, D7
00001450  6000 0002                534              BRA       FINISH_PRINT
00001454                           535  
00001454                           536  FINISH_PRINT:
00001454                           537              * convert hex values back to ASCII
00001454  4EB9 000023EC            538              JSR       HEX_TO_ASCII
0000145A                           539              
0000145A                           540              * print out string
0000145A  12BC 0000                541              MOVE.B    #00,(A1)
0000145E                           542m             CLR_A_REG D0, A1
00001462  103C 000E                543              MOVE.B    #14, D0
00001466  4E4F                     544              TRAP      #15
00001468                           545              
00001468  4282                     546              CLR.L     D2                    
0000146A  6000 0004                547              BRA       FIND_NUM_OF_CHARS
0000146E                           548              
0000146E  4E75                     549              RTS
00001470                           550  
00001470                           551  FIND_NUM_OF_CHARS:
00001470  1A11                     552              MOVE.B    (A1),D5
00001472  BA3C 0000                553              CMP.B     #00, D5
00001476  6700 0008                554              BEQ       FIND_NUMS_DONE
0000147A  5202                     555              ADD.B     #1, D2
0000147C  1A19                     556              MOVE.B    (A1)+, D5
0000147E  60F0                     557              BRA       FIND_NUM_OF_CHARS
00001480                           558  
00001480                           559  FIND_NUMS_DONE:
00001480                           560m             CLR_A_REG D0, A1
00001484  103C 0036                561              MOVE.B #54,D0 *Write to file
00001488  4E4F                     562              TRAP   #15
0000148A  4E75                     563              RTS
0000148C                           564  *-----------------------------------------------------------
0000148C                           565  
0000148C                           566  *-------------------PRINT_INSTRUCTION-----------------------
0000148C                           567  PRINT_INSTRUCTION:            
0000148C  2409                     568              MOVE.L    A1,D2 *Load end address into d2, this will be used to later calculated # of bytes to write to file 
0000148E  12BC 0000                569              MOVE.B    #00,(A1) * null terminator             
00001492                           570  
00001492                           571              * reset A1 to beginning of string
00001492  4280                     572              CLR.L     D0
00001494                           573m             CLR_A_REG D0, A1
00001498                           574  
00001498                           575              * print out string
00001498  103C 000E                576              MOVE.B    #14, D0
0000149C  4E4F                     577              TRAP      #15
0000149E                           578              
0000149E                           579              *Print to File
0000149E  9489                     580              SUB.L   A1,D2 *Subtract start address from end address to determine number of bytes to read
000014A0  103C 0036                581              MOVE.B  #54,D0 *Trap task to write to file
000014A4  4E4F                     582              TRAP    #15
000014A6                           583              
000014A6  43F8 11B4                584              LEA newline,A1 *Create new line on file
000014AA                           585              
000014AA  7401                     586              MOVE.L #1,D2
000014AC  103C 0036                587              MOVE.B #54,D0 *Trap task to write to file
000014B0  4E4F                     588              TRAP   #15
000014B2                           589  
000014B2                           590m             PRINT_MSG newline
000014BE  4E75                     591              RTS
000014C0                           592  *-----------------------------------------------------------
000014C0                           593  
000014C0                           594  
000014C0                           595  
000014C0                           596  
000014C0                           597  
000014C0                           598  
000014C0                           599  
000014C0                           600  
000014C0                           601  
000014C0                           602  
000014C0                           603  
000014C0                           604  
000014C0                           605  
000014C0                           606  
000014C0                           607  
000014C0                           608  
000014C0                           609  
000014C0                           610  
000014C0                           611  
000014C0                           612  
000014C0                           613  *---------------------LOAD ADDRESSES------------------------
000014C0                           614  * Description:
000014C0                           615  * Stores INITIAL values into appropriate address registers 
000014C0                           616  * which is necessary to complete before starting identify opcodes loop
000014C0                           617  * Also pushes reigsters onto the stack
000014C0                           618  *
000014C0                           619  * No Parameters
000014C0                           620  *
000014C0                           621  * Registers:
000014C0                           622  *   A2 = current address (given by user)
000014C0                           623  *   A3 = ending address (given by user)
000014C0                           624  *-----------------------------------------------------------
000014C0                           625  LOAD_ADDRESSES: 
000014C0                           626              * reset A1 to beginning of string
000014C0  4280                     627              CLR.L       D0
000014C2                           628m             CLR_A_REG   D0, A1
000014C6                           629  
000014C6                           630              * load start and end registers and print starting address
000014C6  2478 11CE                631              MOVEA.L     startAddr, A2
000014CA  2678 11D2                632              MOVEA.L     endAddr, A3
000014CE  6100 FF52                633              BSR         PRINT_ADDRESS
000014D2                           634m             INSERT_SPACE
000014D6                           635  
000014D6  6100 003A                636              BSR         GRAB_NEXT_WORD
000014DA  6100 003C                637              BSR         GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
000014DE                           638  
000014DE                           639              * Push current registers onto the stack (so we can have fresh registers)
000014DE  48E7 FF00                640              MOVEM.L D0-D7,-(SP)                  ; move the old registers onto the stack
000014E2  6000 006A                641              BRA     FIND_OPCODE
000014E6                           642  *-----------------------------------------------------------
000014E6                           643  
000014E6                           644  *-----------------------------------------------------------
000014E6                           645  * Description:  IDENTIFY OPCODES LOOP
000014E6                           646  * Registers:
000014E6                           647  *   D0 = used for tasks and trap #15
000014E6                           648  *   D1 = size of shifting bits
000014E6                           649  *   D2 = destination for shifts
000014E6                           650  *   D3 = size of opcode
000014E6                           651  *   D4 = used to hold bits returned from SHIFT macro
000014E6                           652  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000014E6                           653  *   A2 = current address (given by user)
000014E6                           654  *   A3 = ending address (given by user)
000014E6                           655  *-----------------------------------------------------------
000014E6                           656  *-------------------IDENTIFY OPCODES------------------------
000014E6                           657  * evaluates an opcode based on first four bits (aka opTag)
000014E6                           658  * for now only works with one instruction
000014E6                           659  *-----------------------------------------------------------
000014E6                           660  IDENTIFY_OPCODE:
000014E6                           661  
000014E6                           662              * print opcode
000014E6  61A4                     663              BSR     PRINT_INSTRUCTION
000014E8                           664  
000014E8                           665              * check if starting address >= ending address
000014E8  B5CB                     666              CMPA.L  A3, A2
000014EA  6C00 0FA6                667              BGE     DONE
000014EE                           668              
000014EE                           669              * print next address
000014EE  6100 FF32                670              BSR     PRINT_ADDRESS
000014F2                           671m             INSERT_SPACE
000014F6                           672  
000014F6                           673m             CLR_D_REGS
00001506  6100 000A                674              BSR     GRAB_NEXT_WORD          * grab opcode
0000150A  6100 000C                675              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
0000150E                           676             
0000150E  6000 003E                677              BRA     FIND_OPCODE
00001512                           678  *------------------------------------------------------------
00001512                           679  
00001512                           680  *---------Useful Subroutines For Identifying Opcodes--------
00001512                           681  GRAB_NEXT_WORD:
00001512                           682              * load current word of bits into D7
00001512  31DA 11D6                683              MOVE.W (A2)+, opcode
00001516  4E75                     684              RTS
00001518                           685  
00001518                           686  GRAB_FIRST_FOUR_BITS:
00001518                           687              * find first four bits of opcode
00001518                           688m             GET_BITS  #15, #12
00001528                           689m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001532                           690m             * GET HIGH BIT OFFSET
0000153A                           691m             * SHIFT OUT HIGH BITS
00001540                           692m             *GET LOW BIT OFFSET
00001540                           693m             *16 - NUMBER OF BITS WE WANT
00001546                           694m             * SHIFT OUT LOW BITS
00001548  11C4 11D8                695              MOVE.B    D4, opTag
0000154C  4E75                     696              RTS
0000154E                           697  *-----------------------------------------------------------
0000154E                           698  
0000154E                           699  
0000154E                           700  
0000154E                           701  
0000154E                           702  
0000154E                           703  
0000154E                           704  
0000154E                           705  
0000154E                           706  
0000154E                           707  *----------------------FIND OPCODE--------------------------
0000154E                           708  * Description:
0000154E                           709  * Finds a matching opTag (first four bits of opcode) and 
0000154E                           710  * jumps to that opcode's encoding subroutine
0000154E                           711  *
0000154E                           712  * For example:
0000154E                           713  *               ADD's first four bits = 1101, so I put
0000154E                           714  *               CMP.B #%1101, D0
0000154E                           715  *
0000154E                           716  * No Parameters
0000154E                           717  *
0000154E                           718  * No Registers Used
0000154E                           719  *-----------------------------------------------------------        
0000154E                           720  FIND_OPCODE:
0000154E  0C38 0000 11D8           721              CMP.B   #%0000, opTag 
00001554  6700 0084                722              BEQ     OPC_0000
00001558                           723  
00001558  0C38 0001 11D8           724              CMP.B   #%0001, opTag 
0000155E  6700 0196                725              BEQ     OPC_0001
00001562                           726  
00001562  0C38 0002 11D8           727              CMP.B   #%0010, opTag 
00001568  6700 01B6                728              BEQ     OPC_0010
0000156C                           729  
0000156C  0C38 0003 11D8           730              CMP.B   #%0011, opTag 
00001572  6700 01D6                731              BEQ     OPC_0011
00001576                           732  
00001576  0C38 0004 11D8           733              CMP.B   #%0100, opTag 
0000157C  6700 023C                734              BEQ     OPC_0100
00001580                           735              
00001580  0C38 0006 11D8           736              CMP.B   #%0110, opTag
00001586  6700 05C6                737              BEQ     OPC_0110
0000158A                           738  
0000158A  0C38 0005 11D8           739              CMP.B   #%0101, opTag 
00001590  6700 04AE                740              BEQ     OPC_0101
00001594                           741              
00001594  0C38 0007 11D8           742              CMP.B   #%0111, opTag 
0000159A  6700 03E0                743              BEQ     OPC_0111
0000159E                           744  
0000159E  0C38 0008 11D8           745              CMP.B   #%1000, opTag
000015A4  6700 046E                746              BEQ     OPC_1000
000015A8                           747  
000015A8  0C38 0009 11D8           748              CMP.B   #%1001, opTag
000015AE  6700 073A                749              BEQ     OPC_1001
000015B2                           750  
000015B2  0C38 000C 11D8           751              CMP.B   #%1100, opTag
000015B8  6700 0744                752              BEQ     OPC_1100
000015BC                           753  
000015BC  0C38 000D 11D8           754              CMP.B   #%1101, opTag
000015C2  6700 07B2                755              BEQ     OPC_1101
000015C6                           756              
000015C6  0C38 000E 11D8           757              CMP.B   #%1110, opTag
000015CC  6700 07BC                758              BEQ     OPC_1110
000015D0                           759  
000015D0                           760              * error, bad opcode
000015D0  6000 0002                761              BRA      BAD_OPCODE
000015D4                           762  
000015D4                           763  *-----------------------------------------------------------
000015D4                           764  
000015D4                           765  *-----------------------BAD OPCODE--------------------------
000015D4                           766  BAD_OPCODE:
000015D4  4EF9 00002492            767              JMP      DONE
000015DA                           768  *-----------------------------------------------------------
000015DA                           769  
000015DA                           770  *------------------------OPC_0000---------------------------
000015DA                           771  * First four bits = 0000
000015DA                           772  * (ADDI, SUBI)
000015DA                           773  *-----------------------------------------------------------
000015DA                           774  OPC_0000:
000015DA                           775m             GET_BITS  #11, #8
000015EA                           776m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000015F2                           777m             * GET HIGH BIT OFFSET
000015FA                           778m             * SHIFT OUT HIGH BITS
00001600                           779m             *GET LOW BIT OFFSET
00001600                           780m             *16 - NUMBER OF BITS WE WANT
00001606                           781m             * SHIFT OUT LOW BITS
00001608                           782              
00001608                           783              * is the opcode ANDI?
00001608  B83C 0002                784              CMP.B     #%0010, D4
0000160C  6700 0016                785              BEQ       OPC_ANDI
00001610                           786  
00001610                           787              * is the opcode ADDI?
00001610  B83C 0006                788              CMP.B     #%0110, D4
00001614  6700 0026                789              BEQ       OPC_ADDI
00001618                           790  
00001618                           791              * is the opcode SUBI?
00001618  B83C 0004                792              CMP.B     #%0100, D4
0000161C  6700 0036                793              BEQ       OPC_SUBI
00001620                           794  
00001620                           795  
00001620  4EF8 15D4                796              JMP       BAD_OPCODE
00001624                           797  
00001624                           798  *------------------------OPC_ANDI---------------------------
00001624                           799  OPC_ANDI:
00001624  12FC 0041                800              MOVE.B  #'A',(A1)+          * Put AND into Buff
00001628  12FC 004E                801              MOVE.B  #'N',(A1)+
0000162C  12FC 0044                802              MOVE.B  #'D',(A1)+
00001630  12FC 0049                803              MOVE.B  #'I',(A1)+
00001634                           804m             INSERT_PERIOD
00001638                           805  
00001638  6100 0032                806              BSR     DECODE_IMMEDIATE
0000163C                           807  
0000163C                           808  *------------------------OPC_ADDI---------------------------
0000163C                           809  OPC_ADDI:
0000163C  12FC 0041                810              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001640  12FC 0044                811              MOVE.B  #'D',(A1)+
00001644  12FC 0044                812              MOVE.B  #'D',(A1)+
00001648  12FC 0049                813              MOVE.B  #'I',(A1)+
0000164C                           814m             INSERT_PERIOD
00001650                           815  
00001650  6100 001A                816              BSR     DECODE_IMMEDIATE
00001654                           817  
00001654                           818  *------------------------OPC_SUBI---------------------------
00001654                           819  OPC_SUBI:            
00001654  12FC 0053                820              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001658  12FC 0055                821              MOVE.B  #'U',(A1)+
0000165C  12FC 0042                822              MOVE.B  #'B',(A1)+
00001660  12FC 0049                823              MOVE.B  #'I',(A1)+
00001664                           824m             INSERT_PERIOD
00001668                           825  
00001668  6100 0002                826              BSR     DECODE_IMMEDIATE
0000166C                           827  
0000166C                           828  *--------------Subroutines for OPC_0000---------------------  
0000166C                           829  DECODE_IMMEDIATE:
0000166C                           830              * push size to buffer
0000166C                           831m             GET_BITS        #7, #6              * get size bits (gets returned to D4)
0000167C                           832m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001682                           833m             * GET HIGH BIT OFFSET
00001688                           834m             * SHIFT OUT HIGH BITS
0000168E                           835m             *GET LOW BIT OFFSET
0000168E                           836m             *16 - NUMBER OF BITS WE WANT
00001694                           837m             * SHIFT OUT LOW BITS
00001696  11C4 11D9                838              MOVE.B          D4, opSize
0000169A                           839m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000016A2                           840  
000016A2                           841              * push #<data> to buffer
000016A2  4EB9 000016D2            842              JSR             CHECK_IMMEDIATE
000016A8                           843  
000016A8                           844m             INSERT_COMMA
000016AC                           845m             INSERT_SPACE
000016B0                           846  
000016B0                           847              * push <ea> to buffer
000016B0                           848m             DECODE_EA       #5, #0
000016CE  6000 FE16                849              BRA             IDENTIFY_OPCODE
000016D2                           850   
000016D2                           851  CHECK_IMMEDIATE:
000016D2                           852m             INSERT_POUND
000016D6                           853  
000016D6  B67C 0001                854              CMP     #1, D3
000016DA  6F00 000A                855              BLE     IMMEDIATE_WORD
000016DE                           856  
000016DE  B67C 0002                857              CMP     #2, D3
000016E2  6000 000A                858              BRA     IMMEDIATE_LONG
000016E6                           859  
000016E6                           860  IMMEDIATE_WORD:
000016E6  4EB9 000023A0            861              JSR     EA_WORD
000016EC  4E75                     862              RTS
000016EE                           863  
000016EE                           864  IMMEDIATE_LONG:
000016EE  4EB9 000023B4            865              JSR     EA_LONG      
000016F4  4E75                     866              RTS
000016F6                           867  *-----------------------------------------------------------
000016F6                           868  
000016F6                           869  *------------------------OPC_0001---------------------------
000016F6                           870  * First four bits = 0001
000016F6                           871  * (MOVE.B)
000016F6                           872  *-----------------------------------------------------------
000016F6                           873  OPC_0001:
000016F6  12FC 004D                874              MOVE.B   #'M',(A1)+          * Put ADD into Buff
000016FA  12FC 004F                875              MOVE.B   #'O',(A1)+
000016FE  12FC 0056                876              MOVE.B   #'V',(A1)+
00001702  12FC 0045                877              MOVE.B   #'E',(A1)+
00001706  12FC 002E                878              MOVE.B   #'.',(A1)+
0000170A  12FC 0042                879              MOVE.B   #'B',(A1)+
0000170E                           880m             INSERT_SPACE
00001712                           881  
00001712  11FC 0000 11D9           882              MOVE.B   #0, opSize
00001718                           883  
00001718  6100 005A                884              BSR      DECODE_MOVE
0000171C  6000 FDC8                885              BRA      IDENTIFY_OPCODE
00001720                           886  *-----------------------------------------------------------
00001720                           887  
00001720                           888  *------------------------OPC_0010---------------------------
00001720                           889  * First four bits = 0010
00001720                           890  * (MOVE.L)
00001720                           891  *-----------------------------------------------------------
00001720                           892  OPC_0010:
00001720  12FC 004D                893              MOVE.B  #'M',(A1)+          * Put ADD into Buff
00001724  12FC 004F                894              MOVE.B  #'O',(A1)+
00001728  12FC 0056                895              MOVE.B  #'V',(A1)+
0000172C  12FC 0045                896              MOVE.B  #'E',(A1)+
00001730  12FC 002E                897              MOVE.B  #'.',(A1)+
00001734  12FC 004C                898              MOVE.B  #'L',(A1)+
00001738                           899m             INSERT_SPACE
0000173C                           900  
0000173C  11FC 0002 11D9           901              MOVE.B   #2, opSize
00001742                           902  
00001742  6100 0030                903              BSR      DECODE_MOVE
00001746  6000 FD9E                904              BRA      IDENTIFY_OPCODE
0000174A                           905  *-----------------------------------------------------------
0000174A                           906  
0000174A                           907  *------------------------OPC_0011---------------------------
0000174A                           908  * First four bits = 0011
0000174A                           909  * (MOVE.W)
0000174A                           910  *-----------------------------------------------------------
0000174A                           911  OPC_0011:
0000174A  12FC 004D                912              MOVE.B  #'M',(A1)+          * Put ADD into Buff
0000174E  12FC 004F                913              MOVE.B  #'O',(A1)+
00001752  12FC 0056                914              MOVE.B  #'V',(A1)+
00001756  12FC 0045                915              MOVE.B  #'E',(A1)+
0000175A  12FC 002E                916              MOVE.B  #'.',(A1)+
0000175E  12FC 0057                917              MOVE.B  #'W',(A1)+
00001762                           918m             INSERT_SPACE
00001766                           919  
00001766  11FC 0001 11D9           920              MOVE.B   #1, opSize
0000176C                           921  
0000176C  6100 0006                922              BSR      DECODE_MOVE
00001770  6000 FD74                923              BRA      IDENTIFY_OPCODE
00001774                           924  *-----------------------------------------------------------
00001774                           925  
00001774                           926  *---------------------Decode Move---------------------------
00001774                           927  DECODE_MOVE:
00001774                           928m             DECODE_EA       #5, #0
00001792                           929              
00001792                           930m             INSERT_COMMA
00001796                           931m             INSERT_SPACE
0000179A                           932  
0000179A                           933m             DECODE_EA       #11, #6
000017B8  4E75                     934              RTS
000017BA                           935  *-----------------------------------------------------------
000017BA                           936  
000017BA                           937  *------------------------OPC_0100---------------------------
000017BA                           938  * First four bits = 0100
000017BA                           939  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
000017BA                           940  *-----------------------------------------------------------
000017BA                           941  OPC_0100:
000017BA                           942  
000017BA                           943              * Check if the opcode is NOP
000017BA  3438 11D6                944              MOVE.W  opcode, D2              * Copy opcode to D2
000017BE  B47C 4E71                945              CMP.W   #$4E71, D2              * Check if D2 is equal to NOP (0x4E71 in hex)
000017C2  6700 008E                946              BEQ     OPC_NOP                 * If equal branch to label to handle the opcode NOP
000017C6                           947              
000017C6                           948              * Check if the opcode is NOT
000017C6  E082                     949              ASR.L   #8, D2                  * Shift bits to compare
000017C8  B43C 0046                950              CMP.B   #%01000110, D2
000017CC  6700 0094                951              BEQ     OPC_NOT
000017D0  4282                     952              CLR.L   D2
000017D2                           953              
000017D2                           954              * Check if the opcode is LEA
000017D2  3838 11D6                955              MOVE.W   opcode, D4             * Put opcode in D4 to use the macro get bits
000017D6                           956m             GET_BITS #8, #6 
000017E6                           957m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000017EC                           958m             * GET HIGH BIT OFFSET
000017F2                           959m             * SHIFT OUT HIGH BITS
000017F8                           960m             *GET LOW BIT OFFSET
000017F8                           961m             *16 - NUMBER OF BITS WE WANT
000017FE                           962m             * SHIFT OUT LOW BITS
00001800  B83C 0007                963              CMP.B    #%111, D4              * if bits 8-6 are equal to 111, then the opocde is LEA
00001804  6700 00C4                964              BEQ      OPC_LEA
00001808                           965  
00001808                           966              * Check if the opcode is JSR
00001808  3838 11D6                967              MOVE.W   opcode, D4             * Put opcode in D4 to use the macro get bits
0000180C                           968m             GET_BITS #9, #7 
0000181C                           969m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001824                           970m             * GET HIGH BIT OFFSET
0000182C                           971m             * SHIFT OUT HIGH BITS
00001832                           972m             *GET LOW BIT OFFSET
00001832                           973m             *16 - NUMBER OF BITS WE WANT
00001838                           974m             * SHIFT OUT LOW BITS
0000183A  B83C 0005                975              CMP.B    #%101, D4              * if bits 9-7 are equal to 010, then the opocde is LEA
0000183E  6700 00D8                976              BEQ      OPC_JSR
00001842                           977  
00001842                           978              * Check if the opcode is RTS
00001842  B83C 0004                979              CMP.B    #%100, D4              
00001846  6700 0102                980              BEQ      OPC_RTS
0000184A                           981  
0000184A                           982              * Check if the opcode is MOVEM
0000184A  B83C 0001                983              CMP.B    #%001, D4              
0000184E  6700 010A                984              BEQ      OPC_MOVEM
00001852                           985  
00001852                           986  *---------------------------OPC_NOP--------------------------------
00001852                           987  
00001852                           988  OPC_NOP:
00001852                           989              * Put NOP into A1 buffer for printing
00001852  12FC 004E                990              MOVE.B  #'N',(A1)+      
00001856  12FC 004F                991              MOVE.B  #'O',(A1)+ 
0000185A  12FC 0050                992              MOVE.B  #'P',(A1)+ 
0000185E                           993              
0000185E  6000 FC86                994              BRA     IDENTIFY_OPCODE
00001862                           995  
00001862                           996  
00001862                           997  *-----------------------------OPC_NOT------------------------------
00001862                           998  
00001862                           999  OPC_NOT:
00001862                          1000              * Put NOT into A1 buffer for printing
00001862  12FC 004E               1001              MOVE.B  #'N',(A1)+ 
00001866  12FC 004F               1002              MOVE.B  #'O',(A1)+
0000186A  12FC 0054               1003              MOVE.B  #'T',(A1)+
0000186E                          1004m             INSERT_PERIOD
00001872                          1005              
00001872                          1006              * Calculate Size (.b,.w.l)
00001872                          1007m             GET_BITS        #7, #6
00001882                          1008m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001888                          1009m             * GET HIGH BIT OFFSET
0000188E                          1010m             * SHIFT OUT HIGH BITS
00001894                          1011m             *GET LOW BIT OFFSET
00001894                          1012m             *16 - NUMBER OF BITS WE WANT
0000189A                          1013m             * SHIFT OUT LOW BITS
0000189C  11C4 11D9               1014              MOVE.B          D4, opSize
000018A0                          1015m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000018A8                          1016m             DECODE_EA       #5, #0
000018C6  6000 FC1E               1017              BRA             IDENTIFY_OPCODE
000018CA                          1018  
000018CA                          1019  *-----------------------------OPC_LEA------------------------------
000018CA                          1020  OPC_LEA:
000018CA                          1021              * Put LEA into A1 buffer for printing
000018CA  12FC 004C               1022              MOVE.B  #'L',(A1)+      
000018CE  12FC 0045               1023              MOVE.B  #'E',(A1)+ 
000018D2  12FC 0041               1024              MOVE.B  #'A',(A1)+
000018D6                          1025m             INSERT_PERIOD
000018DA  12FC 004C               1026              MOVE.B  #'L',(A1)+ 
000018DE                          1027m             INSERT_SPACE
000018E2                          1028  
000018E2  11FC 0002 11D9          1029              MOVE.B          #2, opSize      * required to always be long operation
000018E8                          1030                      
000018E8                          1031m             DECODE_EA       #5, #0
00001906                          1032m             INSERT_COMMA
0000190A                          1033m             INSERT_SPACE
0000190E  4EB9 000020AA           1034              JSR GET_DATA_REG_NUM
00001914                          1035  
00001914  6000 FBD0               1036              BRA IDENTIFY_OPCODE    
00001918                          1037  
00001918                          1038  *-----------------------------OPC_JSR-----------------------------
00001918                          1039  OPC_JSR:
00001918                          1040              * Put LEA into A1 buffer for printing
00001918  12FC 004A               1041              MOVE.B  #'J',(A1)+      
0000191C  12FC 0053               1042              MOVE.B  #'S',(A1)+ 
00001920  12FC 0052               1043              MOVE.B  #'R',(A1)+
00001924                          1044m             INSERT_SPACE
00001928                          1045              
00001928                          1046m             DECODE_EA       #5, #0
00001946  6000 FB9E               1047              BRA             IDENTIFY_OPCODE  
0000194A                          1048  
0000194A                          1049  *-----------------------------OPC_RTS------------------------------
0000194A                          1050  OPC_RTS:
0000194A                          1051              * Put LEA into A1 buffer for printing
0000194A  12FC 0052               1052              MOVE.B  #'R',(A1)+      
0000194E  12FC 0054               1053              MOVE.B  #'T',(A1)+ 
00001952  12FC 0053               1054              MOVE.B  #'S',(A1)+
00001956                          1055          
00001956  6000 FB8E               1056              BRA IDENTIFY_OPCODE
0000195A                          1057  
0000195A                          1058  *-------------------------OPC_MOVEM--------------------------------
0000195A                          1059  OPC_MOVEM:
0000195A  12FC 004D               1060              MOVE.B  #'M',(A1)+      
0000195E  12FC 004F               1061              MOVE.B  #'O',(A1)+ 
00001962  12FC 0056               1062              MOVE.B  #'V',(A1)+
00001966  12FC 0045               1063              MOVE.B  #'E',(A1)+      
0000196A  12FC 004D               1064              MOVE.B  #'M',(A1)+ 
0000196E                          1065m             INSERT_PERIOD
00001972                          1066  
00001972  4EB9 000020EA           1067              JSR     DECODE_MOVEM
00001978  6000 FB6C               1068              BRA     IDENTIFY_OPCODE
0000197C                          1069  
0000197C                          1070  *------------------------------------------------------------------
0000197C                          1071  
0000197C                          1072  *---------------------------OPC_0111------------------------
0000197C                          1073  * First four bits = 0111
0000197C                          1074  * (MOVEQ)
0000197C                          1075  *-----------------------------------------------------------
0000197C                          1076  OPC_0111:
0000197C  12FC 004D               1077              MOVE.B  #'M',(A1)+      
00001980  12FC 004F               1078              MOVE.B  #'O',(A1)+ 
00001984  12FC 0056               1079              MOVE.B  #'V',(A1)+
00001988  12FC 0045               1080              MOVE.B  #'E',(A1)+      
0000198C  12FC 0051               1081              MOVE.B  #'Q',(A1)+ 
00001990                          1082m             INSERT_PERIOD
00001994  12FC 0042               1083              MOVE.B  #'B',(A1)+
00001998                          1084m             INSERT_SPACE
0000199C                          1085  
0000199C                          1086              * push immediate byte value to buffer
0000199C                          1087m             GET_BITS        #7, #0
000019AC                          1088m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019B4                          1089m             * GET HIGH BIT OFFSET
000019BA                          1090m             * SHIFT OUT HIGH BITS
000019C0                          1091m             *GET LOW BIT OFFSET
000019C0                          1092m             *16 - NUMBER OF BITS WE WANT
000019C6                          1093m             * SHIFT OUT LOW BITS
000019C8                          1094m             VALUE_TO_BUFFER D4 
000019D0                          1095  
000019D0                          1096m             INSERT_COMMA
000019D4                          1097m             INSERT_SPACE
000019D8                          1098  
000019D8                          1099              * push register to buffer
000019D8  12FC 0044               1100              MOVE.B          #'D',(A1)+
000019DC                          1101m             GET_BITS        #11, #9 
000019EC                          1102m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019F6                          1103m             * GET HIGH BIT OFFSET
000019FE                          1104m             * SHIFT OUT HIGH BITS
00001A04                          1105m             *GET LOW BIT OFFSET
00001A04                          1106m             *16 - NUMBER OF BITS WE WANT
00001A0A                          1107m             * SHIFT OUT LOW BITS
00001A0C                          1108m             VALUE_TO_BUFFER D4
00001A14                          1109  *-----------------------------------------------------------
00001A14                          1110  
00001A14                          1111  *---------------------------OPC_1000------------------------
00001A14                          1112   * First four bits = 1000
00001A14                          1113  * (DIVU)
00001A14                          1114  *-----------------------------------------------------------
00001A14                          1115  OPC_1000:   * keeping this in case there's more that start with 1000
00001A14  6000 0002               1116              BRA     OPC_DIVU
00001A18                          1117              
00001A18                          1118  OPC_DIVU:
00001A18  12FC 0044               1119              MOVE.B  #'D',(A1)+
00001A1C  12FC 0049               1120              MOVE.B  #'I',(A1)+
00001A20  12FC 0056               1121              MOVE.B  #'V',(A1)+
00001A24  12FC 0055               1122              MOVE.B  #'U',(A1)+
00001A28                          1123m             INSERT_PERIOD
00001A2C  12FC 0057               1124              MOVE.B  #'W',(A1)+  * always size word
00001A30                          1125m             INSERT_SPACE
00001A34                          1126  
00001A34  11FC 0001 11D9          1127              MOVE.B  #1, opSize
00001A3A  4EF9 00002072           1128              JMP     EA_TO_D
00001A40                          1129  
00001A40                          1130  *-----------------------------------------------------------
00001A40                          1131  
00001A40                          1132  
00001A40                          1133  
00001A40                          1134  *-----------------------OPC_0101----------------------------
00001A40                          1135  * First four bits = 0101
00001A40                          1136  * (ADDQ, SUBQ)
00001A40                          1137  *-----------------------------------------------------------
00001A40                          1138  OPC_0101:
00001A40                          1139m             GET_BITS  #8, #8
00001A50                          1140m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001A56                          1141m             * GET HIGH BIT OFFSET
00001A5C                          1142m             * SHIFT OUT HIGH BITS
00001A62                          1143m             *GET LOW BIT OFFSET
00001A62                          1144m             *16 - NUMBER OF BITS WE WANT
00001A68                          1145m             * SHIFT OUT LOW BITS
00001A6A                          1146              
00001A6A                          1147              * is the opcode ADDQ?
00001A6A  B83C 0000               1148              CMP.B     #%0000, D4
00001A6E  6700 000E               1149              BEQ       OPC_ADDQ
00001A72                          1150  
00001A72                          1151              * is the opcode SUBI?
00001A72  B83C 0001               1152              CMP.B     #%0001, D4
00001A76  6700 001E               1153              BEQ       OPC_SUBQ
00001A7A                          1154  
00001A7A  4EF8 15D4               1155              JMP       BAD_OPCODE
00001A7E                          1156  
00001A7E                          1157  *------------------------OPC_ADDQ---------------------------
00001A7E                          1158  OPC_ADDQ:
00001A7E  12FC 0041               1159              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001A82  12FC 0044               1160              MOVE.B  #'D',(A1)+
00001A86  12FC 0044               1161              MOVE.B  #'D',(A1)+
00001A8A  12FC 0051               1162              MOVE.B  #'Q',(A1)+
00001A8E                          1163m             INSERT_PERIOD
00001A92                          1164  
00001A92  6100 001A               1165              BSR     DECODE_QUICK
00001A96                          1166  
00001A96                          1167  *------------------------OPC_SUBI---------------------------
00001A96                          1168  OPC_SUBQ:            
00001A96  12FC 0053               1169              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001A9A  12FC 0055               1170              MOVE.B  #'U',(A1)+
00001A9E  12FC 0042               1171              MOVE.B  #'B',(A1)+
00001AA2  12FC 0051               1172              MOVE.B  #'Q',(A1)+
00001AA6                          1173m             INSERT_PERIOD
00001AAA                          1174  
00001AAA  6100 0002               1175              BSR     DECODE_QUICK
00001AAE                          1176  
00001AAE                          1177  *------------------Subroutines for OPC_0101-----------------
00001AAE                          1178  DECODE_QUICK:            
00001AAE                          1179              * Get size of operation and push to buffer
00001AAE  4284                    1180              CLR.L           D4
00001AB0                          1181m             GET_BITS        #7, #6
00001AC0                          1182m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001AC6                          1183m             * GET HIGH BIT OFFSET
00001ACC                          1184m             * SHIFT OUT HIGH BITS
00001AD2                          1185m             *GET LOW BIT OFFSET
00001AD2                          1186m             *16 - NUMBER OF BITS WE WANT
00001AD8                          1187m             * SHIFT OUT LOW BITS
00001ADA  11C4 11D9               1188              MOVE.B          D4, opSize
00001ADE                          1189m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001AE6                          1190  
00001AE6                          1191              * push value of #<data> to buffer
00001AE6  4284                    1192              CLR.L            D4
00001AE8                          1193m             GET_BITS         #11, #9
00001AF8                          1194m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B02                          1195m             * GET HIGH BIT OFFSET
00001B0A                          1196m             * SHIFT OUT HIGH BITS
00001B10                          1197m             *GET LOW BIT OFFSET
00001B10                          1198m             *16 - NUMBER OF BITS WE WANT
00001B16                          1199m             * SHIFT OUT LOW BITS
00001B18                          1200m             INSERT_POUND
00001B1C                          1201m             VALUE_TO_BUFFER  D4
00001B24                          1202  
00001B24                          1203m             INSERT_COMMA
00001B28                          1204m             INSERT_SPACE
00001B2C                          1205  
00001B2C                          1206              * push <ea> to buffer
00001B2C                          1207m             DECODE_EA       #5, #0
00001B4A  6000 F99A               1208              BRA             IDENTIFY_OPCODE
00001B4E                          1209  *-----------------------------------------------------------
00001B4E                          1210  
00001B4E                          1211  
00001B4E                          1212  *-----------------------OPC_0110----------------------------
00001B4E                          1213  * First four bits = 0110
00001B4E                          1214  * BRA or Bcc condtions
00001B4E                          1215  *-----------------------------------------------------------
00001B4E                          1216  OPC_0110:
00001B4E                          1217m             GET_BITS #12, #8
00001B5E                          1218m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B66                          1219m             * GET HIGH BIT OFFSET
00001B6E                          1220m             * SHIFT OUT HIGH BITS
00001B74                          1221m             *GET LOW BIT OFFSET
00001B74                          1222m             *16 - NUMBER OF BITS WE WANT
00001B7A                          1223m             * SHIFT OUT LOW BITS
00001B7C  B83C 0000               1224              CMP.B   #0,D4 *Check if opcode is BRA
00001B80  6700 00DE               1225              BEQ     OPC_BRA
00001B84                          1226              
00001B84                          1227m             GET_BITS #11, #8 *Check if opcode is a Bcc condition
00001B94                          1228m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B9C                          1229m             * GET HIGH BIT OFFSET
00001BA4                          1230m             * SHIFT OUT HIGH BITS
00001BAA                          1231m             *GET LOW BIT OFFSET
00001BAA                          1232m             *16 - NUMBER OF BITS WE WANT
00001BB0                          1233m             * SHIFT OUT LOW BITS
00001BB2                          1234              
00001BB2  B83C 000D               1235              CMP.B   #%1101, D4 *Check if opcode is BLT
00001BB6  6700 0016               1236              BEQ     BLT
00001BBA                          1237              
00001BBA  B83C 000C               1238              CMP.B   #%1100, D4 *Check if opcode is BGE
00001BBE  6700 0022               1239              BEQ     BGE
00001BC2                          1240              
00001BC2  B83C 0007               1241              CMP.B   #%0111, D4 *Check if opcode is BEQ
00001BC6  6700 002E               1242              BEQ     BEQ
00001BCA                          1243              
00001BCA  4EF8 15D4               1244              JMP     BAD_OPCODE *If no match if found, we have an error
00001BCE                          1245              
00001BCE                          1246  BLT:
00001BCE  12FC 0042               1247              MOVE.B  #'B',(A1)+          * Put BLT into Buff
00001BD2  12FC 004C               1248              MOVE.B  #'L',(A1)+
00001BD6  12FC 0054               1249              MOVE.B  #'T',(A1)+
00001BDA  12FC 002E               1250              MOVE.B  #'.',(A1)+
00001BDE  6000 002A               1251              BRA     BCC_DISPLACEMENT
00001BE2                          1252  
00001BE2                          1253  BGE:
00001BE2  12FC 0042               1254              MOVE.B  #'B',(A1)+          * Put BGE into Buff
00001BE6  12FC 0047               1255              MOVE.B  #'G',(A1)+
00001BEA  12FC 0045               1256              MOVE.B  #'E',(A1)+
00001BEE  12FC 002E               1257              MOVE.B  #'.',(A1)+
00001BF2  6000 0016               1258              BRA     BCC_DISPLACEMENT
00001BF6                          1259  
00001BF6                          1260  BEQ:
00001BF6  12FC 0042               1261              MOVE.B  #'B',(A1)+          * Put BEQ into Buff
00001BFA  12FC 0045               1262              MOVE.B  #'E',(A1)+
00001BFE  12FC 0051               1263              MOVE.B  #'Q',(A1)+
00001C02  12FC 002E               1264              MOVE.B  #'.',(A1)+
00001C06  6000 0002               1265              BRA     BCC_DISPLACEMENT
00001C0A                          1266  
00001C0A                          1267  BCC_DISPLACEMENT:
00001C0A                          1268m             GET_BITS #7,#0 *Get displacement bits
00001C1A                          1269m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001C22                          1270m             * GET HIGH BIT OFFSET
00001C28                          1271m             * SHIFT OUT HIGH BITS
00001C2E                          1272m             *GET LOW BIT OFFSET
00001C2E                          1273m             *16 - NUMBER OF BITS WE WANT
00001C34                          1274m             * SHIFT OUT LOW BITS
00001C36                          1275              
00001C36  B83C 0000               1276              CMP.B   #0,D4 *Check if we have 16 bit dispalcement, branch if true
00001C3A  6700 008A               1277              BEQ     SIXTEEN_BIT_DISPLACEMENT
00001C3E                          1278              
00001C3E  12FC 0042               1279              MOVE.B  #'B',(A1)+
00001C42                          1280m             INSERT_SPACE 
00001C46  12FC 0024               1281              MOVE.B  #'$',(A1)+
00001C4A                          1282              
00001C4A  2E0A                    1283              MOVE.L  A2,D7  *Get the current address
00001C4C                          1284              
00001C4C  4884                    1285              EXT.W   D4 *Sign extend to long for addition
00001C4E  48C4                    1286              EXT.L   D4 *Sign extend again, must extend from byte to word and then word to long
00001C50  DE84                    1287              ADD.L   D4,D7  *Add the displacement
00001C52                          1288  
00001C52  123C 0003               1289              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001C56  4EB9 000023EC           1290              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001C5C                          1291              
00001C5C  6000 F888               1292              BRA IDENTIFY_OPCODE   
00001C60                          1293                         
00001C60                          1294  OPC_BRA:
00001C60  12FC 0042               1295              MOVE.B  #'B',(A1)+          * Put BRA into Buff
00001C64  12FC 0052               1296              MOVE.B  #'R',(A1)+
00001C68  12FC 0041               1297              MOVE.B  #'A',(A1)+
00001C6C  12FC 002E               1298              MOVE.B  #'.',(A1)+
00001C70                          1299              
00001C70                          1300m             GET_BITS #7,#0 *Get displacement bits
00001C80                          1301m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001C88                          1302m             * GET HIGH BIT OFFSET
00001C8E                          1303m             * SHIFT OUT HIGH BITS
00001C94                          1304m             *GET LOW BIT OFFSET
00001C94                          1305m             *16 - NUMBER OF BITS WE WANT
00001C9A                          1306m             * SHIFT OUT LOW BITS
00001C9C                          1307              
00001C9C  B83C 0000               1308              CMP.B   #0,D4 *Check if we have 16 bit dispalcement, branch if true
00001CA0  6700 0024               1309              BEQ     SIXTEEN_BIT_DISPLACEMENT
00001CA4                          1310             
00001CA4  12FC 0042               1311              MOVE.B  #'B',(A1)+
00001CA8                          1312m             INSERT_SPACE 
00001CAC  12FC 0024               1313              MOVE.B  #'$',(A1)+
00001CB0                          1314              
00001CB0  2E0A                    1315              MOVE.L  A2,D7  *Get the current address
00001CB2                          1316              
00001CB2  4884                    1317              EXT.W   D4 *Sign extend to long for addition
00001CB4  48C4                    1318              EXT.L   D4 *Sign extend again, must extend from byte to word and then word to long
00001CB6  DE84                    1319              ADD.L   D4,D7  *Add the displacement
00001CB8                          1320  
00001CB8  123C 0003               1321              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001CBC  4EB9 000023EC           1322              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001CC2                          1323              
00001CC2  6000 F822               1324              BRA IDENTIFY_OPCODE   
00001CC6                          1325              
00001CC6                          1326  SIXTEEN_BIT_DISPLACEMENT: 
00001CC6  12FC 0057               1327              MOVE.B  #'W',(A1)+
00001CCA                          1328m             INSERT_SPACE 
00001CCE  12FC 0024               1329              MOVE.B  #'$',(A1)+
00001CD2                          1330              
00001CD2  2E0A                    1331              MOVE.L  A2,D7  *Get the current address
00001CD4                          1332              
00001CD4  4284                    1333              CLR.L D4 *Clear the contents of D4
00001CD6  381A                    1334              MOVE.W  (A2)+,D4 *Increment A2 to get 16 bit displacement value
00001CD8                          1335              
00001CD8  48C4                    1336              EXT.L   D4  *Sign extend to long for addition
00001CDA  DE84                    1337              ADD.L   D4,D7  *Add the displacement 
00001CDC                          1338                        
00001CDC  123C 0003               1339              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001CE0  4EB9 000023EC           1340              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001CE6                          1341              
00001CE6  6000 F7FE               1342              BRA     IDENTIFY_OPCODE 
00001CEA                          1343              
00001CEA                          1344  
00001CEA                          1345  *-----------------------OPC_1001----------------------------
00001CEA                          1346  * First four bits = 1001
00001CEA                          1347  * (SUB)
00001CEA                          1348  *-----------------------------------------------------------
00001CEA                          1349  OPC_1001:
00001CEA                          1350              * fill in A1 register
00001CEA  12FC 0053               1351              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001CEE  12FC 0055               1352              MOVE.B  #'U',(A1)+
00001CF2  12FC 0042               1353              MOVE.B  #'B',(A1)+
00001CF6                          1354m             INSERT_PERIOD
00001CFA  6000 02D6               1355              BRA     PROCESS_ROEA
00001CFE                          1356  *-----------------------------------------------------------
00001CFE                          1357  
00001CFE                          1358  
00001CFE                          1359  
00001CFE                          1360  *-----------------------OPC_1100----------------------------
00001CFE                          1361  * First four bits = 1100
00001CFE                          1362  * (AND, MULS)
00001CFE                          1363  *-----------------------------------------------------------
00001CFE                          1364  OPC_1100:   
00001CFE                          1365              ; check to see if bits 8-6 are 111
00001CFE                          1366              ; if they are, then branch to PARSE_MULS
00001CFE                          1367              ; else, keep going to parse AND
00001CFE                          1368  
00001CFE                          1369m             GET_BITS #8, #6
00001D0E                          1370m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001D14                          1371m             * GET HIGH BIT OFFSET
00001D1A                          1372m             * SHIFT OUT HIGH BITS
00001D20                          1373m             *GET LOW BIT OFFSET
00001D20                          1374m             *16 - NUMBER OF BITS WE WANT
00001D26                          1375m             * SHIFT OUT LOW BITS
00001D28  B83C 0007               1376              CMP.B    #%00000111, D4
00001D2C  6700 001A               1377              BEQ      OPC_MULS
00001D30  6600 0002               1378              BNE      OPC_AND
00001D34                          1379  
00001D34                          1380  *---------------------------OPC_AND------------------------
00001D34                          1381  OPC_AND:    ; AND opcode subroutine
00001D34                          1382  
00001D34                          1383              ;-----------------------------
00001D34                          1384              ; fill A1 with the opcode name
00001D34  12FC 0041               1385              MOVE.B  #'A',(A1)+
00001D38  12FC 004E               1386              MOVE.B  #'N',(A1)+
00001D3C  12FC 0044               1387              MOVE.B  #'D',(A1)+
00001D40                          1388m             INSERT_PERIOD
00001D44  6000 028C               1389              BRA     PROCESS_ROEA
00001D48                          1390  
00001D48                          1391  *---------------------------OPC_MULS------------------------
00001D48                          1392  OPC_MULS:  * MULS opcode subroutine
00001D48                          1393  
00001D48                          1394              * load the command name into the output
00001D48  12FC 004D               1395              MOVE.B  #'M',(A1)+
00001D4C  12FC 0055               1396              MOVE.B  #'U',(A1)+
00001D50  12FC 004C               1397              MOVE.B  #'L',(A1)+
00001D54  12FC 0053               1398              MOVE.B  #'S',(A1)+
00001D58                          1399m             INSERT_PERIOD
00001D5C  12FC 0057               1400              MOVE.B  #'W',(A1)+ * always size word
00001D60                          1401m             INSERT_SPACE
00001D64                          1402  
00001D64  11FC 0001 11D9          1403              MOVE.B   #1, opSize
00001D6A                          1404              
00001D6A  11FC 00BF 11DA          1405              MOVE.B  #%10111111, valid   * set the valid mode bits (to be used later)
00001D70                          1406              
00001D70  4EF9 00002072           1407              JMP     EA_TO_D
00001D76                          1408  *-----------------------------------------------------------
00001D76                          1409  
00001D76                          1410  
00001D76                          1411  *---------------------------opc_1101------------------------
00001D76                          1412  * First four bits = 1101
00001D76                          1413  * (ADD)
00001D76                          1414  *-----------------------------------------------------------
00001D76                          1415  OPC_1101:
00001D76                          1416              * fill in A1 register
00001D76  12FC 0041               1417              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001D7A  12FC 0044               1418              MOVE.B  #'D',(A1)+
00001D7E  12FC 0044               1419              MOVE.B  #'D',(A1)+
00001D82                          1420m             INSERT_PERIOD
00001D86  6000 024A               1421              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
00001D8A                          1422  
00001D8A                          1423  *-----------------------------------------------------------
00001D8A                          1424              
00001D8A                          1425  *---------------------------opc_1110------------------------
00001D8A                          1426  * First four bits = 1110
00001D8A                          1427  * (LSL, LSR, ASL, ASR)
00001D8A                          1428  *-----------------------------------------------------------
00001D8A                          1429  OPC_1110:
00001D8A  11FC 003E 11DA          1430              MOVE.B  #%00111110, valid ; valid bits are the same for all shifts
00001D90                          1431              
00001D90                          1432              ; check for LSL/LSR vs ASL/ASR
00001D90                          1433m             GET_BITS #4,#3
00001DA0                          1434m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001DA6                          1435m             * GET HIGH BIT OFFSET
00001DAC                          1436m             * SHIFT OUT HIGH BITS
00001DB2                          1437m             *GET LOW BIT OFFSET
00001DB2                          1438m             *16 - NUMBER OF BITS WE WANT
00001DB8                          1439m             * SHIFT OUT LOW BITS
00001DBA  B83C 0000               1440              CMP.B   #0,D4
00001DBE  6700 0006               1441              BEQ     A_SHIFT     ; if bits 4-3 are 00, ASL/ASR
00001DC2  6000 0040               1442              BRA     L_SHIFT     ; if bits 4-3 are 01, LSL/LSR
00001DC6                          1443  
00001DC6                          1444  ;======================================================
00001DC6                          1445  ; getting the opcode name
00001DC6                          1446  A_SHIFT:
00001DC6  12FC 0041               1447              MOVE.B  #'A',(A1)+
00001DCA  12FC 0053               1448              MOVE.B  #'S',(A1)+ 
00001DCE                          1449m             GET_BITS #8,#8      ; check for shifting left or right
00001DDE                          1450m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001DE4                          1451m             * GET HIGH BIT OFFSET
00001DEA                          1452m             * SHIFT OUT HIGH BITS
00001DF0                          1453m             *GET LOW BIT OFFSET
00001DF0                          1454m             *16 - NUMBER OF BITS WE WANT
00001DF6                          1455m             * SHIFT OUT LOW BITS
00001DF8  B83C 0001               1456              CMP.B   #01,D4
00001DFC  6700 0044               1457              BEQ     L_TO_BUFF
00001E00  6000 004C               1458              BRA     R_TO_BUFF
00001E04                          1459              
00001E04                          1460  L_SHIFT:
00001E04  12FC 004C               1461              MOVE.B  #'L',(A1)+
00001E08  12FC 0053               1462              MOVE.B  #'S',(A1)+
00001E0C                          1463m             GET_BITS #8,#8      ; check for shifting left or right
00001E1C                          1464m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001E22                          1465m             * GET HIGH BIT OFFSET
00001E28                          1466m             * SHIFT OUT HIGH BITS
00001E2E                          1467m             *GET LOW BIT OFFSET
00001E2E                          1468m             *16 - NUMBER OF BITS WE WANT
00001E34                          1469m             * SHIFT OUT LOW BITS
00001E36  B83C 0001               1470              CMP.B   #01,D4
00001E3A  6700 0006               1471              BEQ     L_TO_BUFF
00001E3E  6000 000E               1472              BRA     R_TO_BUFF
00001E42                          1473              
00001E42                          1474              
00001E42                          1475  L_TO_BUFF:
00001E42  12FC 004C               1476              MOVE.B  #'L',(A1)+
00001E46  12FC 002E               1477              MOVE.B  #'.',(A1)+
00001E4A                          1478              
00001E4A  6000 000E               1479              BRA     SHIFT_MODES
00001E4E                          1480  
00001E4E                          1481  
00001E4E                          1482  R_TO_BUFF:
00001E4E  12FC 0052               1483              MOVE.B  #'R',(A1)+
00001E52  12FC 002E               1484              MOVE.B  #'.',(A1)+
00001E56                          1485  
00001E56  6000 0002               1486              BRA     SHIFT_MODES
00001E5A                          1487  
00001E5A                          1488  
00001E5A                          1489  ;======================================================
00001E5A                          1490  ; determining which mode to use
00001E5A                          1491  SHIFT_MODES:
00001E5A                          1492m             GET_BITS #7,#6
00001E6A                          1493m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001E70                          1494m             * GET HIGH BIT OFFSET
00001E76                          1495m             * SHIFT OUT HIGH BITS
00001E7C                          1496m             *GET LOW BIT OFFSET
00001E7C                          1497m             *16 - NUMBER OF BITS WE WANT
00001E82                          1498m             * SHIFT OUT LOW BITS
00001E84  B83C 0003               1499              CMP.B   #3,D4
00001E88  6600 0006               1500              BNE     SHIFT_REG_OR_IMM    ; jump to register/immediate mode if the bits aren't #%11
00001E8C  6000 011A               1501              BRA     SHIFT_MEM_MODE      ; otherwise, jump to memory mode if the bits are #%11
00001E90                          1502  
00001E90                          1503  
00001E90                          1504  SHIFT_REG_OR_IMM: ; register and immediate shifts
00001E90                          1505              
00001E90                          1506              ; get the size
00001E90                          1507m             SIZE_TO_BUFFER D4
00001E98                          1508              
00001E98                          1509              
00001E98                          1510              ; get the i/r bit to determine immediate/register
00001E98                          1511m             GET_BITS #5,#5
00001EA8                          1512m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001EAE                          1513m             * GET HIGH BIT OFFSET
00001EB4                          1514m             * SHIFT OUT HIGH BITS
00001EBA                          1515m             *GET LOW BIT OFFSET
00001EBA                          1516m             *16 - NUMBER OF BITS WE WANT
00001EC0                          1517m             * SHIFT OUT LOW BITS
00001EC2                          1518              ; if i/r is 0, it's an immediate shift
00001EC2                          1519              ; if i/r is 1, it's a register shift
00001EC2  B83C 0000               1520              CMP.B   #0,D4
00001EC6  6700 0006               1521              BEQ     SHIFT_IMMEDIATE_MODE
00001ECA  6000 005E               1522              BRA     SHIFT_REGISTER_MODE
00001ECE                          1523              
00001ECE                          1524  
00001ECE                          1525  ;======================================================
00001ECE                          1526  ; shifting modes (immediate data, from a register, from memory)
00001ECE                          1527  SHIFT_IMMEDIATE_MODE:
00001ECE  12FC 0023               1528              MOVE.B  #'#',(A1)+
00001ED2                          1529              
00001ED2  4EB9 00001EE4           1530              JSR     SHIFT_COUNT
00001ED8                          1531              
00001ED8  12FC 002C               1532              MOVE.B  #',',(A1)+
00001EDC  12FC 0020               1533              MOVE.B  #' ',(A1)+
00001EE0                          1534              
00001EE0  6000 0088               1535              BRA     SHIFT_DEST_REG   ; get the destination register
00001EE4                          1536  
00001EE4                          1537  SHIFT_COUNT: ; moves the size to the buffer
00001EE4                          1538m             GET_BITS #11,#9
00001EF4                          1539m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001EFE                          1540m             * GET HIGH BIT OFFSET
00001F06                          1541m             * SHIFT OUT HIGH BITS
00001F0C                          1542m             *GET LOW BIT OFFSET
00001F0C                          1543m             *16 - NUMBER OF BITS WE WANT
00001F12                          1544m             * SHIFT OUT LOW BITS
00001F14                          1545              
00001F14  B83C 0000               1546              CMP.B   #0,D4   ; shift bits = 0, shifting 8 bits
00001F18  6700 000A               1547              BEQ     EIGHT_TO_BUFF
00001F1C                          1548              
00001F1C  0604 0030               1549              ADD.B   #$30,D4
00001F20  12C4                    1550              MOVE.B  D4,(A1)+
00001F22  4E75                    1551              RTS
00001F24                          1552              
00001F24                          1553  EIGHT_TO_BUFF:
00001F24  12FC 0038               1554              MOVE.B  #'8',(A1)+
00001F28  4E75                    1555              RTS
00001F2A                          1556              
00001F2A                          1557              
00001F2A                          1558  SHIFT_REGISTER_MODE:
00001F2A  12FC 0044               1559              MOVE.B  #'D',(A1)+
00001F2E                          1560              
00001F2E                          1561m             GET_BITS #7, #6
00001F3E                          1562m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001F44                          1563m             * GET HIGH BIT OFFSET
00001F4A                          1564m             * SHIFT OUT HIGH BITS
00001F50                          1565m             *GET LOW BIT OFFSET
00001F50                          1566m             *16 - NUMBER OF BITS WE WANT
00001F56                          1567m             * SHIFT OUT LOW BITS
00001F58                          1568              
00001F58  0604 0030               1569              ADD.B   #$30,D4         ; push the register to the buffer
00001F5C  12C4                    1570              MOVE.B  D4,(A1)+
00001F5E  12FC 002C               1571              MOVE.B  #',',(A1)+
00001F62  12FC 0020               1572              MOVE.B  #' ',(A1)+
00001F66                          1573              
00001F66  6000 0002               1574              BRA     SHIFT_DEST_REG   ; get the destination register
00001F6A                          1575  
00001F6A                          1576  SHIFT_DEST_REG:
00001F6A  12FC 0044               1577              MOVE.B  #'D',(A1)+
00001F6E                          1578m             GET_BITS #2,#0
00001F7E                          1579m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001F86                          1580m             * GET HIGH BIT OFFSET
00001F8C                          1581m             * SHIFT OUT HIGH BITS
00001F92                          1582m             *GET LOW BIT OFFSET
00001F92                          1583m             *16 - NUMBER OF BITS WE WANT
00001F98                          1584m             * SHIFT OUT LOW BITS
00001F9A                          1585              ; add 30 to the register bits
00001F9A  0604 0030               1586              ADD.B   #$30,D4
00001F9E  12C4                    1587              MOVE.B  D4,(A1)+
00001FA0                          1588              
00001FA0  12FC 0000               1589              MOVE.B  #0,(A1)+        ; add the null terminator
00001FA4                          1590              
00001FA4  6000 F540               1591              BRA     IDENTIFY_OPCODE
00001FA8                          1592              
00001FA8                          1593              
00001FA8                          1594  SHIFT_MEM_MODE: ; memory shifts
00001FA8  12FC 0057               1595              MOVE.B  #'W',(A1)+      ; always word sized
00001FAC  12FC 0020               1596              MOVE.B  #' ',(A1)+
00001FB0                          1597              
00001FB0                          1598m             DECODE_EA #5, #0
00001FCE  6000 F516               1599              BRA     IDENTIFY_OPCODE
00001FD2                          1600  
00001FD2                          1601  
00001FD2                          1602  *--------------Process Register->Opmode->EA-----------------
00001FD2                          1603  * Description:
00001FD2                          1604  * Parses bits for opcodes that share bit placements:
00001FD2                          1605  * ROEA stands for Register, Opmode, and Effective Address,
00001FD2                          1606  * because the opcodes below share this bit order.
00001FD2                          1607  *
00001FD2                          1608  * Used by: (ADD, SUB, MULS)
00001FD2                          1609  *
00001FD2                          1610  *-----------------------------------------------------------
00001FD2                          1611  PROCESS_ROEA:
00001FD2                          1612m             GET_BITS        #7, #6              * retrieve size
00001FE2                          1613m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001FE8                          1614m             * GET HIGH BIT OFFSET
00001FEE                          1615m             * SHIFT OUT HIGH BITS
00001FF4                          1616m             *GET LOW BIT OFFSET
00001FF4                          1617m             *16 - NUMBER OF BITS WE WANT
00001FFA                          1618m             * SHIFT OUT LOW BITS
00001FFC  11C4 11D9               1619              MOVE.B          D4, opSize
00002000                          1620m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00002008                          1621  
00002008                          1622m             GET_BITS        #8, #8              * retrieve type  
00002018                          1623m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000201E                          1624m             * GET HIGH BIT OFFSET
00002024                          1625m             * SHIFT OUT HIGH BITS
0000202A                          1626m             *GET LOW BIT OFFSET
0000202A                          1627m             *16 - NUMBER OF BITS WE WANT
00002030                          1628m             * SHIFT OUT LOW BITS
00002032  B83C 0001               1629              CMP.B           #1, D4              * is this Dn + <ea> -> <ea>?
00002036  6700 000A               1630              BEQ             D_TO_EA
0000203A  B83C 0000               1631              CMP.B           #0, D4              * is this <ea> + Dn -> <ea>?
0000203E  6700 0032               1632              BEQ             EA_TO_D
00002042                          1633  
00002042                          1634  D_TO_EA:
00002042  4EB9 000020AA           1635              JSR             GET_DATA_REG_NUM
00002048                          1636m             INSERT_COMMA
0000204C                          1637m             INSERT_SPACE
00002050                          1638m             DECODE_EA       #5, #0
0000206E  6000 0032               1639              BRA             ROEA_DONE
00002072                          1640  
00002072                          1641  EA_TO_D:
00002072                          1642m             DECODE_EA       #5, #0
00002090                          1643m             INSERT_COMMA
00002094                          1644m             INSERT_SPACE
00002098  4EB9 000020AA           1645              JSR             GET_DATA_REG_NUM
0000209E  6000 0002               1646              BRA             ROEA_DONE
000020A2                          1647  
000020A2                          1648  ROEA_DONE:
000020A2                          1649m             INSERT_SPACE
000020A6  6000 F43E               1650              BRA     IDENTIFY_OPCODE
000020AA                          1651  
000020AA                          1652  GET_DATA_REG_NUM:
000020AA  4284                    1653              CLR.L    D4
000020AC                          1654m             GET_BITS #11, #9                     * retrieve high data register number
000020BC                          1655m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000020C6                          1656m             * GET HIGH BIT OFFSET
000020CE                          1657m             * SHIFT OUT HIGH BITS
000020D4                          1658m             *GET LOW BIT OFFSET
000020D4                          1659m             *16 - NUMBER OF BITS WE WANT
000020DA                          1660m             * SHIFT OUT LOW BITS
000020DC                          1661  
000020DC                          1662              * store in appropriate register
000020DC  12FC 0044               1663              MOVE.B            #'D',(A1)+                  * add "D" to buffer
000020E0                          1664m             VALUE_TO_BUFFER   D4          
000020E8  4E75                    1665              RTS
000020EA                          1666  *-----------------------------------------------------------
000020EA                          1667  
000020EA                          1668  
000020EA                          1669  
000020EA                          1670  
000020EA                          1671  
000020EA                          1672  
000020EA                          1673  
000020EA                          1674  
000020EA                          1675  
000020EA                          1676  
000020EA                          1677  
000020EA                          1678  *----------------------DECODE_MOVEM-------------------------
000020EA                          1679  * Description:
000020EA                          1680  * Parses bits for MOVEM 
000020EA                          1681  *
000020EA                          1682  * Parameters:
000020EA                          1683  *   None
000020EA                          1684  *
000020EA                          1685  * Registers Used:
000020EA                          1686  *   D1 = holds next word from memory (word represents register list mask)
000020EA                          1687  *   D2 = temp variable to hold iteration values in LOOP_LIST
000020EA                          1688  *   D3 = determines if we are currrently parsing data regs or address regs
000020EA                          1689  *   D4 = holds returned value from GET_BITS
000020EA                          1690  *   D5 = holds dr field (direction of transfer)
000020EA                          1691  *   D7 = temp data
000020EA                          1692  *-----------------------------------------------------------
000020EA                          1693  DECODE_MOVEM:
000020EA                          1694m             CLR_D_REGS
000020FA                          1695  
000020FA  6100 0016               1696              BSR       MOVEM_SIZE
000020FE  6100 006E               1697              BSR       MOVEM_BR
00002102                          1698  
00002102  BA3C 0000               1699              CMP.B     #0, D5            * register -> memory
00002106  6700 009A               1700              BEQ       REG_TO_MEM
0000210A  BA3C 0001               1701              CMP.B     #1, D5            * memory -> register
0000210E  6700 00D0               1702              BEQ       MEM_TO_REG
00002112                          1703  
00002112                          1704  *-----------------------------------------------------------
00002112                          1705  MOVEM_SIZE:
00002112                          1706              * move size of operation to opSize
00002112                          1707m             GET_BITS  #6, #6
00002122                          1708m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00002128                          1709m             * GET HIGH BIT OFFSET
0000212E                          1710m             * SHIFT OUT HIGH BITS
00002134                          1711m             *GET LOW BIT OFFSET
00002134                          1712m             *16 - NUMBER OF BITS WE WANT
0000213A                          1713m             * SHIFT OUT LOW BITS
0000213C                          1714  
0000213C  B83C 0000               1715              CMP.B     #0, D4
00002140  6700 000A               1716              BEQ       MOVEM_PUSH_WORD
00002144                          1717  
00002144  B83C 0001               1718              CMP.B     #1, D4
00002148  6700 000A               1719              BEQ       MOVEM_PUSH_LONG
0000214C                          1720  
0000214C                          1721  MOVEM_PUSH_WORD:
0000214C  183C 0001               1722              MOVE.B    #1, D4
00002150  6000 000A               1723              BRA       MOVEM_SIZE_DONE
00002154                          1724  
00002154                          1725  MOVEM_PUSH_LONG:
00002154  183C 0002               1726              MOVE.B    #2, D4
00002158  6000 0002               1727              BRA       MOVEM_SIZE_DONE
0000215C                          1728  
0000215C                          1729  MOVEM_SIZE_DONE:
0000215C  11C4 11D9               1730              MOVE.B          D4, opSize
00002160                          1731m             SIZE_TO_BUFFER  D4
00002168                          1732m             INSERT_SPACE
0000216C  4E75                    1733              RTS
0000216E                          1734  *-----------------------------------------------------------
0000216E                          1735  MOVEM_BR:
0000216E                          1736              * move dr of operation to D5
0000216E                          1737m             GET_BITS  #10, #10
0000217E                          1738m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00002188                          1739m             * GET HIGH BIT OFFSET
00002190                          1740m             * SHIFT OUT HIGH BITS
00002196                          1741m             *GET LOW BIT OFFSET
00002196                          1742m             *16 - NUMBER OF BITS WE WANT
0000219C                          1743m             * SHIFT OUT LOW BITS
0000219E  1A04                    1744              MOVE.B    D4, D5
000021A0  4E75                    1745              RTS
000021A2                          1746  *-----------------------------------------------------------
000021A2                          1747  REG_TO_MEM:
000021A2  6100 007C               1748              BSR       REGS_TO_MEM
000021A6                          1749m             CLR_D_REGS
000021B6                          1750m             INSERT_COMMA
000021BA                          1751m             INSERT_SPACE
000021BE                          1752m             DECODE_EA #5, #0
000021DC  6000 0040               1753              BRA       DONE_MOVEM
000021E0                          1754  
000021E0                          1755  MEM_TO_REG:
000021E0                          1756m             DECODE_EA #5, #0
000021FE                          1757m             CLR_D_REGS
0000220E                          1758m             INSERT_COMMA
00002212                          1759m             INSERT_SPACE
00002216  6100 0008               1760              BSR       REGS_TO_MEM
0000221A  6000 0002               1761              BRA       DONE_MOVEM
0000221E                          1762  
0000221E                          1763  DONE_MOVEM:
0000221E  4E75                    1764              RTS
00002220                          1765  *-----------------------------------------------------------
00002220                          1766  REGS_TO_MEM:
00002220                          1767              * bring in the next word from memory, which represents the register list mask
00002220  31DA 11DE               1768              MOVE.W    (A2)+, list_mask
00002224                          1769  
00002224                          1770              * load registers with appropriate memory
00002224  6100 0018               1771              BSR       LOAD_REGISTERS
00002228  7600                    1772              MOVE.L    #0, D3
0000222A  6100 0026               1773              BSR       FIND_HIGH_TO_LOW_BITS   
0000222E                          1774  
0000222E                          1775              * find address registers   
0000222E  6100 000E               1776              BSR       LOAD_REGISTERS
00002232  7601                    1777              MOVE.L    #1, D3
00002234  6100 001C               1778              BSR       FIND_HIGH_TO_LOW_BITS
00002238                          1779  
00002238  6100 0012               1780              BSR       REMOVE_FINAL_SLASH 
0000223C  4E75                    1781              RTS
0000223E                          1782  
0000223E                          1783  LOAD_REGISTERS:
0000223E  6100 FF2E               1784              BSR       MOVEM_BR
00002242  143C 00FF               1785              MOVE.B    #-1, D2
00002246  3238 11DE               1786              MOVE.W    list_mask, D1
0000224A  4E75                    1787              RTS
0000224C                          1788  
0000224C                          1789  REMOVE_FINAL_SLASH:
0000224C  133C 0000               1790              MOVE.B    #0, -(A1)
00002250  4E75                    1791              RTS 
00002252                          1792  
00002252                          1793  *-----------------------------------------------------------  
00002252                          1794  FIND_HIGH_TO_LOW_BITS:
00002252                          1795              * only parse 8 (0 based) data registers or address registers at a time
00002252  5202                    1796              ADD.B     #1, D2            
00002254  B43C 0007               1797              CMP.B     #7, D2  
00002258  6E00 0052               1798              BGT       NO_MORE_BITS
0000225C                          1799  
0000225C                          1800              * are this register -> memory?
0000225C  BA3C 0000               1801              CMP.B     #0, D5 
00002260  6700 000C               1802              BEQ       SHIFT_LIST_LEFT
00002264                          1803  
00002264                          1804              * are this memory -> register?
00002264  BA3C 0001               1805              CMP.B     #1, D5 
00002268  6700 000C               1806              BEQ       SHIFT_LIST_RIGHT        
0000226C  60E4                    1807              BRA       FIND_HIGH_TO_LOW_BITS
0000226E                          1808  
0000226E                          1809  SHIFT_LIST_LEFT:
0000226E                          1810              * shift left to detect carry. If 1 is carried out, that means there is a register there
0000226E  E341                    1811              ASL.W     #1, D1
00002270  6500 000C               1812              BCS       STORE_BIT    
00002274  60DC                    1813              BRA       FIND_HIGH_TO_LOW_BITS
00002276                          1814  
00002276                          1815  SHIFT_LIST_RIGHT:
00002276                          1816              * shift left to detect carry. If 1 is carried out, that means there is a register there
00002276  E241                    1817              ASR.W     #1, D1
00002278  6500 0004               1818              BCS       STORE_BIT         
0000227C  60D4                    1819              BRA       FIND_HIGH_TO_LOW_BITS
0000227E                          1820  
0000227E                          1821  STORE_BIT:
0000227E                          1822              * are we dealing with data registers?
0000227E  B63C 0000               1823              CMP.B     #0, D3
00002282  6700 000A               1824              BEQ       STORE_DATA_REG_BIT
00002286                          1825  
00002286                          1826              * are we dealing with address registers?
00002286  B63C 0001               1827              CMP.B     #1, D3
0000228A  6700 000A               1828              BEQ       STORE_ADDR_REG_BIT
0000228E                          1829  
0000228E                          1830  STORE_DATA_REG_BIT:
0000228E  12FC 0044               1831              MOVE.B    #'D', (A1)+
00002292  6000 000A               1832              BRA       LOOP_BACK
00002296                          1833  
00002296                          1834  STORE_ADDR_REG_BIT:
00002296  12FC 0041               1835              MOVE.B    #'A', (A1)+
0000229A  6000 0002               1836              BRA       LOOP_BACK
0000229E                          1837  
0000229E                          1838  LOOP_BACK:
0000229E                          1839              * push register number to buffer
0000229E  1E02                    1840              MOVE.B    D2, D7
000022A0  0607 0030               1841              ADD.B     #$30, D7
000022A4  12C7                    1842              MOVE.B    D7, (A1)+
000022A6  12FC 002F               1843              MOVE.B    #'/', (A1)+       
000022AA  60A6                    1844              BRA       FIND_HIGH_TO_LOW_BITS
000022AC                          1845  
000022AC                          1846  NO_MORE_BITS:
000022AC  31C1 11DE               1847              MOVE.W    D1, list_mask
000022B0  4E75                    1848              RTS
000022B2                          1849  *-----------------------------------------------------------
000022B2                          1850  
000022B2                          1851  
000022B2                          1852  
000022B2                          1853  
000022B2                          1854  
000022B2                          1855  
000022B2                          1856  
000022B2                          1857  
000022B2                          1858  
000022B2                          1859  
000022B2                          1860  
000022B2                          1861  
000022B2                          1862  *----------------------EA_TO_BUFFER------------------
000022B2                          1863  * Description:
000022B2                          1864  * Evaluates the ea mode and register of an opcode 
000022B2                          1865  * (usually last 6 bits of instruction format),
000022B2                          1866  * and adds it to A1 to be printed out
000022B2                          1867  *
000022B2                          1868  * No Parameters
000022B2                          1869  *
000022B2                          1870  * Registers Used:
000022B2                          1871  *   D1 = amount to shift the opcode
000022B2                          1872  *   D2 = destination for shifts
000022B2                          1873  *-----------------------------------------------------------
000022B2                          1874  EA_TO_BUFFER:                            
000022B2  0C38 0000 11DB          1875              CMP.B   #%0000, ea_mode        * Direct Data Register
000022B8  6700 004C               1876              BEQ     EA_000
000022BC                          1877  
000022BC  0C38 0001 11DB          1878              CMP.B   #%0001, ea_mode        * Direct Address Register
000022C2  6700 0052               1879              BEQ     EA_001
000022C6                          1880  
000022C6  0C38 0002 11DB          1881              CMP.B   #%0010, ea_mode        * Indirect Address Register
000022CC  6700 0058               1882              BEQ     EA_010
000022D0                          1883  
000022D0  0C38 0003 11DB          1884              CMP.B   #%0011, ea_mode        * Post Increment
000022D6  6700 0066               1885              BEQ     EA_011
000022DA                          1886  
000022DA  0C38 0004 11DB          1887              CMP.B   #%0100, ea_mode        * Pre Decrement
000022E0  6700 0078               1888              BEQ     EA_100
000022E4                          1889  
000022E4  0C38 0005 11DB          1890              CMP.B   #%0101, ea_mode        * Not necessary, go to bad EA
000022EA  6700 008A               1891              BEQ     EA_101
000022EE                          1892  
000022EE  0C38 0006 11DB          1893              CMP.B   #%0110, ea_mode        * Not necessary, go to bad EA
000022F4  6700 0084               1894              BEQ     EA_110
000022F8                          1895  
000022F8  0C38 0007 11DB          1896              CMP.B   #%0111, ea_mode        * Absolute or immediate address
000022FE  6700 007E               1897              BEQ     EA_111
00002302                          1898  
00002302  6000 00E2               1899              BRA    INVALID_EA
00002306                          1900  
00002306                          1901  *----------------------------Direct Data Register------------------------
00002306                          1902  EA_000:
00002306  12FC 0044               1903              MOVE.B      #'D',(A1)+              * add "D" to buffer
0000230A  0638 0030 11DC          1904              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00002310  12F8 11DC               1905              MOVE.B      ea_register, (A1)+      * register # to buffer                  
00002314  4E75                    1906              RTS                                
00002316                          1907  
00002316                          1908  *----------------------------Direct Address Register------------------------
00002316                          1909  EA_001:
00002316  12FC 0041               1910              MOVE.B      #'A',(A1)+              * add "A" to buffer
0000231A  0638 0030 11DC          1911              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00002320  12F8 11DC               1912              MOVE.B      ea_register, (A1)+      * register # to buffer               
00002324  4E75                    1913              RTS                            
00002326                          1914  
00002326                          1915  *----------------------------Indirect Address Register------------------------
00002326                          1916  EA_010:
00002326  12FC 0028               1917              MOVE.B      #'(',(A1)+              * add "(" to buffer
0000232A  12FC 0041               1918              MOVE.B      #'A',(A1)+              * add "A" to buffer
0000232E  0638 0030 11DC          1919              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00002334  12F8 11DC               1920              MOVE.B      ea_register, (A1)+      * register # to buffer     
00002338  12FC 0029               1921              MOVE.B      #')',(A1)+              * add ")" to buffer
0000233C  4E75                    1922              RTS                            
0000233E                          1923  
0000233E                          1924  *----------------------------Post Increment------------------------
0000233E                          1925  EA_011:
0000233E  12FC 0028               1926              MOVE.B      #'(',(A1)+              * add "(" to buffer
00002342  12FC 0041               1927              MOVE.B      #'A',(A1)+              * add "A" to buffer
00002346  0638 0030 11DC          1928              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
0000234C  12F8 11DC               1929              MOVE.B      ea_register, (A1)+      * register # to buffer 
00002350  12FC 0029               1930              MOVE.B      #')',(A1)+              * add ")" to buffer
00002354  12FC 002B               1931              MOVE.B      #'+',(A1)+              * add "+" to buffer 
00002358  4E75                    1932              RTS                              
0000235A                          1933  
0000235A                          1934  *----------------------------Pre Decrement------------------------
0000235A                          1935  EA_100:
0000235A  12FC 002D               1936              MOVE.B      #'-',(A1)+              * add "-" to buffer
0000235E  12FC 0028               1937              MOVE.B      #'(',(A1)+              * add "(" to buffer
00002362  12FC 0041               1938              MOVE.B      #'A',(A1)+              * add "A" to buffer
00002366  0638 0030 11DC          1939              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
0000236C  12F8 11DC               1940              MOVE.B      ea_register, (A1)+      * register # to buffer 
00002370  12FC 0029               1941              MOVE.B      #')',(A1)+              * add ")" to buffer
00002374  4E75                    1942              RTS
00002376                          1943  
00002376                          1944  *----------------------------Not necessary, go to bad EA------------------------
00002376                          1945  EA_101:
00002376  6000 006E               1946              BRA         INVALID_EA        
0000237A                          1947  
0000237A                          1948  *----------------------------Not necessary, go to bad EA------------------------
0000237A                          1949  EA_110:
0000237A  6000 006A               1950              BRA         INVALID_EA        
0000237E                          1951  
0000237E                          1952  *----------------------------Absolute or immediate address------------------------
0000237E                          1953  EA_111:
0000237E                          1954  
0000237E  0C38 0000 11DC          1955              CMP.B       #%000, ea_register                  * compare to determine if it's a word
00002384  6700 001A               1956              BEQ         EA_WORD                             * put word address in buffer
00002388                          1957  
00002388  0C38 0001 11DC          1958              CMP.B       #%001, ea_register                  * compare to determine if it's a long
0000238E  6700 0024               1959              BEQ         EA_LONG                             * put long address in buffer
00002392                          1960              
00002392  0C38 0004 11DC          1961              CMP.B       #%100, ea_register
00002398  6700 002E               1962              BEQ         EA_IMMEDIATE                        * always print a long if it's immediate data
0000239C                          1963  
0000239C                          1964              * Invalid EA mode/register
0000239C  6000 0048               1965              BRA         INVALID_EA
000023A0                          1966  
000023A0                          1967  EA_WORD:
000023A0  12FC 0024               1968              MOVE.B      #'$', (A1)+
000023A4  4281                    1969              CLR.L       D1
000023A6  123C 0001               1970              MOVE.B      #1, D1
000023AA  3E1A                    1971              MOVE.W      (A2)+, D7
000023AC  6100 003E               1972              BSR         HEX_TO_ASCII
000023B0  6000 0032               1973              BRA         GET_EA_DONE
000023B4                          1974  
000023B4                          1975  EA_LONG:
000023B4  12FC 0024               1976              MOVE.B      #'$', (A1)+
000023B8  4281                    1977              CLR.L       D1
000023BA  123C 0003               1978              MOVE.B      #3, D1
000023BE  2E1A                    1979              MOVE.L      (A2)+, D7   
000023C0  6100 002A               1980              BSR         HEX_TO_ASCII
000023C4  6000 001E               1981              BRA         GET_EA_DONE
000023C8                          1982  
000023C8                          1983  EA_IMMEDIATE:
000023C8  12FC 0023               1984              MOVE.B      #'#', (A1)+
000023CC                          1985  
000023CC  0C38 0000 11D9          1986              CMP.B       #0, opSize          
000023D2  67CC                    1987              BEQ         EA_WORD
000023D4                          1988  
000023D4  0C38 0001 11D9          1989              CMP.B       #1, opSize          
000023DA  67C4                    1990              BEQ         EA_WORD          
000023DC                          1991              
000023DC  0C38 0002 11D9          1992              CMP.B       #2, opSize
000023E2  60D0                    1993              BRA         EA_LONG             
000023E4                          1994  
000023E4                          1995  GET_EA_DONE:
000023E4  4E75                    1996              RTS
000023E6                          1997  
000023E6                          1998  *------------------Invalid Effective Address----------------
000023E6                          1999  INVALID_EA:
000023E6  4EF9 00002492           2000              JMP      DONE
000023EC                          2001  *-----------------------------------------------------------
000023EC                          2002  
000023EC                          2003  
000023EC                          2004  
000023EC                          2005  
000023EC                          2006  
000023EC                          2007  
000023EC                          2008  
000023EC                          2009  
000023EC                          2010  
000023EC                          2011  *----------------------HEX TO ASCII-------------------------
000023EC                          2012  * Description:
000023EC                          2013  * Converts a Hex numbered address (1-9 or A-F) back to an
000023EC                          2014  * ASCII value for printing
000023EC                          2015  *
000023EC                          2016  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
000023EC                          2017  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
000023EC                          2018  *   D7 = holds the original address to parse (either word or long, for example: $7000)
000023EC                          2019  *
000023EC                          2020  *
000023EC                          2021  * Registers Used:
000023EC                          2022  *   D0 = number of bits to remove
000023EC                          2023  *   D2 = holds either top four bits or bottom four bits of each byte in D6
000023EC                          2024  *   D3 = holds temp data
000023EC                          2025  *   D6 = holds part of address (used as temp variable)
000023EC                          2026  *   A1 = used for buffer
000023EC                          2027  *-----------------------------------------------------------
000023EC                          2028  HEX_TO_ASCII:
000023EC  1001                    2029              MOVE.B   D1, D0             * current number of bytes to remove
000023EE  C1FC 0008               2030              MULS.W   #8, D0             * number of bits to remove
000023F2                          2031  
000023F2  2C07                    2032              MOVE.L   D7, D6             * load original address to parse
000023F4  E0AE                    2033              LSR.L    D0, D6             * remove lowest byte(s)
000023F6                          2034  
000023F6                          2035              * isolate first four bits
000023F6  1406                    2036              MOVE.B   D6, D2
000023F8  E80A                    2037              LSR.B    #4, D2 
000023FA  6100 0018               2038              BSR      NUMBER_OR_LETTER
000023FE                          2039  
000023FE                          2040              * isolate second set of four bits
000023FE  1406                    2041              MOVE.B   D6, D2
00002400  E90A                    2042              LSL.B    #4, D2 
00002402  E80A                    2043              LSR.B    #4, D2 
00002404  6100 000E               2044              BSR      NUMBER_OR_LETTER
00002408                          2045  
00002408  5301                    2046              SUB.B    #1, D1             * iterate
0000240A  B23C 0000               2047              CMP.B    #0, D1             * done if equal
0000240E  6D00 0036               2048              BLT      ATH_DONE
00002412                          2049  
00002412  60D8                    2050              BRA      HEX_TO_ASCII
00002414                          2051  
00002414                          2052  NUMBER_OR_LETTER:
00002414  1602                    2053              MOVE.B   D2, D3
00002416  0603 0030               2054              ADD.B    #$30, D3           
0000241A  B63C 0039               2055              CMP.B    #$39, D3           * is byte in D2 a number?
0000241E  6F00 0012               2056              BLE      NUMBER_TO_ASCII
00002422                          2057              
00002422  1602                    2058              MOVE.B   D2, D3
00002424  0603 0037               2059              ADD.B    #$37, D3           
00002428  B63C 0039               2060              CMP.B    #$39, D3           * is byte in D2 a letter?
0000242C  6C00 000C               2061              BGE      LETTER_TO_ASCII
00002430                          2062  
00002430  60B4                    2063              BRA      INVALID_EA
00002432                          2064  
00002432                          2065  NUMBER_TO_ASCII:
00002432  0602 0030               2066              ADD.B    #$30, D2           * Get the hex range from '0-9'
00002436  6000 000A               2067              BRA      ADD_TO_BUFFER
0000243A                          2068  
0000243A                          2069  LETTER_TO_ASCII:
0000243A  0602 0037               2070              ADD.B    #$37, D2           * Get the hex range from 'A-F'
0000243E  6000 0002               2071              BRA      ADD_TO_BUFFER
00002442                          2072  
00002442                          2073  ADD_TO_BUFFER:
00002442  12C3                    2074              MOVE.B   D3, (A1)+          * add part of address to buffer    
00002444  4E75                    2075              RTS
00002446                          2076  
00002446                          2077  ATH_DONE:
00002446                          2078m             CLR_D_REGS
00002456  4E75                    2079              RTS
00002458                          2080  *-----------------------------------------------------------
00002458                          2081  
00002458                          2082  
00002458                          2083  
00002458                          2084  
00002458                          2085  
00002458                          2086  
00002458                          2087  
00002458                          2088  
00002458                          2089  
00002458                          2090  *---------------------SIZE TO BUFFER------------------------
00002458                          2091  * Description:
00002458                          2092  * Evaluates the size of an opcode and adds it to A1 to be printed out
00002458                          2093  *
00002458                          2094  * Parameters:
00002458                          2095  *   D3 = size of opcode
00002458                          2096  *
00002458                          2097  * Registers Used:
00002458                          2098  *   A1: adding words/numbers to buffer
00002458                          2099  *-----------------------------------------------------------
00002458                          2100  FIND_SIZE: 
00002458  B63C 0000               2101              CMP.B   #%0000,D3            
0000245C  6700 0016               2102              BEQ     BYTE_TO_BUFFER              
00002460                          2103  
00002460  B63C 0001               2104              CMP.B   #%0001,D3             * is this a word?
00002464  6700 0016               2105              BEQ     WORD_TO_BUFFER
00002468                          2106  
00002468  B63C 0002               2107              CMP.B   #%0010,D3             * is this a long?
0000246C  6700 0016               2108              BEQ     LONG_TO_BUFFER             
00002470                          2109        
00002470  4EF8 15D4               2110              JMP     BAD_OPCODE  
00002474                          2111              
00002474                          2112  BYTE_TO_BUFFER:
00002474  12FC 0042               2113              MOVE.B  #'B', (A1)+           * add B to buffer
00002478  6000 0012               2114              BRA     STB_END             
0000247C                          2115              
0000247C                          2116  WORD_TO_BUFFER:
0000247C  12FC 0057               2117              MOVE.B  #'W', (A1)+          * add W to buffer
00002480  6000 000A               2118              BRA     STB_END             
00002484                          2119  
00002484                          2120  LONG_TO_BUFFER:
00002484  12FC 004C               2121              MOVE.B  #'L',(A1)+          * add L to buffer
00002488  6000 0002               2122              BRA     STB_END             
0000248C                          2123  
0000248C                          2124  STB_END:
0000248C  12FC 0020               2125              MOVE.B  #' ',(A1)+          * add blank space to buffer
00002490  4E75                    2126              RTS                         
00002492                          2127  *-----------------------------------------------------------
00002492                          2128  
00002492                          2129  
00002492                          2130  
00002492                          2131  
00002492                          2132  
00002492                          2133  
00002492                          2134  *-------------------------DONE-------------------------------
00002492                          2135  DONE:
00002492                          2136m             CLR_A_REG D0, A1
00002496                          2137  
00002496                          2138              * add 'SIMHAULT' to buffer
00002496  12FC 0020               2139              MOVE.B  #' ',(A1)+ 
0000249A  12FC 0053               2140              MOVE.B  #'S',(A1)+      
0000249E  12FC 0049               2141              MOVE.B  #'I',(A1)+         
000024A2  12FC 004D               2142              MOVE.B  #'M',(A1)+         
000024A6  12FC 0048               2143              MOVE.B  #'H',(A1)+        
000024AA  12FC 0041               2144              MOVE.B  #'A',(A1)+                 
000024AE  12FC 004C               2145              MOVE.B  #'L',(A1)+          
000024B2  12FC 0054               2146              MOVE.B  #'T',(A1)+                 
000024B6  12FC 0000               2147              MOVE.B  #00,(A1)+         
000024BA                          2148  
000024BA                          2149m             CLR_A_REG D0, A1
000024BE                          2150              
000024BE                          2151              * print out string
000024BE  103C 000E               2152              MOVE.B    #14, D0
000024C2  4E4F                    2153              TRAP      #15
000024C4                          2154              
000024C4                          2155m             PRINT_MSG    newLine
000024D0                          2156m             PRINT_MSG    doneMsg
000024DC                          2157              
000024DC                          2158m             CLR_A_REG D0, A1
000024E0                          2159              
000024E0                          2160              *Write Pending data to file
000024E0  103C 0038               2161              MOVE.B #56,D0 
000024E4  4E4F                    2162              TRAP   #15
000024E6                          2163              
000024E6                          2164  
000024E6                          2165              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       2442
ATH_DONE            2446
A_SHIFT             1DC6
BADINPUT            11A4
BAD_OPCODE          15D4
BCC_DISPLACEMENT    1C0A
BEQ                 1BF6
BGE                 1BE2
BLT                 1BCE
BYTE_TO_BUFFER      2474
CHECK_ADDRESS       13AA
CHECK_IMMEDIATE     16D2
CHECK_LENGTH        1384
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      13DC
CR                  D
DECODE_11_TO_6      1252
DECODE_6_TO_0       11F0
DECODE_EA           57B
DECODE_EA_HELP      11E0
DECODE_IMMEDIATE    166C
DECODE_MOVE         1774
DECODE_MOVEM        20EA
DECODE_QUICK        1AAE
DONE                2492
DONEMSG             116C
DONE_MOVEM          221E
D_TO_EA             2042
EA_000              2306
EA_001              2316
EA_010              2326
EA_011              233E
EA_100              235A
EA_101              2376
EA_110              237A
EA_111              237E
EA_END              12B4
EA_IMMEDIATE        23C8
EA_LONG             23B4
EA_MODE             11DB
EA_REGISTER         11DC
EA_TO_BUFFER        22B2
EA_TO_D             2072
EA_VALID            11DD
EA_WORD             23A0
EIGHT_TO_BUFF       1F24
ENDADDR             11D2
ENDMSG              1149
FILENAME            11B7
FIND_HIGH_TO_LOW_BITS  2252
FIND_NUMS_DONE      1480
FIND_NUM_OF_CHARS   1470
FIND_OPCODE         154E
FIND_SIZE           2458
FINISH_PRINT        1454
GET_ADDRESS         135C
GET_BITS            1C5
GET_DATA_REG_NUM    20AA
GET_EA_DONE         23E4
GET_EA_MODE         613
GET_EA_REG          675
GET_INPUT           130C
GRAB_FIRST_FOUR_BITS  1518
GRAB_NEXT_WORD      1512
HEX_TO_ASCII        23EC
IDENTIFY_OPCODE     14E6
IMMEDIATE_LONG      16EE
IMMEDIATE_WORD      16E6
INSERT_COMMA        73A
INSERT_DOLLAR       857
INSERT_PERIOD       799
INSERT_POUND        7F8
INSERT_SPACE        6DB
INVALID_ADDRESS     13CA
INVALID_EA          23E6
INVALID_INPUT       1398
ITERATE             1410
LETTER_TO_ASCII     243A
LETTER_TO_HEX       1402
LF                  A
LIST_MASK           11DE
LOAD_ADDRESSES      14C0
LOAD_REGISTERS      223E
LONG_TO_BUFFER      2484
LOOP_BACK           229E
L_SHIFT             1E04
L_TO_BUFF           1E42
MAIN                12B6
MEM_TO_REG          21E0
MOVEM_BR            216E
MOVEM_PUSH_LONG     2154
MOVEM_PUSH_WORD     214C
MOVEM_SIZE          2112
MOVEM_SIZE_DONE     215C
NEWLINE             11B4
NO_MORE_BITS        22AC
NUMBER_OR_LETTER    2414
NUMBER_TO_ASCII     2432
NUM_TO_HEX          13FA
OPCODE              11D6
OPC_0000            15DA
OPC_0001            16F6
OPC_0010            1720
OPC_0011            174A
OPC_0100            17BA
OPC_0101            1A40
OPC_0110            1B4E
OPC_0111            197C
OPC_1000            1A14
OPC_1001            1CEA
OPC_1100            1CFE
OPC_1101            1D76
OPC_1110            1D8A
OPC_ADDI            163C
OPC_ADDQ            1A7E
OPC_AND             1D34
OPC_ANDI            1624
OPC_BRA             1C60
OPC_DIVU            1A18
OPC_JSR             1918
OPC_LEA             18CA
OPC_MOVEM           195A
OPC_MULS            1D48
OPC_NOP             1852
OPC_NOT             1862
OPC_RTS             194A
OPC_SUBI            1654
OPC_SUBQ            1A96
OPSIZE              11D9
OPTAG               11D8
PRINTADDREND        11C6
PRINTADDRSTART      11C6
PRINT_ADDRESS       1422
PRINT_INSTRUCTION   148C
PRINT_LONG          144A
PRINT_MSG           0
PRINT_WORD          1440
PROCESS_ROEA        1FD2
REGS_TO_MEM         2220
REG_TO_MEM          21A2
REMOVE_FINAL_SLASH  224C
RESTART_INPUT       135A
RETURN_TO_INPUT     1382
ROEA_DONE           20A2
RULE1               1000
RULE1C              1038
RULE2               1059
RULE3               109B
RULE3C              10DD
R_TO_BUFF           1E4E
SHIFT_COUNT         1EE4
SHIFT_DEST_REG      1F6A
SHIFT_IMMEDIATE_MODE  1ECE
SHIFT_LIST_LEFT     226E
SHIFT_LIST_RIGHT    2276
SHIFT_MEM_MODE      1FA8
SHIFT_MODES         1E5A
SHIFT_REGISTER_MODE  1F2A
SHIFT_REG_OR_IMM    1E90
SIXTEEN_BIT_DISPLACEMENT  1CC6
SIZE_TO_BUFFER      51C
STARTADDR           11CE
STARTMSG            1125
STB_END             248C
STORE_ADDR_REG_BIT  2296
STORE_BIT           227E
STORE_CHAR          140A
STORE_DATA_REG_BIT  228E
STORE_INPUT         141E
USERADDR            11C6
VALID               11DA
VALUE_TO_BUFFER     4B4
WORD_TO_BUFFER      247C
