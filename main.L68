0000127C Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/13/2021 12:34:38 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00000000                            11              
00001000                            12              ORG     $1000
00001000                            13  
00001000  =0000000D                 14  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 15  LF          EQU     $0A 
00001000                            16  
00001000= 31 2E 20 41 64 64 ...     17  rule1:      DC.B    '1. Addresses must be in the range $FFFFFF > x > $6FFF', CR, LF, 0 ' 
00001038= 77 68 65 72 65 20 ...     18  rule1c:     DC.B    'where x is your given address.', CR, LF, 0 '
00001059= 32 2E 20 49 66 20 ...     19  rule2:      DC.B    '2. If you use any letters (A-F), make sure they are upper case.', CR, LF, 0
0000109B= 33 2E 20 49 66 20 ...     20  rule3:      DC.B    '3. If you use constants (DC), make sure you give addresses that', CR, LF, 0 
000010DD= 64 6F 20 6E 6F 74 ...     21  rule3c:     DC.B    'do not include that part of memory (only want to parse instructions).', CR, LF, 0
00001125= 50 6C 65 61 73 65 ...     22  startMsg:   DC.B    'Please enter a starting address.  ', CR, LF, 0
0000114A= 50 6C 65 61 73 65 ...     23  endMsg:     DC.B    'Please enter an ending address. ', CR, LF, 0
0000116D= 65 78 69 74 69 6E ...     24  doneMsg:    DC.B    'exiting...', CR, LF, 0
0000117A= 49 6E 76 61 6C 69 ...     25  badInput:   DC.B    'Invalid Input', CR, LF, 0
0000118A= 0D 0A 00                  26  newline:    DC.B    '', CR, LF, 0
0000118D                            27  
0000118E                            28  userAddr:   DS.L    1
00001192= 00000000                  29              DC.L    0 *Null termination for userAddr
00001196                            30  startAddr:  DS.L    1
0000119A                            31  endAddr:    DS.L    1
0000119E                            32  
0000119E                            33  opcode:     DS.W    1   
000011A0                            34  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
000011A1                            35  opSize:     DS.B    1
000011A2                            36  valid:      DS.B    1
000011A3                            37  
000011A3                            38  ea_mode     DS.B    1
000011A4                            39  ea_register DS.B    1
000011A5                            40  ea_valid    DS.B    1
000011A6                            41  
000011A6                            42  
000011A6                            43  
000011A6                            44  
000011A6                            45  
000011A6                            46  
000011A6                            47  
000011A6                            48  *-----------------------------------------------------------
000011A6                            49  * Macros:
000011A6                            50  *-----------------------------------------------------------
000011A6                            51  
000011A6                            52  PRINT_MSG:  MACRO 
000011A6                            53              CLR.L   D0
000011A6                            54              LEA     \1, A1      ; \1 acts as a parameter
000011A6                            55              MOVE.B  #14, D0     
000011A6                            56              TRAP    #15
000011A6                            57              ENDM
000011A6                            58  
000011A6                            59  CLR_D_REGS: MACRO
000011A6                            60              CLR.L   D0
000011A6                            61              CLR.L   D1
000011A6                            62              CLR.L   D2
000011A6                            63              CLR.L   D3
000011A6                            64              CLR.L   D4
000011A6                            65              CLR.L   D5
000011A6                            66              CLR.L   D6
000011A6                            67              CLR.L   D7
000011A6                            68              ENDM
000011A6                            69  
000011A6                            70  CLR_A_REG:  MACRO
000011A6                            71              CLR.L   \1
000011A6                            72              MOVE.L  \1, \2
000011A6                            73              ENDM              
000011A6                            74  
000011A6                            75  *-----------------------------------------------------------
000011A6                            76  * Parameters:
000011A6                            77  *   \1 should be highest bit in range
000011A6                            78  *   \2 should be lowest bit in range
000011A6                            79  * 
000011A6                            80  * Example: #11, #9
000011A6                            81  *
000011A6                            82  * Return Value:
000011A6                            83  *   D4 = value held within bits \1 and \2
000011A6                            84  *
000011A6                            85  * Registers:
000011A6                            86  *   D4 = holds opcode
000011A6                            87  *   D5 = highest bit in range 
000011A6                            88  *   D6 = lowest bit in range 
000011A6                            89  *   D7 = number of bits we want
000011A6                            90  *-----------------------------------------------------------
000011A6                            91  GET_BITS:   MACRO
000011A6                            92  
000011A6                            93              CLR_D_REGS
000011A6                            94  
000011A6                            95              * Subtract value to find amount to shift by 
000011A6                            96              ADD.B   \1, D7          
000011A6                            97              SUB.B   \2, D7 
000011A6                            98              ADD.B   #1, D7  * add 1 because we start our count from 0
000011A6                            99  
000011A6                           100              * Get high bit offset
000011A6                           101              ADD.B   #15, D5
000011A6                           102              SUB.B   \1, D5
000011A6                           103              
000011A6                           104              * shift out high bits
000011A6                           105              MOVE.W  opcode, D4
000011A6                           106              LSL.W   D5, D4
000011A6                           107              
000011A6                           108              *get low bit offset
000011A6                           109              *16 - NUMBER OF BITS WE WANT
000011A6                           110              ADD.B   #16, D6         * 16 total bits
000011A6                           111              SUB.L   D7, D6          * subtract numBits from 16
000011A6                           112              
000011A6                           113              * shift out low bits
000011A6                           114              LSR.W   D6, D4          * isolate bits
000011A6                           115              ENDM
000011A6                           116  
000011A6                           117  *----------------------Value To Buffer----------------------
000011A6                           118  * Description:
000011A6                           119  * Converts a Hex numbered address (1-9 or A-F) back to an
000011A6                           120  * ASCII value and pushes it to the buffer for printing
000011A6                           121  *
000011A6                           122  * Parameters:
000011A6                           123  *   \1 = should hold value (in hex) you want to push to the buffer
000011A6                           124  *
000011A6                           125  *-----------------------------------------------------------
000011A6                           126  VALUE_TO_BUFFER:  MACRO
000011A6                           127                    MOVE.L  \1, D2  
000011A6                           128                    JSR     NUMBER_OR_LETTER
000011A6                           129                    ENDM
000011A6                           130  *-----------------------------------------------------------
000011A6                           131  
000011A6                           132  *----------------------Size To Buffer-----------------------
000011A6                           133  * Description:
000011A6                           134  * Converts a binary size (Byte = 00, Word = 01, or Long = 10) 
000011A6                           135  * to a letter (B, W, L) and pushes it to the buffer
000011A6                           136  *
000011A6                           137  * Parameters:
000011A6                           138  *   \1 = should hold size (in binary) of the size you want
000011A6                           139  *        to push to the buffer
000011A6                           140  *
000011A6                           141  *-----------------------------------------------------------
000011A6                           142  SIZE_TO_BUFFER:   MACRO
000011A6                           143                    MOVE.L  \1, D3
000011A6                           144                    JSR     FIND_SIZE
000011A6                           145                    ENDM
000011A6                           146  *-----------------------------------------------------------
000011A6                           147  
000011A6                           148  
000011A6                           149  
000011A6                           150  
000011A6                           151  
000011A6                           152  
000011A6                           153  *----------------Decoding EA Mode and Register--------------
000011A6                           154  * Description:
000011A6                           155  * Decodes EA mode and register and pushes to buffer
000011A6                           156  * 
000011A6                           157  * Parameters:
000011A6                           158  *   \1 = high bit of ea
000011A6                           159  *   \2 = low bit of ea
000011A6                           160  *
000011A6                           161  * Registers Used:
000011A6                           162  *   D1 = temp variable
000011A6                           163  *
000011A6                           164  * For Example (most common): 
000011A6                           165  *   DECODE_EA    #5, #0
000011A6                           166  *
000011A6                           167  *-----------------------------------------------------------
000011A6                           168  DECODE_EA:  MACRO
000011A6                           169              CLR_D_REGS
000011A6                           170              MOVE.B      \1, D1
000011A6                           171              JSR         DECODE_EA_HELP
000011A6                           172              JSR         EA_TO_BUFFER
000011A6                           173              ENDM
000011A6                           174  
000011A6                           175  GET_EA_MODE: MACRO
000011A6                           176               GET_BITS        \1, \2
000011A6                           177               MOVE.B          D4, ea_mode
000011A6                           178               ENDM
000011A6                           179  
000011A6                           180  GET_EA_REG:  MACRO
000011A6                           181               GET_BITS        \1, \2
000011A6                           182               MOVE.B          D4, ea_register
000011A6                           183               ENDM
000011A6                           184  *-----------------------------------------------------------
000011A6                           185  
000011A6                           186  *-----------------------------------------------------------
000011A6                           187  DECODE_EA_HELP:
000011A6                           188          
000011A6  B23C 0005                189              CMP.B       #5, D1               * is this bits 5-0?
000011AA  6700 000A                190              BEQ         DECODE_6_TO_0
000011AE                           191  
000011AE  B23C 000B                192              CMP.B       #11, D1              * is this bits 11-6? 
000011B2  6700 0064                193              BEQ         DECODE_11_TO_6
000011B6                           194  
000011B6                           195  DECODE_6_TO_0:
000011B6                           196m             GET_EA_MODE #5, #3               * get ea mode
000011C6                           197mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011CC                           198mm             * GET HIGH BIT OFFSET
000011D2                           199mm             * SHIFT OUT HIGH BITS
000011D8                           200mm             *GET LOW BIT OFFSET
000011D8                           201mm             *16 - NUMBER OF BITS WE WANT
000011DE                           202mm             * SHIFT OUT LOW BITS
000011E4                           203m             GET_EA_REG  #2, #0               * get ea register
000011F4                           204mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011FC                           205mm             * GET HIGH BIT OFFSET
00001202                           206mm             * SHIFT OUT HIGH BITS
00001208                           207mm             *GET LOW BIT OFFSET
00001208                           208mm             *16 - NUMBER OF BITS WE WANT
0000120E                           209mm             * SHIFT OUT LOW BITS
00001214  6000 0064                210              BRA         EA_END
00001218                           211  
00001218                           212  DECODE_11_TO_6:
00001218                           213m             GET_EA_MODE #8, #6               * get ea mode
00001228                           214mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000122E                           215mm             * GET HIGH BIT OFFSET
00001234                           216mm             * SHIFT OUT HIGH BITS
0000123A                           217mm             *GET LOW BIT OFFSET
0000123A                           218mm             *16 - NUMBER OF BITS WE WANT
00001240                           219mm             * SHIFT OUT LOW BITS
00001246                           220m             GET_EA_REG  #11, #9              * get ea register
00001256                           221mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001260                           222mm             * GET HIGH BIT OFFSET
00001268                           223mm             * SHIFT OUT HIGH BITS
0000126E                           224mm             *GET LOW BIT OFFSET
0000126E                           225mm             *16 - NUMBER OF BITS WE WANT
00001274                           226mm             * SHIFT OUT LOW BITS
0000127A                           227  
0000127A                           228  EA_END:
0000127A  4E75                     229              RTS
0000127C                           230  
0000127C                           231  *-----------------------------------------------------------            
0000127C                           232  
0000127C                           233  
0000127C                           234  
0000127C                           235  
0000127C                           236  
0000127C                           237  *----------------------Buffer Macros------------------------
0000127C                           238  * Description:
0000127C                           239  * Pushes commonly used single characters to the buffer
0000127C                           240  *-----------------------------------------------------------
0000127C                           241  INSERT_SPACE:   MACRO
0000127C                           242                  MOVE.B  #' ',(A1)+          * add blank space to buffer
0000127C                           243                  ENDM
0000127C                           244  
0000127C                           245  INSERT_COMMA:   MACRO
0000127C                           246                  MOVE.B  #',',(A1)+          * add blank space to buffer
0000127C                           247                  ENDM
0000127C                           248  
0000127C                           249  INSERT_PERIOD:  MACRO
0000127C                           250                  MOVE.B  #'.',(A1)+          * add blank space to buffer
0000127C                           251                  ENDM
0000127C                           252  
0000127C                           253  INSERT_POUND:   MACRO
0000127C                           254                  MOVE.B  #'#',(A1)+          * add blank space to buffer
0000127C                           255                  ENDM
0000127C                           256  
0000127C                           257  INSERT_DOLLAR:  MACRO
0000127C                           258                  MOVE.B  #'$',(A1)+          * add blank space to buffer
0000127C                           259                  ENDM
0000127C                           260  *-----------------------------------------------------------
0000127C                           261  
0000127C                           262  
0000127C                           263  
0000127C                           264  
0000127C                           265  
0000127C                           266  
0000127C                           267  
0000127C                           268  
0000127C                           269  
0000127C                           270  *-----------------------------------------------------------
0000127C                           271  * Description:  
0000127C                           272  * Main routine
0000127C                           273  *-----------------------------------------------------------
0000127C                           274  
0000127C                           275  *-------------------------MAIN------------------------------
0000127C                           276  MAIN:
0000127C                           277m             PRINT_MSG    rule1
00001288                           278m             PRINT_MSG    rule1c                   
00001294                           279m             PRINT_MSG    rule2
000012A0                           280m             PRINT_MSG    rule3
000012AC                           281m             PRINT_MSG    rule3c
000012B8  6100 000A                282              BSR          GET_INPUT
000012BC  6100 0074                283              BSR          CHECK_ADDRESS
000012C0  6000 018C                284              BRA          LOAD_ADDRESSES
000012C4                           285  *-----------------------------------------------------------
000012C4                           286  
000012C4                           287  
000012C4                           288  
000012C4                           289  
000012C4                           290  
000012C4                           291  
000012C4                           292  
000012C4                           293  
000012C4                           294  *-----------------------------------------------------------
000012C4                           295  * Description:  
000012C4                           296  * Get User Input
000012C4                           297  *
000012C4                           298  * Registers Used:
000012C4                           299  *   D0 = task values
000012C4                           300  *   D1 = stores of size of ascii string in A1 from user input
000012C4                           301  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000012C4                           302  *   A1 = stores an ascii string from user input
000012C4                           303  *-----------------------------------------------------------
000012C4                           304  *-------------------------Get Input-------------------------
000012C4                           305  GET_INPUT:
000012C4                           306m             PRINT_MSG    startMsg
000012D0  6100 002C                307              BSR          GET_ADDRESS   
000012D4  21C7 1196                308              MOVE.L       D7, startAddr
000012D8                           309  
000012D8                           310m             CLR_D_REGS
000012E8                           311  
000012E8                           312m             PRINT_MSG    endMsg
000012F4  6100 0008                313              BSR          GET_ADDRESS   
000012F8  21C7 119A                314              MOVE.L       D7, endAddr
000012FC  4E75                     315              RTS 
000012FE                           316  *-----------------------------------------------------------
000012FE                           317  
000012FE                           318  *------------------------Get Address------------------------
000012FE                           319  GET_ADDRESS:
000012FE  43F8 118E                320              LEA.L   userAddr, A1
00001302  103C 0002                321              MOVE.B  #2, D0
00001306  4E4F                     322              TRAP    #15
00001308                           323  
00001308  6100 0008                324              BSR     CHECK_LENGTH
0000130C  6100 0054                325              BSR     CONVERT_TO_HEX
00001310  4E75                     326              RTS
00001312                           327  *-----------------------------------------------------------
00001312                           328  
00001312                           329  
00001312                           330  
00001312                           331  
00001312                           332  
00001312                           333  
00001312                           334  
00001312                           335  
00001312                           336  
00001312                           337  
00001312                           338  *-----------------------------------------------------------
00001312                           339  * Description:  Validate User Input
00001312                           340  * Constraints:  
00001312                           341  *   User input must be:
00001312                           342  *   Length 4 or Length 8
00001312                           343  *   ASCII character 0-9 or A-F
00001312                           344  *   Starting and ending address with value < $00FFFFFF 
00001312                           345  *   Starting address is before ending address
00001312                           346  *
00001312                           347  * Registers Used:
00001312                           348  *   D0 = task values
00001312                           349  *   D1 = stores of size of ascii string in A1 from user input
00001312                           350  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
00001312                           351  *   A1 = stores an ascii string from user input
00001312                           352  *-----------------------------------------------------------
00001312                           353  
00001312                           354  *----------------------VALIDATE INPUT---------------------------      
00001312                           355  CHECK_LENGTH:
00001312  B23C 0001                356              CMP.B      #1, D1               ; for task 2, length of string is in D1                
00001316  6D00 000C                357              BLT        INVALID_INPUT 
0000131A  B23C 0008                358              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
0000131E  6E00 0004                359              BGT        INVALID_INPUT
00001322  4E75                     360              RTS
00001324                           361  
00001324                           362  INVALID_INPUT:  
00001324                           363m             PRINT_MSG  badInput
00001330  6092                     364              BRA        GET_INPUT
00001332                           365  *-----------------------------------------------------------
00001332                           366  
00001332                           367  *----------------------VALIDATE INPUT---------------------------      
00001332                           368  CHECK_ADDRESS:
00001332  2A38 1196                369              MOVE.L     startAddr, D5
00001336  BAB8 119A                370              CMP.L      endAddr, D5          ; starting address >= ending address?
0000133A  6C00 0016                371              BGE        INVALID_ADDRESS
0000133E                           372  
0000133E  BABC 00006FFF            373              CMP.L      #$6FFF, D5
00001344  6FDE                     374              BLE        INVALID_INPUT 
00001346                           375              
00001346  0CB8 00FFFFFF 119A       376              CMP.L      #$FFFFFF, endAddr
0000134E  6CD4                     377              BGE        INVALID_INPUT
00001350  4E75                     378              RTS
00001352                           379  
00001352                           380  INVALID_ADDRESS:  
00001352                           381m             PRINT_MSG  badInput
0000135E  6000 FF64                382              BRA        GET_INPUT
00001362                           383  *-----------------------------------------------------------
00001362                           384  
00001362                           385  *----------------CONVERT FROM ASCII TO HEX------------------
00001362                           386  CONVERT_TO_HEX:
00001362  0C11 0030                387              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001366  6DBC                     388              BLT        INVALID_INPUT        
00001368                           389  
00001368  0C11 003A                390              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
0000136C  6D00 0012                391              BLT        NUM_TO_HEX      
00001370                           392  
00001370  0C11 0041                393              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001374  6DAE                     394              BLT        INVALID_INPUT             
00001376                           395  
00001376  0C11 0047                396              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
0000137A  6D00 000C                397              BLT        LETTER_TO_HEX
0000137E                           398  
0000137E  60A4                     399              BRA        INVALID_INPUT    
00001380                           400  
00001380                           401  NUM_TO_HEX:      
00001380  0411 0030                402              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001384  6000 000A                403              BRA        STORE_CHAR   
00001388                           404  
00001388                           405  LETTER_TO_HEX:     
00001388  0411 0037                406              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
0000138C  6000 0002                407              BRA        STORE_CHAR
00001390                           408  
00001390                           409  STORE_CHAR:       
00001390  D619                     410              ADD.B      (A1)+, D3           ; keep hex stored in D3           
00001392  6000 0002                411              BRA        ITERATE                 
00001396                           412  
00001396                           413  ITERATE:
00001396  5301                     414              SUB.B      #$1, D1
00001398  B23C 0000                415              CMP.B      #0, D1
0000139C  6700 0006                416              BEQ        STORE_INPUT
000013A0                           417  
000013A0  E98B                     418              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
000013A2  60BE                     419              BRA        CONVERT_TO_HEX
000013A4                           420  
000013A4                           421  STORE_INPUT:
000013A4  2E03                     422              MOVE.L     D3, D7
000013A6  4E75                     423              RTS
000013A8                           424  *-----------------------------------------------------------
000013A8                           425  
000013A8                           426  
000013A8                           427  
000013A8                           428  
000013A8                           429  
000013A8                           430  
000013A8                           431  
000013A8                           432  
000013A8                           433  
000013A8                           434  
000013A8                           435              
000013A8                           436  *--------------------------PRINT----------------------------
000013A8                           437  * Description:
000013A8                           438  * Prints hex addresses according to where we are in the .S file
000013A8                           439  * and source/destination effective addresses
000013A8                           440  *
000013A8                           441  * No Parameters
000013A8                           442  *
000013A8                           443  * Registers:
000013A8                           444  *   D0 = used for tasks and trap #15
000013A8                           445  *   D1 = size of comparison
000013A8                           446  *   D2 = destination for comparisons, holds an address
000013A8                           447  *   D3 = iterator
000013A8                           448  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000013A8                           449  *   A2 = current address (given by user)
000013A8                           450  *-----------------------------------------------------------
000013A8                           451  
000013A8                           452  *----------------------PRINT_ADDRESS------------------------
000013A8                           453  PRINT_ADDRESS:
000013A8                           454              * reset A1 to beginning of string
000013A8                           455m             CLR_D_REGS
000013B8                           456m             CLR_A_REG D0, A1
000013BC                           457              
000013BC                           458              * move current address to D2
000013BC  240A                     459              MOVE.L    A2, D2
000013BE                           460  
000013BE                           461              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
000013BE  223C 00008000            462              MOVE.L    #$8000, D1
000013C4  B481                     463              CMP.L     D1, D2
000013C6  6D00 000E                464              BLT       PRINT_WORD
000013CA                           465              
000013CA                           466              * if absolute long, print long. Range $8000 - $FFFF7FFF
000013CA  223C FFFF8000            467              MOVE.L    #$FFFF8000, D1
000013D0  B481                     468              CMP.L     D1, D2
000013D2  6C00 001C                469              BGE       PRINT_LONG                 
000013D6                           470  
000013D6                           471  PRINT_WORD:
000013D6                           472m             CLR_D_REGS
000013E6  123C 0001                473              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000013EA  3E0A                     474              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000013EC  6000 001C                475              BRA       FINISH_PRINT
000013F0                           476  
000013F0                           477  PRINT_LONG:
000013F0                           478m             CLR_D_REGS
00001400  123C 0003                479              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
00001404  2E0A                     480              MOVE.L    A2, D7
00001406  6000 0002                481              BRA       FINISH_PRINT
0000140A                           482  
0000140A                           483  FINISH_PRINT:
0000140A                           484              * convert hex values back to ASCII
0000140A  4EB9 00001E2A            485              JSR       HEX_TO_ASCII
00001410                           486              
00001410                           487              * print out string
00001410  12BC 0000                488              MOVE.B    #00,(A1)
00001414                           489m             CLR_D_REGS
00001424                           490m             CLR_A_REG D0, A1
00001428  103C 000E                491              MOVE.B    #14, D0
0000142C  4E4F                     492              TRAP      #15
0000142E  4E75                     493              RTS
00001430                           494  *-----------------------------------------------------------
00001430                           495  
00001430                           496  *-------------------PRINT_INSTRUCTION-----------------------
00001430                           497  PRINT_INSTRUCTION:    
00001430                           498              * null terminator
00001430  12BC 0000                499              MOVE.B    #00,(A1)              
00001434                           500  
00001434                           501              * reset A1 to beginning of string
00001434  4280                     502              CLR.L     D0
00001436                           503m             CLR_A_REG D0, A1
0000143A                           504  
0000143A                           505              * print out string
0000143A  103C 000E                506              MOVE.B    #14, D0
0000143E  4E4F                     507              TRAP      #15
00001440                           508  
00001440                           509m             PRINT_MSG newline
0000144C  4E75                     510              RTS
0000144E                           511  *-----------------------------------------------------------
0000144E                           512  
0000144E                           513  
0000144E                           514  
0000144E                           515  
0000144E                           516  
0000144E                           517  
0000144E                           518  
0000144E                           519  
0000144E                           520  
0000144E                           521  
0000144E                           522  
0000144E                           523  
0000144E                           524  
0000144E                           525  
0000144E                           526  
0000144E                           527  
0000144E                           528  
0000144E                           529  
0000144E                           530  
0000144E                           531  
0000144E                           532  *---------------------LOAD ADDRESSES------------------------
0000144E                           533  * Description:
0000144E                           534  * Stores INITIAL values into appropriate address registers 
0000144E                           535  * which is necessary to complete before starting identify opcodes loop
0000144E                           536  * Also pushes reigsters onto the stack
0000144E                           537  *
0000144E                           538  * No Parameters
0000144E                           539  *
0000144E                           540  * Registers:
0000144E                           541  *   A2 = current address (given by user)
0000144E                           542  *   A3 = ending address (given by user)
0000144E                           543  *-----------------------------------------------------------
0000144E                           544  LOAD_ADDRESSES: 
0000144E                           545              * reset A1 to beginning of string
0000144E  4280                     546              CLR.L       D0
00001450                           547m             CLR_A_REG   D0, A1
00001454                           548  
00001454                           549              * load start and end registers and print starting address
00001454  2478 1196                550              MOVEA.L     startAddr, A2
00001458  2678 119A                551              MOVEA.L     endAddr, A3
0000145C  6100 FF4A                552              BSR         PRINT_ADDRESS
00001460                           553m             INSERT_SPACE
00001464                           554  
00001464  6100 0040                555              BSR         GRAB_NEXT_WORD
00001468  6100 0042                556              BSR         GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
0000146C                           557  
0000146C                           558              * Push current registers onto the stack (so we can have fresh registers)
0000146C  48E7 FF00                559              MOVEM.L D0-D7,-(SP)                  ; move the old registers onto the stack
00001470  6000 004C                560              BRA     FIND_OPCODE
00001474                           561  *-----------------------------------------------------------
00001474                           562  
00001474                           563  *-----------------------------------------------------------
00001474                           564  * Description:  IDENTIFY OPCODES LOOP
00001474                           565  * Registers:
00001474                           566  *   D0 = used for tasks and trap #15
00001474                           567  *   D1 = size of shifting bits
00001474                           568  *   D2 = destination for shifts
00001474                           569  *   D3 = size of opcode
00001474                           570  *   D4 = used to hold bits returned from SHIFT macro
00001474                           571  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001474                           572  *   A2 = current address (given by user)
00001474                           573  *   A3 = ending address (given by user)
00001474                           574  *-----------------------------------------------------------
00001474                           575  *-------------------IDENTIFY OPCODES------------------------
00001474                           576  * evaluates an opcode based on first four bits (aka opTag)
00001474                           577  * for now only works with one instruction
00001474                           578  *-----------------------------------------------------------
00001474                           579  IDENTIFY_OPCODE:
00001474                           580  
00001474                           581              * print opcode
00001474  61BA                     582              BSR     PRINT_INSTRUCTION
00001476                           583  
00001476                           584              * check if starting address >= ending address
00001476  B5CB                     585              CMPA.L  A3, A2
00001478  6C00 0A56                586              BGE     DONE
0000147C                           587              
0000147C                           588              * print next address
0000147C  6100 FF2A                589              BSR     PRINT_ADDRESS
00001480                           590m             INSERT_SPACE
00001484                           591              
00001484                           592              ;BSR     RESTORE_REGS           need to fix
00001484                           593  
00001484                           594m             CLR_D_REGS
00001494  6100 0010                595              BSR     GRAB_NEXT_WORD          * grab opcode
00001498  6100 0012                596              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
0000149C                           597             
0000149C  6000 0020                598              BRA     FIND_OPCODE
000014A0                           599  *------------------------------------------------------------
000014A0                           600  
000014A0                           601  *----------------------RESTORE_REGS--------------------------
000014A0                           602  * Description:
000014A0                           603  * Move the old registers onto the stack
000014A0                           604  *------------------------------------------------------------
000014A0                           605  RESTORE_REGS:
000014A0  4CDF 00FF                606              MOVEM.L (SP)+, D0-D7            
000014A4  4E75                     607              RTS
000014A6                           608  *-----------------------------------------------------------
000014A6                           609  
000014A6                           610  *---------Useful Subroutines For Identifying Opcodes--------
000014A6                           611  GRAB_NEXT_WORD:
000014A6                           612              * load current word of bits into D7
000014A6  31DA 119E                613              MOVE.W (A2)+, opcode
000014AA  4E75                     614              RTS
000014AC                           615  
000014AC                           616  GRAB_FIRST_FOUR_BITS:
000014AC                           617              * find first four bits of opcode
000014AC  3438 119E                618              MOVE.W  opcode, D2
000014B0  123C 000C                619              MOVE.B  #12, D1
000014B4  E2AA                     620              LSR.L   D1, D2
000014B6  1002                     621              MOVE.B  D2, D0
000014B8  11C0 11A0                622              MOVE.B  D0, opTag
000014BC  4E75                     623              RTS
000014BE                           624  *-----------------------------------------------------------
000014BE                           625  
000014BE                           626  
000014BE                           627  
000014BE                           628  
000014BE                           629  
000014BE                           630  
000014BE                           631  
000014BE                           632  
000014BE                           633  
000014BE                           634  *----------------------FIND OPCODE--------------------------
000014BE                           635  * Description:
000014BE                           636  * Finds a matching opTag (first four bits of opcode) and 
000014BE                           637  * jumps to that opcode's encoding subroutine
000014BE                           638  *
000014BE                           639  * For example:
000014BE                           640  *               ADD's first four bits = 1101, so I put
000014BE                           641  *               CMP.B #%1101, D0
000014BE                           642  *
000014BE                           643  * No Parameters
000014BE                           644  *
000014BE                           645  * No Registers Used
000014BE                           646  *-----------------------------------------------------------        
000014BE                           647  FIND_OPCODE:
000014BE  0C38 0000 11A0           648              CMP.B   #%0000, opTag 
000014C4  6700 0070                649              BEQ     OPC_0000
000014C8                           650  
000014C8  0C38 0001 11A0           651              CMP.B   #%0001, opTag 
000014CE  6700 0162                652              BEQ     OPC_0001
000014D2                           653  
000014D2  0C38 0002 11A0           654              CMP.B   #%0010, opTag 
000014D8  6700 0182                655              BEQ     OPC_0010
000014DC                           656  
000014DC  0C38 0003 11A0           657              CMP.B   #%0011, opTag 
000014E2  6700 01A2                658              BEQ     OPC_0011
000014E6                           659  
000014E6  0C38 0004 11A0           660              CMP.B   #%0100, opTag 
000014EC  6700 0208                661              BEQ     OPC_0100
000014F0                           662              
000014F0  0C38 0006 11A0           663              CMP.B   #%0110, opTag
000014F6  6700 04A4                664              BEQ     OPC_0110
000014FA                           665  
000014FA  0C38 0005 11A0           666              CMP.B   #%0101, opTag 
00001500  6700 038C                667              BEQ     OPC_0101
00001504                           668  
00001504  0C38 0008 11A0           669              CMP.B   #%1000, opTag
0000150A  6700 0350                670              BEQ     OPC_1000
0000150E                           671  
0000150E  0C38 0009 11A0           672              CMP.B   #%1001, opTag
00001514  6700 0622                673              BEQ     OPC_1001
00001518                           674  
00001518  0C38 000C 11A0           675              CMP.B   #%1100, opTag
0000151E  6700 062C                676              BEQ     OPC_1100
00001522                           677  
00001522  0C38 000D 11A0           678              CMP.B   #%1101, opTag
00001528  6700 069A                679              BEQ     OPC_1101
0000152C                           680  
0000152C                           681              * error, bad opcode
0000152C  6000 0002                682              BRA      BAD_OPCODE
00001530                           683  
00001530                           684  *-----------------------------------------------------------
00001530                           685  
00001530                           686  *-----------------------BAD OPCODE--------------------------
00001530                           687  BAD_OPCODE:
00001530  4EF9 00001ED0            688              JMP      DONE
00001536                           689  *-----------------------------------------------------------
00001536                           690  
00001536                           691  *------------------------OPC_0000---------------------------
00001536                           692  * First four bits = 0000
00001536                           693  * (ADDI, SUBI)
00001536                           694  *-----------------------------------------------------------
00001536                           695  OPC_0000:
00001536                           696m             GET_BITS  #11, #8
00001546                           697m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000154E                           698m             * GET HIGH BIT OFFSET
00001556                           699m             * SHIFT OUT HIGH BITS
0000155C                           700m             *GET LOW BIT OFFSET
0000155C                           701m             *16 - NUMBER OF BITS WE WANT
00001562                           702m             * SHIFT OUT LOW BITS
00001564                           703              
00001564                           704              * is the opcode ADDI?
00001564  B83C 0006                705              CMP.B     #%0110, D4
00001568  6700 000E                706              BEQ       OPC_ADDI
0000156C                           707  
0000156C                           708              * is the opcode SUBI?
0000156C  B83C 0004                709              CMP.B     #%0100, D4
00001570  6700 001E                710              BEQ       OPC_SUBI
00001574                           711  
00001574  4EF8 1530                712              JMP       BAD_OPCODE
00001578                           713  
00001578                           714  *------------------------OPC_ADDI---------------------------
00001578                           715  OPC_ADDI:
00001578  12FC 0041                716              MOVE.B  #'A',(A1)+          * Put ADD into Buff
0000157C  12FC 0044                717              MOVE.B  #'D',(A1)+
00001580  12FC 0044                718              MOVE.B  #'D',(A1)+
00001584  12FC 0049                719              MOVE.B  #'I',(A1)+
00001588                           720m             INSERT_PERIOD
0000158C                           721  
0000158C  6100 001A                722              BSR     DECODE_IMMEDIATE
00001590                           723  
00001590                           724  *------------------------OPC_SUBI---------------------------
00001590                           725  OPC_SUBI:            
00001590  12FC 0053                726              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001594  12FC 0055                727              MOVE.B  #'U',(A1)+
00001598  12FC 0042                728              MOVE.B  #'B',(A1)+
0000159C  12FC 0049                729              MOVE.B  #'I',(A1)+
000015A0                           730m             INSERT_PERIOD
000015A4                           731  
000015A4  6100 0002                732              BSR     DECODE_IMMEDIATE
000015A8                           733  
000015A8                           734  *--------------Subroutines for OPC_0000---------------------  
000015A8                           735  DECODE_IMMEDIATE:
000015A8                           736              * push size to buffer
000015A8                           737m             GET_BITS        #7, #6              * get size bits (gets returned to D4)
000015B8                           738m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000015BE                           739m             * GET HIGH BIT OFFSET
000015C4                           740m             * SHIFT OUT HIGH BITS
000015CA                           741m             *GET LOW BIT OFFSET
000015CA                           742m             *16 - NUMBER OF BITS WE WANT
000015D0                           743m             * SHIFT OUT LOW BITS
000015D2  11C4 11A1                744              MOVE.B          D4, opSize
000015D6                           745m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000015DE                           746  
000015DE                           747              * push #<data> to buffer
000015DE  4EB9 0000160E            748              JSR             CHECK_IMMEDIATE
000015E4                           749  
000015E4                           750m             INSERT_COMMA
000015E8                           751m             INSERT_SPACE
000015EC                           752  
000015EC                           753              * push <ea> to buffer
000015EC                           754m             DECODE_EA       #5, #0
0000160A  6000 FE68                755              BRA             IDENTIFY_OPCODE
0000160E                           756   
0000160E                           757  CHECK_IMMEDIATE:
0000160E                           758m             INSERT_POUND
00001612                           759  
00001612  B67C 0001                760              CMP     #1, D3
00001616  6F00 000A                761              BLE     IMMEDIATE_WORD
0000161A                           762  
0000161A  B67C 0002                763              CMP     #2, D3
0000161E  6000 000A                764              BRA     IMMEDIATE_LONG
00001622                           765  
00001622                           766  IMMEDIATE_WORD:
00001622  4EB9 00001DDE            767              JSR     EA_WORD
00001628  4E75                     768              RTS
0000162A                           769  
0000162A                           770  IMMEDIATE_LONG:
0000162A  4EB9 00001DF2            771              JSR     EA_LONG      
00001630  4E75                     772              RTS
00001632                           773  *-----------------------------------------------------------
00001632                           774  
00001632                           775  *------------------------OPC_0001---------------------------
00001632                           776  * First four bits = 0001
00001632                           777  * (MOVE.B)
00001632                           778  *-----------------------------------------------------------
00001632                           779  OPC_0001:
00001632  12FC 004D                780              MOVE.B   #'M',(A1)+          * Put ADD into Buff
00001636  12FC 004F                781              MOVE.B   #'O',(A1)+
0000163A  12FC 0056                782              MOVE.B   #'V',(A1)+
0000163E  12FC 0045                783              MOVE.B   #'E',(A1)+
00001642  12FC 002E                784              MOVE.B   #'.',(A1)+
00001646  12FC 0042                785              MOVE.B   #'B',(A1)+
0000164A                           786m             INSERT_SPACE
0000164E                           787  
0000164E  11FC 0000 11A1           788              MOVE.B   #0, opSize
00001654                           789  
00001654  6100 005A                790              BSR      DECODE_MOVE
00001658  6000 FE1A                791              BRA      IDENTIFY_OPCODE
0000165C                           792  *-----------------------------------------------------------
0000165C                           793  
0000165C                           794  *------------------------OPC_0010---------------------------
0000165C                           795  * First four bits = 0010
0000165C                           796  * (MOVE.L)
0000165C                           797  *-----------------------------------------------------------
0000165C                           798  OPC_0010:
0000165C  12FC 004D                799              MOVE.B  #'M',(A1)+          * Put ADD into Buff
00001660  12FC 004F                800              MOVE.B  #'O',(A1)+
00001664  12FC 0056                801              MOVE.B  #'V',(A1)+
00001668  12FC 0045                802              MOVE.B  #'E',(A1)+
0000166C  12FC 002E                803              MOVE.B  #'.',(A1)+
00001670  12FC 004C                804              MOVE.B  #'L',(A1)+
00001674                           805m             INSERT_SPACE
00001678                           806  
00001678  11FC 0002 11A1           807              MOVE.B   #2, opSize
0000167E                           808  
0000167E  6100 0030                809              BSR      DECODE_MOVE
00001682  6000 FDF0                810              BRA      IDENTIFY_OPCODE
00001686                           811  *-----------------------------------------------------------
00001686                           812  
00001686                           813  *------------------------OPC_0011---------------------------
00001686                           814  * First four bits = 0011
00001686                           815  * (MOVE.W)
00001686                           816  *-----------------------------------------------------------
00001686                           817  OPC_0011:
00001686  12FC 004D                818              MOVE.B  #'M',(A1)+          * Put ADD into Buff
0000168A  12FC 004F                819              MOVE.B  #'O',(A1)+
0000168E  12FC 0056                820              MOVE.B  #'V',(A1)+
00001692  12FC 0045                821              MOVE.B  #'E',(A1)+
00001696  12FC 002E                822              MOVE.B  #'.',(A1)+
0000169A  12FC 0057                823              MOVE.B  #'W',(A1)+
0000169E                           824m             INSERT_SPACE
000016A2                           825  
000016A2  11FC 0001 11A1           826              MOVE.B   #1, opSize
000016A8                           827  
000016A8  6100 0006                828              BSR      DECODE_MOVE
000016AC  6000 FDC6                829              BRA      IDENTIFY_OPCODE
000016B0                           830  *-----------------------------------------------------------
000016B0                           831  
000016B0                           832  *---------------------Decode Move---------------------------
000016B0                           833  DECODE_MOVE:
000016B0                           834m             DECODE_EA       #5, #0
000016CE                           835              
000016CE                           836m             INSERT_COMMA
000016D2                           837m             INSERT_SPACE
000016D6                           838  
000016D6                           839m             DECODE_EA       #11, #6
000016F4  4E75                     840              RTS
000016F6                           841  *-----------------------------------------------------------
000016F6                           842  
000016F6                           843  *------------------------OPC_0100---------------------------
000016F6                           844  * First four bits = 0100
000016F6                           845  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
000016F6                           846  *-----------------------------------------------------------
000016F6                           847  OPC_0100:
000016F6                           848  
000016F6                           849              * Check if the opcode is NOP
000016F6  3438 119E                850              MOVE.W  opcode, D2              * Copy opcode to D2
000016FA  B47C 4E71                851              CMP.W   #$4E71, D2              * Check if D2 is equal to NOP (0x4E71 in hex)
000016FE  6700 0054                852              BEQ     OPC_NOP                 * If equal branch to label to handle the opcode NOP
00001702                           853              
00001702                           854              * Check if the opcode is NOT
00001702  E082                     855              ASR.L   #8, D2                  * Shift bits to compare
00001704  B43C 0046                856              CMP.B   #%01000110, D2
00001708  6700 005A                857              BEQ     OPC_NOT
0000170C  4282                     858              CLR.L   D2
0000170E                           859              
0000170E                           860              * Check if the opcode is LEA
0000170E  3838 119E                861              MOVE.W   opcode, D4             * Put opcode in D4 to use the macro get bits
00001712                           862m             GET_BITS #8, #6 
00001722                           863m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001728                           864m             * GET HIGH BIT OFFSET
0000172E                           865m             * SHIFT OUT HIGH BITS
00001734                           866m             *GET LOW BIT OFFSET
00001734                           867m             *16 - NUMBER OF BITS WE WANT
0000173A                           868m             * SHIFT OUT LOW BITS
0000173C  B83C 0007                869              CMP.B    #%0111, D4              * if bits 6-8 are equal to 111, then the opocde is LEA
00001740  6700 008A                870              BEQ      OPC_LEA
00001744                           871  
00001744                           872              * Check if the opcode is JSR
00001744  B83C 0002                873              CMP.B   #%0010, D4              * if bits 6-8 are equal to 010, then the opocde is LEA
00001748  6700 00D0                874              BEQ     OPC_JSR
0000174C                           875  
0000174C                           876              * Check if the opcode is RTS
0000174C  B83C 0001                877              CMP.B   #%0001, D4              * if bits 6-8 are equal to 001, then the opocde is LEA
00001750  6700 00FA                878              BEQ     OPC_RTS
00001754                           879  
00001754                           880  *---------------------------OPC_NOP--------------------------------
00001754                           881  
00001754                           882  OPC_NOP:
00001754                           883              * Put NOP into A1 buffer for printing
00001754  12FC 004E                884              MOVE.B  #'N',(A1)+      
00001758  12FC 004F                885              MOVE.B  #'O',(A1)+ 
0000175C  12FC 0050                886              MOVE.B  #'P',(A1)+ 
00001760                           887              
00001760  6000 FD12                888              BRA     IDENTIFY_OPCODE
00001764                           889  
00001764                           890  
00001764                           891  *-----------------------------OPC_NOT------------------------------
00001764                           892  
00001764                           893  OPC_NOT:
00001764                           894              * Put NOT into A1 buffer for printing
00001764  12FC 004E                895              MOVE.B  #'N',(A1)+ 
00001768  12FC 004F                896              MOVE.B  #'O',(A1)+
0000176C  12FC 0054                897              MOVE.B  #'T',(A1)+
00001770                           898m             INSERT_PERIOD
00001774                           899              
00001774                           900              * Calculate Size (.b,.w.l)
00001774                           901m             GET_BITS        #7, #6
00001784                           902m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000178A                           903m             * GET HIGH BIT OFFSET
00001790                           904m             * SHIFT OUT HIGH BITS
00001796                           905m             *GET LOW BIT OFFSET
00001796                           906m             *16 - NUMBER OF BITS WE WANT
0000179C                           907m             * SHIFT OUT LOW BITS
0000179E  11C4 11A1                908              MOVE.B          D4, opSize
000017A2                           909m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000017AA                           910m             DECODE_EA       #5, #0
000017C8  6000 FCAA                911              BRA             IDENTIFY_OPCODE
000017CC                           912  
000017CC                           913  *-----------------------------OPC_LEA------------------------------
000017CC                           914  OPC_LEA:
000017CC                           915              * Put LEA into A1 buffer for printing
000017CC  12FC 004C                916              MOVE.B  #'L',(A1)+      
000017D0  12FC 0045                917              MOVE.B  #'E',(A1)+ 
000017D4  12FC 0041                918              MOVE.B  #'A',(A1)+
000017D8                           919m             INSERT_PERIOD
000017DC  12FC 004C                920              MOVE.B  #'L',(A1)+ 
000017E0                           921m             INSERT_SPACE
000017E4                           922  
000017E4  11FC 0002 11A1           923              MOVE.B          #2, opSize      * required to always be long operation
000017EA                           924                      
000017EA                           925m             DECODE_EA       #5, #0
00001808                           926m             INSERT_COMMA
0000180C                           927m             INSERT_SPACE
00001810  4EB9 00001CB0            928              JSR GET_DATA_REG_NUM
00001816                           929  
00001816  6000 FC5C                930              BRA IDENTIFY_OPCODE    
0000181A                           931  
0000181A                           932  
0000181A                           933  *-----------------------------------------------------------
0000181A                           934  
0000181A                           935  *-----------------------------OPC_JSR------------------------------
0000181A                           936  OPC_JSR:
0000181A                           937              * Put LEA into A1 buffer for printing
0000181A  12FC 004A                938              MOVE.B  #'J',(A1)+      
0000181E  12FC 0053                939              MOVE.B  #'S',(A1)+ 
00001822  12FC 0052                940              MOVE.B  #'R',(A1)+
00001826                           941m             INSERT_SPACE
0000182A                           942              
0000182A                           943m             DECODE_EA       #5, #0
00001848  6000 FC2A                944              BRA             IDENTIFY_OPCODE  
0000184C                           945  
0000184C                           946  *-----------------------------OPC_RTS------------------------------
0000184C                           947  OPC_RTS:
0000184C                           948              * Put LEA into A1 buffer for printing
0000184C  12FC 0052                949              MOVE.B  #'R',(A1)+      
00001850  12FC 0054                950              MOVE.B  #'T',(A1)+ 
00001854  12FC 0053                951              MOVE.B  #'S',(A1)+
00001858                           952          
00001858  6000 FC1A                953              BRA IDENTIFY_OPCODE
0000185C                           954  
0000185C                           955  *-----------------------------------------------------------
0000185C                           956  
0000185C                           957  *---------------------------OPC_1000------------------------
0000185C                           958  * First four bits = 1001
0000185C                           959  * (DIVU)
0000185C                           960  *-----------------------------------------------------------
0000185C                           961  OPC_1000:   * keeping this in case there's more that start with 1000
0000185C  6000 0002                962              BRA     OPC_DIVU
00001860                           963              
00001860                           964  OPC_DIVU:
00001860  12FC 0044                965              MOVE.B  #'D',(A1)+
00001864  12FC 0049                966              MOVE.B  #'I',(A1)+
00001868  12FC 0056                967              MOVE.B  #'V',(A1)+
0000186C  12FC 0055                968              MOVE.B  #'U',(A1)+
00001870                           969m             INSERT_PERIOD
00001874  12FC 0057                970              MOVE.B  #'W',(A1)+  * always size word
00001878                           971m             INSERT_SPACE
0000187C                           972  
0000187C  11FC 0001 11A1           973              MOVE.B  #1, opSize
00001882                           974              
00001882                           975              * set the valid bits (since there's only one adressing mode)
00001882  11FC 00BF 11A2           976              MOVE.B  #%10111111, valid
00001888                           977              
00001888  4EF9 00001C78            978              JMP     EA_TO_D
0000188E                           979  
0000188E                           980  *-----------------------------------------------------------
0000188E                           981  
0000188E                           982  
0000188E                           983  
0000188E                           984  *-----------------------OPC_0101----------------------------
0000188E                           985  * First four bits = 0101
0000188E                           986  * (ADDQ, SUBQ)
0000188E                           987  *-----------------------------------------------------------
0000188E                           988  OPC_0101:
0000188E                           989m             GET_BITS  #8, #8
0000189E                           990m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000018A4                           991m             * GET HIGH BIT OFFSET
000018AA                           992m             * SHIFT OUT HIGH BITS
000018B0                           993m             *GET LOW BIT OFFSET
000018B0                           994m             *16 - NUMBER OF BITS WE WANT
000018B6                           995m             * SHIFT OUT LOW BITS
000018B8                           996              
000018B8                           997              * is the opcode ADDQ?
000018B8  B83C 0000                998              CMP.B     #%0000, D4
000018BC  6700 000E                999              BEQ       OPC_ADDQ
000018C0                          1000  
000018C0                          1001              * is the opcode SUBI?
000018C0  B83C 0001               1002              CMP.B     #%0001, D4
000018C4  6700 001E               1003              BEQ       OPC_SUBQ
000018C8                          1004  
000018C8  4EF8 1530               1005              JMP       BAD_OPCODE
000018CC                          1006  
000018CC                          1007  *------------------------OPC_ADDQ---------------------------
000018CC                          1008  OPC_ADDQ:
000018CC  12FC 0041               1009              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000018D0  12FC 0044               1010              MOVE.B  #'D',(A1)+
000018D4  12FC 0044               1011              MOVE.B  #'D',(A1)+
000018D8  12FC 0051               1012              MOVE.B  #'Q',(A1)+
000018DC                          1013m             INSERT_PERIOD
000018E0                          1014  
000018E0  6100 001A               1015              BSR     DECODE_QUICK
000018E4                          1016  
000018E4                          1017  *------------------------OPC_SUBI---------------------------
000018E4                          1018  OPC_SUBQ:            
000018E4  12FC 0053               1019              MOVE.B  #'S',(A1)+          * Put ADD into Buff
000018E8  12FC 0055               1020              MOVE.B  #'U',(A1)+
000018EC  12FC 0042               1021              MOVE.B  #'B',(A1)+
000018F0  12FC 0051               1022              MOVE.B  #'Q',(A1)+
000018F4                          1023m             INSERT_PERIOD
000018F8                          1024  
000018F8  6100 0002               1025              BSR     DECODE_QUICK
000018FC                          1026  
000018FC                          1027  *------------------Subroutines for OPC_0101-----------------
000018FC                          1028  DECODE_QUICK:            
000018FC                          1029              * Get size of operation and push to buffer
000018FC  4284                    1030              CLR.L           D4
000018FE                          1031m             GET_BITS        #7, #6
0000190E                          1032m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001914                          1033m             * GET HIGH BIT OFFSET
0000191A                          1034m             * SHIFT OUT HIGH BITS
00001920                          1035m             *GET LOW BIT OFFSET
00001920                          1036m             *16 - NUMBER OF BITS WE WANT
00001926                          1037m             * SHIFT OUT LOW BITS
00001928  11C4 11A1               1038              MOVE.B          D4, opSize
0000192C                          1039m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001934                          1040  
00001934                          1041              * push value of #<data> to buffer
00001934  4284                    1042              CLR.L            D4
00001936                          1043m             GET_BITS         #11, #9
00001946                          1044m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001950                          1045m             * GET HIGH BIT OFFSET
00001958                          1046m             * SHIFT OUT HIGH BITS
0000195E                          1047m             *GET LOW BIT OFFSET
0000195E                          1048m             *16 - NUMBER OF BITS WE WANT
00001964                          1049m             * SHIFT OUT LOW BITS
00001966                          1050m             INSERT_POUND
0000196A                          1051m             VALUE_TO_BUFFER  D4
00001972                          1052  
00001972                          1053m             INSERT_COMMA
00001976                          1054m             INSERT_SPACE
0000197A                          1055  
0000197A                          1056              * push <ea> to buffer
0000197A                          1057m             DECODE_EA       #5, #0
00001998  6000 FADA               1058              BRA             IDENTIFY_OPCODE
0000199C                          1059  *-----------------------------------------------------------
0000199C                          1060  
0000199C                          1061  
0000199C                          1062  *-----------------------OPC_0110----------------------------
0000199C                          1063  * First four bits = 0110
0000199C                          1064  * BRA or Bcc condtions
0000199C                          1065  *-----------------------------------------------------------
0000199C                          1066  OPC_0110:
0000199C                          1067m             GET_BITS #12, #8
000019AC                          1068m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019B4                          1069m             * GET HIGH BIT OFFSET
000019BC                          1070m             * SHIFT OUT HIGH BITS
000019C2                          1071m             *GET LOW BIT OFFSET
000019C2                          1072m             *16 - NUMBER OF BITS WE WANT
000019C8                          1073m             * SHIFT OUT LOW BITS
000019CA  B83C 0000               1074              CMP.B   #0,D4 *Check if opcode is BRA
000019CE  6700 00DE               1075              BEQ     OPC_BRA
000019D2                          1076              
000019D2                          1077m             GET_BITS #11, #8 *Check if opcode is a Bcc condition
000019E2                          1078m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019EA                          1079m             * GET HIGH BIT OFFSET
000019F2                          1080m             * SHIFT OUT HIGH BITS
000019F8                          1081m             *GET LOW BIT OFFSET
000019F8                          1082m             *16 - NUMBER OF BITS WE WANT
000019FE                          1083m             * SHIFT OUT LOW BITS
00001A00                          1084              
00001A00  B83C 000D               1085              CMP.B   #%1101, D4 *Check if opcode is BLT
00001A04  6700 0016               1086              BEQ     BLT
00001A08                          1087              
00001A08  B83C 000C               1088              CMP.B   #%1100, D4 *Check if opcode is BGE
00001A0C  6700 0022               1089              BEQ     BGE
00001A10                          1090              
00001A10  B83C 0007               1091              CMP.B   #%0111, D4 *Check if opcode is BEQ
00001A14  6700 002E               1092              BEQ     BEQ
00001A18                          1093              
00001A18  4EF8 1530               1094              JMP     BAD_OPCODE *If no match if found, we have an error
00001A1C                          1095              
00001A1C                          1096              
00001A1C                          1097              
00001A1C                          1098  BLT:
00001A1C  12FC 0042               1099              MOVE.B  #'B',(A1)+          * Put BLT into Buff
00001A20  12FC 004C               1100              MOVE.B  #'L',(A1)+
00001A24  12FC 0054               1101              MOVE.B  #'T',(A1)+
00001A28  12FC 002E               1102              MOVE.B  #'.',(A1)+
00001A2C  6000 002A               1103              BRA     BCC_DISPLACEMENT
00001A30                          1104  
00001A30                          1105  BGE:
00001A30  12FC 0042               1106              MOVE.B  #'B',(A1)+          * Put BGE into Buff
00001A34  12FC 0047               1107              MOVE.B  #'G',(A1)+
00001A38  12FC 0045               1108              MOVE.B  #'E',(A1)+
00001A3C  12FC 002E               1109              MOVE.B  #'.',(A1)+
00001A40  6000 0016               1110              BRA     BCC_DISPLACEMENT
00001A44                          1111  
00001A44                          1112  BEQ:
00001A44  12FC 0042               1113              MOVE.B  #'B',(A1)+          * Put BEQ into Buff
00001A48  12FC 0045               1114              MOVE.B  #'E',(A1)+
00001A4C  12FC 0051               1115              MOVE.B  #'Q',(A1)+
00001A50  12FC 002E               1116              MOVE.B  #'.',(A1)+
00001A54  6000 0002               1117              BRA     BCC_DISPLACEMENT
00001A58                          1118  
00001A58                          1119  BCC_DISPLACEMENT:
00001A58                          1120m             GET_BITS #7,#0 *Get displacement bits
00001A68                          1121m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001A70                          1122m             * GET HIGH BIT OFFSET
00001A76                          1123m             * SHIFT OUT HIGH BITS
00001A7C                          1124m             *GET LOW BIT OFFSET
00001A7C                          1125m             *16 - NUMBER OF BITS WE WANT
00001A82                          1126m             * SHIFT OUT LOW BITS
00001A84                          1127              
00001A84  B83C 0000               1128              CMP.B   #0,D4 *Check if we have 16 bit dispalcement, branch if true
00001A88  6700 008A               1129              BEQ     SIXTEEN_BIT_DISPLACEMENT
00001A8C                          1130              
00001A8C  12FC 0042               1131              MOVE.B  #'B',(A1)+
00001A90                          1132m             INSERT_SPACE 
00001A94  12FC 0024               1133              MOVE.B  #'$',(A1)+
00001A98                          1134              
00001A98  2E0A                    1135              MOVE.L  A2,D7  *Get the current address
00001A9A                          1136              
00001A9A  4884                    1137              EXT.W   D4 *Sign extend to long for addition
00001A9C  48C4                    1138              EXT.L   D4 *Sign extend again, must extend from byte to word and then word to long
00001A9E  DE84                    1139              ADD.L   D4,D7  *Add the displacement
00001AA0                          1140  
00001AA0  123C 0003               1141              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001AA4  4EB9 00001E2A           1142              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001AAA                          1143              
00001AAA  6000 F9C8               1144              BRA IDENTIFY_OPCODE   
00001AAE                          1145  
00001AAE                          1146               
00001AAE                          1147                         
00001AAE                          1148  OPC_BRA:
00001AAE  12FC 0042               1149              MOVE.B  #'B',(A1)+          * Put BRA into Buff
00001AB2  12FC 0052               1150              MOVE.B  #'R',(A1)+
00001AB6  12FC 0041               1151              MOVE.B  #'A',(A1)+
00001ABA  12FC 002E               1152              MOVE.B  #'.',(A1)+
00001ABE                          1153              
00001ABE                          1154m             GET_BITS #7,#0 *Get displacement bits
00001ACE                          1155m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001AD6                          1156m             * GET HIGH BIT OFFSET
00001ADC                          1157m             * SHIFT OUT HIGH BITS
00001AE2                          1158m             *GET LOW BIT OFFSET
00001AE2                          1159m             *16 - NUMBER OF BITS WE WANT
00001AE8                          1160m             * SHIFT OUT LOW BITS
00001AEA                          1161              
00001AEA  B83C 0000               1162              CMP.B   #0,D4 *Check if we have 16 bit dispalcement, branch if true
00001AEE  6700 0024               1163              BEQ     SIXTEEN_BIT_DISPLACEMENT
00001AF2                          1164             
00001AF2  12FC 0042               1165              MOVE.B  #'B',(A1)+
00001AF6                          1166m             INSERT_SPACE 
00001AFA  12FC 0024               1167              MOVE.B  #'$',(A1)+
00001AFE                          1168              
00001AFE  2E0A                    1169              MOVE.L  A2,D7  *Get the current address
00001B00                          1170              
00001B00  4884                    1171              EXT.W   D4 *Sign extend to long for addition
00001B02  48C4                    1172              EXT.L   D4 *Sign extend again, must extend from byte to word and then word to long
00001B04  DE84                    1173              ADD.L   D4,D7  *Add the displacement
00001B06                          1174  
00001B06  123C 0003               1175              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001B0A  4EB9 00001E2A           1176              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001B10                          1177              
00001B10  6000 F962               1178              BRA IDENTIFY_OPCODE   
00001B14                          1179              
00001B14                          1180  SIXTEEN_BIT_DISPLACEMENT: 
00001B14  12FC 0057               1181              MOVE.B  #'W',(A1)+
00001B18                          1182m             INSERT_SPACE 
00001B1C  12FC 0024               1183              MOVE.B  #'$',(A1)+
00001B20                          1184              
00001B20  2E0A                    1185              MOVE.L  A2,D7  *Get the current address
00001B22                          1186              
00001B22  4284                    1187              CLR.L D4 *Clear the contents of D4
00001B24  381A                    1188              MOVE.W  (A2)+,D4 *Increment A2 to get 16 bit displacement value
00001B26                          1189              
00001B26  48C4                    1190              EXT.L   D4  *Sign extend to long for addition
00001B28  DE84                    1191              ADD.L   D4,D7  *Add the displacement 
00001B2A                          1192                        
00001B2A  123C 0003               1193              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001B2E  4EB9 00001E2A           1194              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001B34                          1195              
00001B34  6000 F93E               1196              BRA IDENTIFY_OPCODE 
00001B38                          1197              
00001B38                          1198  
00001B38                          1199  *-----------------------OPC_1001----------------------------
00001B38                          1200  * First four bits = 1001
00001B38                          1201  * (SUB)
00001B38                          1202  *-----------------------------------------------------------
00001B38                          1203  OPC_1001:
00001B38                          1204              * fill in A1 register
00001B38  12FC 0053               1205              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001B3C  12FC 0055               1206              MOVE.B  #'U',(A1)+
00001B40  12FC 0042               1207              MOVE.B  #'B',(A1)+
00001B44                          1208m             INSERT_PERIOD
00001B48  6000 008E               1209              BRA     PROCESS_ROEA
00001B4C                          1210  *-----------------------------------------------------------
00001B4C                          1211  
00001B4C                          1212  
00001B4C                          1213  
00001B4C                          1214  *-----------------------OPC_1100----------------------------
00001B4C                          1215  * First four bits = 1100
00001B4C                          1216  * (AND, MULS)
00001B4C                          1217  *-----------------------------------------------------------
00001B4C                          1218  OPC_1100:   
00001B4C                          1219              ; check to see if bits 8-6 are 111
00001B4C                          1220              ; if they are, then branch to PARSE_MULS
00001B4C                          1221              ; else, keep going to parse AND
00001B4C                          1222  
00001B4C                          1223m             GET_BITS #8, #6
00001B5C                          1224m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B62                          1225m             * GET HIGH BIT OFFSET
00001B68                          1226m             * SHIFT OUT HIGH BITS
00001B6E                          1227m             *GET LOW BIT OFFSET
00001B6E                          1228m             *16 - NUMBER OF BITS WE WANT
00001B74                          1229m             * SHIFT OUT LOW BITS
00001B76  B83C 0007               1230              CMP.B    #%00000111, D4
00001B7A  6700 001A               1231              BEQ      OPC_MULS
00001B7E  6600 0002               1232              BNE      OPC_AND
00001B82                          1233  
00001B82                          1234  *---------------------------OPC_AND------------------------
00001B82                          1235  OPC_AND:    ; AND opcode subroutine
00001B82                          1236  
00001B82                          1237              ;-----------------------------
00001B82                          1238              ; fill A1 with the opcode name
00001B82  12FC 0041               1239              MOVE.B  #'A',(A1)+
00001B86  12FC 004E               1240              MOVE.B  #'N',(A1)+
00001B8A  12FC 0044               1241              MOVE.B  #'D',(A1)+
00001B8E                          1242m             INSERT_PERIOD
00001B92  6000 0044               1243              BRA     PROCESS_ROEA
00001B96                          1244  
00001B96                          1245  *---------------------------OPC_MULS------------------------
00001B96                          1246  OPC_MULS:  * MULS opcode subroutine
00001B96                          1247  
00001B96                          1248              * load the command name into the output
00001B96  12FC 004D               1249              MOVE.B  #'M',(A1)+
00001B9A  12FC 0055               1250              MOVE.B  #'U',(A1)+
00001B9E  12FC 004C               1251              MOVE.B  #'L',(A1)+
00001BA2  12FC 0053               1252              MOVE.B  #'S',(A1)+
00001BA6                          1253m             INSERT_PERIOD
00001BAA  12FC 0057               1254              MOVE.B  #'W',(A1)+ * always size word
00001BAE                          1255m             INSERT_SPACE
00001BB2                          1256  
00001BB2  11FC 0001 11A1          1257              MOVE.B   #1, opSize
00001BB8                          1258              
00001BB8  11FC 00BF 11A2          1259              MOVE.B  #%10111111, valid   * set the valid mode bits (to be used later)
00001BBE                          1260              
00001BBE  4EF9 00001C78           1261              JMP     EA_TO_D
00001BC4                          1262  *-----------------------------------------------------------
00001BC4                          1263  
00001BC4                          1264  
00001BC4                          1265  *---------------------------opc_1101------------------------
00001BC4                          1266  * First four bits = 1101
00001BC4                          1267  * (ADD)
00001BC4                          1268  *-----------------------------------------------------------
00001BC4                          1269  OPC_1101:
00001BC4                          1270              * fill in A1 register
00001BC4  12FC 0041               1271              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001BC8  12FC 0044               1272              MOVE.B  #'D',(A1)+
00001BCC  12FC 0044               1273              MOVE.B  #'D',(A1)+
00001BD0                          1274m             INSERT_PERIOD
00001BD4  6000 0002               1275              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
00001BD8                          1276  
00001BD8                          1277  *-----------------------------------------------------------
00001BD8                          1278  
00001BD8                          1279  
00001BD8                          1280  
00001BD8                          1281  
00001BD8                          1282  
00001BD8                          1283  
00001BD8                          1284  
00001BD8                          1285  
00001BD8                          1286  
00001BD8                          1287  
00001BD8                          1288  
00001BD8                          1289  *--------------Process Register->Opmode->EA-----------------
00001BD8                          1290  * Description:
00001BD8                          1291  * Parses bits for opcodes that share bit placements:
00001BD8                          1292  * ROEA stands for Register, Opmode, and Effective Address,
00001BD8                          1293  * because the opcodes below share this bit order.
00001BD8                          1294  *
00001BD8                          1295  * Used by: (ADD, SUB, MULS)
00001BD8                          1296  *
00001BD8                          1297  *-----------------------------------------------------------
00001BD8                          1298  PROCESS_ROEA:
00001BD8                          1299m             GET_BITS        #7, #6              * retrieve size
00001BE8                          1300m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001BEE                          1301m             * GET HIGH BIT OFFSET
00001BF4                          1302m             * SHIFT OUT HIGH BITS
00001BFA                          1303m             *GET LOW BIT OFFSET
00001BFA                          1304m             *16 - NUMBER OF BITS WE WANT
00001C00                          1305m             * SHIFT OUT LOW BITS
00001C02  11C4 11A1               1306              MOVE.B          D4, opSize
00001C06                          1307m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001C0E                          1308  
00001C0E                          1309m             GET_BITS        #8, #8              * retrieve type  
00001C1E                          1310m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001C24                          1311m             * GET HIGH BIT OFFSET
00001C2A                          1312m             * SHIFT OUT HIGH BITS
00001C30                          1313m             *GET LOW BIT OFFSET
00001C30                          1314m             *16 - NUMBER OF BITS WE WANT
00001C36                          1315m             * SHIFT OUT LOW BITS
00001C38  B83C 0001               1316              CMP.B           #1, D4              * is this Dn + <ea> -> <ea>?
00001C3C  6700 000A               1317              BEQ             D_TO_EA
00001C40  B83C 0000               1318              CMP.B           #0, D4              * is this <ea> + Dn -> <ea>?
00001C44  6700 0032               1319              BEQ             EA_TO_D
00001C48                          1320  
00001C48                          1321  D_TO_EA:
00001C48  4EB9 00001CB0           1322              JSR             GET_DATA_REG_NUM
00001C4E                          1323m             INSERT_COMMA
00001C52                          1324m             INSERT_SPACE
00001C56                          1325m             DECODE_EA       #5, #0
00001C74  6000 0032               1326              BRA             ROEA_DONE
00001C78                          1327  
00001C78                          1328  EA_TO_D:
00001C78                          1329m             DECODE_EA       #5, #0
00001C96                          1330m             INSERT_COMMA
00001C9A                          1331m             INSERT_SPACE
00001C9E  4EB9 00001CB0           1332              JSR             GET_DATA_REG_NUM
00001CA4  6000 0002               1333              BRA             ROEA_DONE
00001CA8                          1334  
00001CA8                          1335  ROEA_DONE:
00001CA8                          1336m             INSERT_SPACE
00001CAC  6000 F7C6               1337              BRA     IDENTIFY_OPCODE
00001CB0                          1338  
00001CB0                          1339  GET_DATA_REG_NUM:
00001CB0  4284                    1340              CLR.L    D4
00001CB2                          1341m             GET_BITS #11, #9                     * retrieve high data register number
00001CC2                          1342m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001CCC                          1343m             * GET HIGH BIT OFFSET
00001CD4                          1344m             * SHIFT OUT HIGH BITS
00001CDA                          1345m             *GET LOW BIT OFFSET
00001CDA                          1346m             *16 - NUMBER OF BITS WE WANT
00001CE0                          1347m             * SHIFT OUT LOW BITS
00001CE2                          1348  
00001CE2                          1349              * store in appropriate register
00001CE2  12FC 0044               1350              MOVE.B            #'D',(A1)+                  * add "D" to buffer
00001CE6                          1351m             VALUE_TO_BUFFER   D4          
00001CEE  4E75                    1352              RTS
00001CF0                          1353  *-----------------------------------------------------------
00001CF0                          1354  
00001CF0                          1355  
00001CF0                          1356  
00001CF0                          1357  
00001CF0                          1358  
00001CF0                          1359  
00001CF0                          1360  
00001CF0                          1361  
00001CF0                          1362  
00001CF0                          1363  
00001CF0                          1364  
00001CF0                          1365  
00001CF0                          1366  *----------------------EA_TO_BUFFER------------------
00001CF0                          1367  * Description:
00001CF0                          1368  * Evaluates the ea mode and register of an opcode 
00001CF0                          1369  * (usually last 6 bits of instruction format),
00001CF0                          1370  * and adds it to A1 to be printed out
00001CF0                          1371  *
00001CF0                          1372  * No Parameters
00001CF0                          1373  *
00001CF0                          1374  * Registers Used:
00001CF0                          1375  *   D1 = amount to shift the opcode
00001CF0                          1376  *   D2 = destination for shifts
00001CF0                          1377  *-----------------------------------------------------------
00001CF0                          1378  EA_TO_BUFFER:                            
00001CF0  0C38 0000 11A3          1379              CMP.B   #%0000, ea_mode        * Direct Data Register
00001CF6  6700 004C               1380              BEQ     EA_000
00001CFA                          1381  
00001CFA  0C38 0001 11A3          1382              CMP.B   #%0001, ea_mode        * Direct Address Register
00001D00  6700 0052               1383              BEQ     EA_001
00001D04                          1384  
00001D04  0C38 0002 11A3          1385              CMP.B   #%0010, ea_mode        * Indirect Address Register
00001D0A  6700 0058               1386              BEQ     EA_010
00001D0E                          1387  
00001D0E  0C38 0003 11A3          1388              CMP.B   #%0011, ea_mode        * Post Increment
00001D14  6700 0066               1389              BEQ     EA_011
00001D18                          1390  
00001D18  0C38 0004 11A3          1391              CMP.B   #%0100, ea_mode        * Pre Decrement
00001D1E  6700 0078               1392              BEQ     EA_100
00001D22                          1393  
00001D22  0C38 0005 11A3          1394              CMP.B   #%0101, ea_mode        * Not necessary, go to bad EA
00001D28  6700 008A               1395              BEQ     EA_101
00001D2C                          1396  
00001D2C  0C38 0006 11A3          1397              CMP.B   #%0110, ea_mode        * Not necessary, go to bad EA
00001D32  6700 0084               1398              BEQ     EA_110
00001D36                          1399  
00001D36  0C38 0007 11A3          1400              CMP.B   #%0111, ea_mode        * Absolute or immediate address
00001D3C  6700 007E               1401              BEQ     EA_111
00001D40                          1402  
00001D40  6000 00E2               1403              BRA    INVALID_EA
00001D44                          1404  
00001D44                          1405  *----------------------------Direct Data Register------------------------
00001D44                          1406  EA_000:
00001D44  12FC 0044               1407              MOVE.B      #'D',(A1)+              * add "D" to buffer
00001D48  0638 0030 11A4          1408              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001D4E  12F8 11A4               1409              MOVE.B      ea_register, (A1)+      * register # to buffer                  
00001D52  4E75                    1410              RTS                                
00001D54                          1411  
00001D54                          1412  *----------------------------Direct Address Register------------------------
00001D54                          1413  EA_001:
00001D54  12FC 0041               1414              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001D58  0638 0030 11A4          1415              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001D5E  12F8 11A4               1416              MOVE.B      ea_register, (A1)+      * register # to buffer               
00001D62  4E75                    1417              RTS                            
00001D64                          1418  
00001D64                          1419  *----------------------------Indirect Address Register------------------------
00001D64                          1420  EA_010:
00001D64  12FC 0028               1421              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001D68  12FC 0041               1422              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001D6C  0638 0030 11A4          1423              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001D72  12F8 11A4               1424              MOVE.B      ea_register, (A1)+      * register # to buffer     
00001D76  12FC 0029               1425              MOVE.B      #')',(A1)+              * add ")" to buffer
00001D7A  4E75                    1426              RTS                            
00001D7C                          1427  
00001D7C                          1428  *----------------------------Post Increment------------------------
00001D7C                          1429  EA_011:
00001D7C  12FC 0028               1430              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001D80  12FC 0041               1431              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001D84  0638 0030 11A4          1432              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001D8A  12F8 11A4               1433              MOVE.B      ea_register, (A1)+      * register # to buffer 
00001D8E  12FC 0029               1434              MOVE.B      #')',(A1)+              * add ")" to buffer
00001D92  12FC 002B               1435              MOVE.B      #'+',(A1)+              * add "+" to buffer 
00001D96  4E75                    1436              RTS                              
00001D98                          1437  
00001D98                          1438  *----------------------------Pre Decrement------------------------
00001D98                          1439  EA_100:
00001D98  12FC 002D               1440              MOVE.B      #'-',(A1)+              * add "-" to buffer
00001D9C  12FC 0028               1441              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001DA0  12FC 0041               1442              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001DA4  0638 0030 11A4          1443              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001DAA  12F8 11A4               1444              MOVE.B      ea_register, (A1)+      * register # to buffer 
00001DAE  12FC 0029               1445              MOVE.B      #')',(A1)+              * add ")" to buffer
00001DB2  4E75                    1446              RTS
00001DB4                          1447  
00001DB4                          1448  *----------------------------Not necessary, go to bad EA------------------------
00001DB4                          1449  EA_101:
00001DB4  6000 006E               1450              BRA         INVALID_EA        
00001DB8                          1451  
00001DB8                          1452  *----------------------------Not necessary, go to bad EA------------------------
00001DB8                          1453  EA_110:
00001DB8  6000 006A               1454              BRA         INVALID_EA        
00001DBC                          1455  
00001DBC                          1456  *----------------------------Absolute or immediate address------------------------
00001DBC                          1457  EA_111:
00001DBC                          1458              * D405      0 0003456  23345245
00001DBC                          1459              * ADD.L     $1234, D0
00001DBC                          1460  
00001DBC                          1461              * 8 bit value
00001DBC                          1462              * 11111111
00001DBC                          1463  
00001DBC                          1464              * 11111011 - Direct data register would be Invalid
00001DBC                          1465              * 00000100
00001DBC                          1466              * 00000000 -> invalid code
00001DBC                          1467  
00001DBC                          1468              * and.b     #$F, Dn        ---->  10000000
00001DBC                          1469              * cmp.b     #%10000000, Dn  
00001DBC                          1470  
00001DBC                          1471              * check against valid bits
00001DBC                          1472                  * if invalid, branch to invalid opcode subroutine
00001DBC                          1473                      * if the mode is 111, then go back and print out addresses
00001DBC                          1474  
00001DBC  0C38 0000 11A4          1475              CMP.B       #%000, ea_register                * compare to determine if it's a word
00001DC2  6700 001A               1476              BEQ         EA_WORD                  * put word address in buffer
00001DC6                          1477  
00001DC6  0C38 0001 11A4          1478              CMP.B       #%001, ea_register                * compare to determine if it's a long
00001DCC  6700 0024               1479              BEQ         EA_LONG                  * put long address in buffer
00001DD0                          1480              
00001DD0  0C38 0004 11A4          1481              CMP.B       #%100, ea_register
00001DD6  6700 002E               1482              BEQ         EA_IMMEDIATE             * always print a long if it's immediate data
00001DDA                          1483  
00001DDA                          1484              * Invalid EA mode/register
00001DDA  6000 0048               1485              BRA         INVALID_EA
00001DDE                          1486  
00001DDE                          1487  EA_WORD:
00001DDE  12FC 0024               1488              MOVE.B      #'$', (A1)+
00001DE2  4281                    1489              CLR.L       D1
00001DE4  123C 0001               1490              MOVE.B      #1, D1
00001DE8  3E1A                    1491              MOVE.W      (A2)+, D7
00001DEA  6100 003E               1492              BSR         HEX_TO_ASCII
00001DEE  6000 0032               1493              BRA         GET_EA_DONE
00001DF2                          1494  
00001DF2                          1495  EA_LONG:
00001DF2  12FC 0024               1496              MOVE.B      #'$', (A1)+
00001DF6  4281                    1497              CLR.L       D1
00001DF8  123C 0003               1498              MOVE.B      #3, D1
00001DFC  2E1A                    1499              MOVE.L      (A2)+, D7   
00001DFE  6100 002A               1500              BSR         HEX_TO_ASCII
00001E02  6000 001E               1501              BRA         GET_EA_DONE
00001E06                          1502  
00001E06                          1503  EA_IMMEDIATE:
00001E06  12FC 0023               1504              MOVE.B      #'#', (A1)+
00001E0A                          1505  
00001E0A  0C38 0000 11A1          1506              CMP.B       #0, opSize          
00001E10  67CC                    1507              BEQ         EA_WORD
00001E12                          1508  
00001E12  0C38 0001 11A1          1509              CMP.B       #1, opSize          
00001E18  67C4                    1510              BEQ         EA_WORD          
00001E1A                          1511              
00001E1A  0C38 0002 11A1          1512              CMP.B       #2, opSize
00001E20  60D0                    1513              BRA         EA_LONG             
00001E22                          1514  
00001E22                          1515  GET_EA_DONE:
00001E22  4E75                    1516              RTS
00001E24                          1517  
00001E24                          1518  *------------------Invalid Effective Address----------------
00001E24                          1519  INVALID_EA:
00001E24  4EF9 00001ED0           1520              JMP      DONE
00001E2A                          1521  *-----------------------------------------------------------
00001E2A                          1522  
00001E2A                          1523  
00001E2A                          1524  
00001E2A                          1525  
00001E2A                          1526  
00001E2A                          1527  
00001E2A                          1528  
00001E2A                          1529  
00001E2A                          1530  
00001E2A                          1531  *----------------------HEX TO ASCII-------------------------
00001E2A                          1532  * Description:
00001E2A                          1533  * Converts a Hex numbered address (1-9 or A-F) back to an
00001E2A                          1534  * ASCII value for printing
00001E2A                          1535  *
00001E2A                          1536  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
00001E2A                          1537  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
00001E2A                          1538  *   D7 = holds the original address to parse (either word or long, for example: $7000)
00001E2A                          1539  *
00001E2A                          1540  *
00001E2A                          1541  * Registers Used:
00001E2A                          1542  *   D0 = number of bits to remove
00001E2A                          1543  *   D2 = holds either top four bits or bottom four bits of each byte in D6
00001E2A                          1544  *   D3 = holds temp data
00001E2A                          1545  *   D6 = holds part of address (used as temp variable)
00001E2A                          1546  *   A1 = used for buffer
00001E2A                          1547  *-----------------------------------------------------------
00001E2A                          1548  HEX_TO_ASCII:
00001E2A  1001                    1549              MOVE.B   D1, D0             * current number of bytes to remove
00001E2C  C1FC 0008               1550              MULS.W   #8, D0             * number of bits to remove
00001E30                          1551  
00001E30  2C07                    1552              MOVE.L   D7, D6             * load original address to parse
00001E32  E0AE                    1553              LSR.L    D0, D6             * remove lowest byte(s)
00001E34                          1554  
00001E34                          1555              * isolate first four bits
00001E34  1406                    1556              MOVE.B   D6, D2
00001E36  E80A                    1557              LSR.B    #4, D2 
00001E38  6100 0018               1558              BSR      NUMBER_OR_LETTER
00001E3C                          1559  
00001E3C                          1560              * isolate second set of four bits
00001E3C  1406                    1561              MOVE.B   D6, D2
00001E3E  E90A                    1562              LSL.B    #4, D2 
00001E40  E80A                    1563              LSR.B    #4, D2 
00001E42  6100 000E               1564              BSR      NUMBER_OR_LETTER
00001E46                          1565  
00001E46  5301                    1566              SUB.B    #1, D1             * iterate
00001E48  B23C 0000               1567              CMP.B    #0, D1             * done if equal
00001E4C  6D00 0036               1568              BLT      ATH_DONE
00001E50                          1569  
00001E50  60D8                    1570              BRA      HEX_TO_ASCII
00001E52                          1571  
00001E52                          1572  NUMBER_OR_LETTER:
00001E52  1602                    1573              MOVE.B   D2, D3
00001E54  0603 0030               1574              ADD.B    #$30, D3           
00001E58  B63C 0039               1575              CMP.B    #$39, D3           * is byte in D2 a number?
00001E5C  6F00 0012               1576              BLE      NUMBER_TO_ASCII
00001E60                          1577              
00001E60  1602                    1578              MOVE.B   D2, D3
00001E62  0603 0037               1579              ADD.B    #$37, D3           
00001E66  B63C 0039               1580              CMP.B    #$39, D3           * is byte in D2 a letter?
00001E6A  6C00 000C               1581              BGE      LETTER_TO_ASCII
00001E6E                          1582  
00001E6E  60B4                    1583              BRA      INVALID_EA
00001E70                          1584  
00001E70                          1585  NUMBER_TO_ASCII:
00001E70  0602 0030               1586              ADD.B    #$30, D2           * Get the hex range from '0-9'
00001E74  6000 000A               1587              BRA      ADD_TO_BUFFER
00001E78                          1588  
00001E78                          1589  LETTER_TO_ASCII:
00001E78  0602 0037               1590              ADD.B    #$37, D2           * Get the hex range from 'A-F'
00001E7C  6000 0002               1591              BRA      ADD_TO_BUFFER
00001E80                          1592  
00001E80                          1593  ADD_TO_BUFFER:
00001E80  12C3                    1594              MOVE.B   D3, (A1)+          * add part of address to buffer    
00001E82  4E75                    1595              RTS
00001E84                          1596  
00001E84                          1597  ATH_DONE:
00001E84                          1598m             CLR_D_REGS
00001E94  4E75                    1599              RTS
00001E96                          1600  *-----------------------------------------------------------
00001E96                          1601  
00001E96                          1602  
00001E96                          1603  
00001E96                          1604  
00001E96                          1605  
00001E96                          1606  
00001E96                          1607  
00001E96                          1608  
00001E96                          1609  
00001E96                          1610  *---------------------SIZE TO BUFFER------------------------
00001E96                          1611  * Description:
00001E96                          1612  * Evaluates the size of an opcode and adds it to A1 to be printed out
00001E96                          1613  *
00001E96                          1614  * Parameters:
00001E96                          1615  *   D3 = size of opcode
00001E96                          1616  *
00001E96                          1617  * Registers Used:
00001E96                          1618  *   A1: adding words/numbers to buffer
00001E96                          1619  *-----------------------------------------------------------
00001E96                          1620  FIND_SIZE: 
00001E96  B63C 0000               1621              CMP.B   #%0000,D3            
00001E9A  6700 0016               1622              BEQ     BYTE_TO_BUFFER              
00001E9E                          1623  
00001E9E  B63C 0001               1624              CMP.B   #%0001,D3             * is this a word?
00001EA2  6700 0016               1625              BEQ     WORD_TO_BUFFER
00001EA6                          1626  
00001EA6  B63C 0002               1627              CMP.B   #%0010,D3             * is this a long?
00001EAA  6700 0016               1628              BEQ     LONG_TO_BUFFER             
00001EAE                          1629        
00001EAE  4EF8 1530               1630              JMP     BAD_OPCODE  
00001EB2                          1631              
00001EB2                          1632  BYTE_TO_BUFFER:
00001EB2  12FC 0042               1633              MOVE.B  #'B', (A1)+           * add B to buffer
00001EB6  6000 0012               1634              BRA     STB_END             
00001EBA                          1635              
00001EBA                          1636  WORD_TO_BUFFER:
00001EBA  12FC 0057               1637              MOVE.B  #'W', (A1)+          * add W to buffer
00001EBE  6000 000A               1638              BRA     STB_END             
00001EC2                          1639  
00001EC2                          1640  LONG_TO_BUFFER:
00001EC2  12FC 004C               1641              MOVE.B  #'L',(A1)+          * add L to buffer
00001EC6  6000 0002               1642              BRA     STB_END             
00001ECA                          1643  
00001ECA                          1644  STB_END:
00001ECA  12FC 0020               1645              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001ECE  4E75                    1646              RTS                         
00001ED0                          1647  *-----------------------------------------------------------
00001ED0                          1648  
00001ED0                          1649  
00001ED0                          1650  
00001ED0                          1651  
00001ED0                          1652  
00001ED0                          1653  
00001ED0                          1654  *-------------------------DONE-------------------------------
00001ED0                          1655  DONE:
00001ED0                          1656m             CLR_A_REG D0, A1
00001ED4                          1657  
00001ED4                          1658              * add 'SIMHAULT' to buffer
00001ED4  12FC 0053               1659              MOVE.B  #'S',(A1)+      
00001ED8  12FC 0049               1660              MOVE.B  #'I',(A1)+         
00001EDC  12FC 004D               1661              MOVE.B  #'M',(A1)+         
00001EE0  12FC 0048               1662              MOVE.B  #'H',(A1)+        
00001EE4  12FC 0041               1663              MOVE.B  #'A',(A1)+                 
00001EE8  12FC 004C               1664              MOVE.B  #'L',(A1)+          
00001EEC  12FC 0054               1665              MOVE.B  #'T',(A1)+         
00001EF0  12FC 0000               1666              MOVE.B  #00,(A1)+         
00001EF4                          1667  
00001EF4                          1668m             CLR_A_REG D0, A1
00001EF8                          1669              
00001EF8                          1670              * print out string
00001EF8  103C 000E               1671              MOVE.B    #14, D0
00001EFC  4E4F                    1672              TRAP      #15
00001EFE                          1673              
00001EFE                          1674m             CLR_A_REG D0, A1
00001F02                          1675  
00001F02                          1676  
00001F02                          1677              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       1E80
ATH_DONE            1E84
BADINPUT            117A
BAD_OPCODE          1530
BCC_DISPLACEMENT    1A58
BEQ                 1A44
BGE                 1A30
BLT                 1A1C
BYTE_TO_BUFFER      1EB2
CHECK_ADDRESS       1332
CHECK_IMMEDIATE     160E
CHECK_LENGTH        1312
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      1362
CR                  D
DECODE_11_TO_6      1218
DECODE_6_TO_0       11B6
DECODE_EA           57B
DECODE_EA_HELP      11A6
DECODE_IMMEDIATE    15A8
DECODE_MOVE         16B0
DECODE_QUICK        18FC
DONE                1ED0
DONEMSG             116D
D_TO_EA             1C48
EA_000              1D44
EA_001              1D54
EA_010              1D64
EA_011              1D7C
EA_100              1D98
EA_101              1DB4
EA_110              1DB8
EA_111              1DBC
EA_END              127A
EA_IMMEDIATE        1E06
EA_LONG             1DF2
EA_MODE             11A3
EA_REGISTER         11A4
EA_TO_BUFFER        1CF0
EA_TO_D             1C78
EA_VALID            11A5
EA_WORD             1DDE
ENDADDR             119A
ENDMSG              114A
FIND_OPCODE         14BE
FIND_SIZE           1E96
FINISH_PRINT        140A
GET_ADDRESS         12FE
GET_BITS            1C5
GET_DATA_REG_NUM    1CB0
GET_EA_DONE         1E22
GET_EA_MODE         613
GET_EA_REG          675
GET_INPUT           12C4
GRAB_FIRST_FOUR_BITS  14AC
GRAB_NEXT_WORD      14A6
HEX_TO_ASCII        1E2A
IDENTIFY_OPCODE     1474
IMMEDIATE_LONG      162A
IMMEDIATE_WORD      1622
INSERT_COMMA        73A
INSERT_DOLLAR       857
INSERT_PERIOD       799
INSERT_POUND        7F8
INSERT_SPACE        6DB
INVALID_ADDRESS     1352
INVALID_EA          1E24
INVALID_INPUT       1324
ITERATE             1396
LETTER_TO_ASCII     1E78
LETTER_TO_HEX       1388
LF                  A
LOAD_ADDRESSES      144E
LONG_TO_BUFFER      1EC2
MAIN                127C
NEWLINE             118A
NUMBER_OR_LETTER    1E52
NUMBER_TO_ASCII     1E70
NUM_TO_HEX          1380
OPCODE              119E
OPC_0000            1536
OPC_0001            1632
OPC_0010            165C
OPC_0011            1686
OPC_0100            16F6
OPC_0101            188E
OPC_0110            199C
OPC_1000            185C
OPC_1001            1B38
OPC_1100            1B4C
OPC_1101            1BC4
OPC_ADDI            1578
OPC_ADDQ            18CC
OPC_AND             1B82
OPC_BRA             1AAE
OPC_DIVU            1860
OPC_JSR             181A
OPC_LEA             17CC
OPC_MULS            1B96
OPC_NOP             1754
OPC_NOT             1764
OPC_RTS             184C
OPC_SUBI            1590
OPC_SUBQ            18E4
OPSIZE              11A1
OPTAG               11A0
PRINT_ADDRESS       13A8
PRINT_INSTRUCTION   1430
PRINT_LONG          13F0
PRINT_MSG           0
PRINT_WORD          13D6
PROCESS_ROEA        1BD8
RESTORE_REGS        14A0
ROEA_DONE           1CA8
RULE1               1000
RULE1C              1038
RULE2               1059
RULE3               109B
RULE3C              10DD
SIXTEEN_BIT_DISPLACEMENT  1B14
SIZE_TO_BUFFER      51C
STARTADDR           1196
STARTMSG            1125
STB_END             1ECA
STORE_CHAR          1390
STORE_INPUT         13A4
USERADDR            118E
VALID               11A2
VALUE_TO_BUFFER     4B4
WORD_TO_BUFFER      1EBA
