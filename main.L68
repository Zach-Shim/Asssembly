00001086 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 4/26/2021 10:53:39 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00001000                            11              ORG     $1000
00001000                            12  
00001000  =0000000D                 13  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 14  LF          EQU     $0A 
00001000                            15  
00001000= 50 6C 65 61 73 65 ...     16  startMsg:   DC.B    'Please enter a starting address ', 0, CR, LF
00001023= 50 6C 65 61 73 65 ...     17  endMsg:     DC.B    'Please enter an ending address ', 0, CR, LF
00001045= 65 78 69 74 69 6E ...     18  doneMsg:    DC.B    'exiting...', 0, CR, LF
00001052= 49 6E 76 61 6C 69 ...     19  badInput:   DC.B    'Invalid Input', 0, CR, LF
00001062                            20  
00001062                            21  userAddr:   DS.L    1
00001066                            22  startAddr:  DS.L    1
0000106A                            23  endAddr:    DS.L    1
0000106E                            24  
0000106E                            25  opOutput:   DS.L    5
00001082                            26  
00001082                            27  opcode:     DS.W    1   
00001084                            28  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
00001085                            29  valid:      DS.B    1
00001086                            30  
00001086                            31  *-----------------------------------------------------------
00001086                            32  * Macros:
00001086                            33  *-----------------------------------------------------------
00001086                            34  
00001086                            35  PRINT_MSG:  MACRO 
00001086                            36              CLR.L   D0
00001086                            37              LEA     \1, A1      ; \1 acts as a parameter
00001086                            38              MOVE.B  #14, D0     
00001086                            39              TRAP    #15
00001086                            40              ENDM
00001086                            41  
00001086                            42  CLR_D_REGS: MACRO
00001086                            43              CLR.L   D0
00001086                            44              CLR.L   D1
00001086                            45              CLR.L   D2
00001086                            46              CLR.L   D3
00001086                            47              CLR.L   D4
00001086                            48              CLR.L   D5
00001086                            49              CLR.L   D6
00001086                            50              CLR.L   D7
00001086                            51              ENDM
00001086                            52  
00001086                            53  CLR_A_REG: MACRO
00001086                            54              CLR.L   \1
00001086                            55              MOVE.L  \1, \2
00001086                            56              ENDM  
00001086                            57  
00001086                            58  
00001086                            59  *-----------------------------------------------------------
00001086                            60  * Description:  Get User Input
00001086                            61  *-----------------------------------------------------------
00001086                            62  
00001086                            63  *-------------------------MAIN------------------------------
00001086                            64  MAIN:
00001086  6100 0008                 65              BSR     GET_INPUT
0000108A  4EF9 000011BE             66              JMP     IDENTIFY_OPCODE
00001090                            67  *-----------------------------------------------------------
00001090                            68  
00001090                            69  *-------------------------Get Input-------------------------
00001090                            70  GET_INPUT:
00001090  B87C 0000                 71              CMP      #0, D4
00001094  6700 000C                 72              BEQ      GET_START_ADDRESS
00001098                            73                 
00001098  21C6 1066                 74              MOVE.L   D6, startAddr
0000109C  21C7 106A                 75              MOVE.L   D7, endAddr
000010A0  4E75                      76              RTS 
000010A2                            77  *-----------------------------------------------------------
000010A2                            78  
000010A2                            79  *----------------------Get Starting Address----------------------
000010A2                            80  GET_START_ADDRESS:
000010A2  4280                      81              CLR.L   D0
000010A4  43F8 1000                 82              LEA.L   startMsg, A1      
000010A8  103C 000E                 83              MOVE.B  #14, D0     
000010AC  4E4F                      84              TRAP    #15
000010AE                            85  
000010AE  43F8 1062                 86              LEA.L   userAddr, A1
000010B2  103C 0002                 87              MOVE.B  #2, D0
000010B6  4E4F                      88              TRAP    #15
000010B8                            89              ;MOVE.B  D1, startSize
000010B8  6000 001C                 90              BRA     VALIDATE_INPUT
000010BC                            91  *-----------------------------------------------------------
000010BC                            92  
000010BC                            93  *----------------------Get Ending Address----------------------
000010BC                            94  GET_END_ADDRESS:
000010BC  4280                      95              CLR.L   D0
000010BE  43F8 1023                 96              LEA.L   endMsg, A1      
000010C2  103C 000E                 97              MOVE.B  #14, D0     
000010C6  4E4F                      98              TRAP    #15
000010C8                            99  
000010C8  43F8 1062                100              LEA.L   userAddr, A1
000010CC  103C 0002                101              MOVE.B  #2, D0
000010D0  4E4F                     102              TRAP    #15
000010D2                           103              ;MOVE.B  D1, endSize
000010D2  6000 0012                104              BRA     CHECK_LENGTH
000010D6                           105  *-----------------------------------------------------------
000010D6                           106  
000010D6                           107  
000010D6                           108  
000010D6                           109  
000010D6                           110  
000010D6                           111  *-----------------------------------------------------------
000010D6                           112  * Description:  Validate User Input
000010D6                           113  * Constraints:  
000010D6                           114  *   User input must be:
000010D6                           115  *   Length 4 or Length 8
000010D6                           116  *   ASCII character 0-9 or A-F
000010D6                           117  *   Starting and ending address with value < $00FFFFFF 
000010D6                           118  *   Starting address is before ending address
000010D6                           119  *-----------------------------------------------------------
000010D6                           120  
000010D6                           121  *----------------------VALIDATE INPUT---------------------------      
000010D6                           122  
000010D6                           123  VALIDATE_INPUT:        
000010D6  B83C 0000                124              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
000010DA  6700 000A                125              BEQ        CHECK_LENGTH         ; if equal, parse START address 
000010DE  B83C 0001                126              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
000010E2  67D8                     127              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
000010E4  60AA                     128              BRA        GET_INPUT            ; done parsing, D4 = 2
000010E6                           129  
000010E6                           130  CHECK_LENGTH:
000010E6  B23C 0004                131              CMP.B      #4, D1               ; for task 2, length of string is in D1                
000010EA  6700 002C                132              BEQ        CONVERT_TO_HEX 
000010EE  B23C 0008                133              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
000010F2  6700 0024                134              BEQ        CONVERT_TO_HEX
000010F6  6000 0002                135              BRA        INVALID_INPUT
000010FA                           136  
000010FA                           137  INVALID_INPUT:  
000010FA  4283                     138              CLR.L      D3
000010FC                           139m             PRINT_MSG  badInput
00001108  B83C 0000                140              CMP.B      #0, D4 
0000110C  6794                     141              BEQ        GET_START_ADDRESS  
0000110E  B83C 0001                142              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001112  67A8                     143              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
00001114  6000 FF70                144              BRA        MAIN
00001118                           145  *-----------------------------------------------------------
00001118                           146  
00001118                           147  *----------------CONVERT FROM ASCII TO HEX------------------
00001118                           148  CONVERT_TO_HEX:
00001118  0C11 0030                149              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
0000111C  6DDC                     150              BLT        INVALID_INPUT        
0000111E                           151  
0000111E  0C11 003A                152              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001122  6D00 0012                153              BLT        NUM_TO_HEX      
00001126                           154  
00001126  0C11 0041                155              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
0000112A  6DCE                     156              BLT        INVALID_INPUT             
0000112C                           157  
0000112C  0C11 0047                158              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001130  6D00 000C                159              BLT        LETTER_TO_HEX
00001134                           160  
00001134  60C4                     161              BRA        INVALID_INPUT    
00001136                           162  
00001136                           163  NUM_TO_HEX:      
00001136  0411 0030                164              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
0000113A  6000 000A                165              BRA        STORE_CHAR   
0000113E                           166  
0000113E                           167  LETTER_TO_HEX:     
0000113E  0411 0037                168              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001142  6000 0002                169              BRA        STORE_CHAR
00001146                           170  
00001146                           171  STORE_CHAR:       
00001146  D619                     172              ADD.B     (A1)+, D3            ; keep hex stored in D3           
00001148  6000 0002                173              BRA        ITERATE                 
0000114C                           174  
0000114C                           175  ITERATE:
0000114C  5301                     176              SUB.B      #$1, D1
0000114E  B23C 0000                177              CMP.B      #0, D1
00001152  6700 0006                178              BEQ        STORE_INPUT
00001156                           179  
00001156  E98B                     180              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
00001158  60BE                     181              BRA        CONVERT_TO_HEX
0000115A                           182  
0000115A                           183  STORE_INPUT:
0000115A  B83C 0000                184              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
0000115E  6700 000A                185              BEQ        STORE_START          ; if equal, parse START address 
00001162                           186              
00001162  B83C 0001                187              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001166  6700 0016                188              BEQ        STORE_END         
0000116A                           189  
0000116A                           190  STORE_START:
0000116A  2C03                     191              MOVE.L     D3, D6
0000116C  5204                     192              ADD.B      #1, D4               ; value to indicate if we are done parsing
0000116E                           193              ;CLR        D3
0000116E                           194              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
0000116E                           195  
0000116E                           196              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
0000116E  4281                     197              CLR.L       D1
00001170  2203                     198              MOVE.L      D3, D1   
00001172  103C 0003                199              MOVE.B      #3, D0     
00001176  4E4F                     200              TRAP        #15
00001178                           201  
00001178  4243                     202              CLR         D3
0000117A  6000 FF5A                203              BRA         VALIDATE_INPUT
0000117E                           204  
0000117E                           205  STORE_END:
0000117E  2E03                     206              MOVE.L     D3, D7
00001180  5204                     207              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001182                           208              ;CLR        D3
00001182                           209              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001182                           210  
00001182                           211              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001182  4281                     212              CLR.L       D1
00001184  2203                     213              MOVE.L      D3, D1   
00001186  103C 0003                214              MOVE.B      #3, D0     
0000118A  4E4F                     215              TRAP        #15
0000118C                           216  
0000118C  4243                     217              CLR         D3
0000118E  6000 FF46                218              BRA         VALIDATE_INPUT
00001192                           219  *-----------------------------------------------------------
00001192                           220  
00001192                           221  
00001192                           222  
00001192                           223  
00001192                           224  
00001192                           225  *-----------------------------------------------------------
00001192                           226  * Description:  IDENTIFY OPCODES LOOP
00001192                           227  * Registers:
00001192                           228  *   D0 = used for tasks and trap #15
00001192                           229  *   D1 = size of shifting bits
00001192                           230  *   D2 = destination for shifts
00001192                           231  *   D3 = size of opcode
00001192                           232  *   D4 = <ea> vs Dn (0 = <ea>, 1 = Dn)
00001192                           233  *   D5 = addressing mode
00001192                           234  *   D6 = register number
00001192                           235  *   D7 = used as bool flag
00001192                           236  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001192                           237  *   A2 = current address (given by user)
00001192                           238  *   A3 = ending address (given by user)
00001192                           239  *   A4 = used to add to the buffer to print ()
00001192                           240  
00001192                           241  *-----------------------------------------------------------
00001192                           242  
00001192                           243  
00001192                           244  *---------------------LOAD ADDRESSES------------------------
00001192                           245  * stores initial values into registers
00001192                           246  *-----------------------------------------------------------
00001192                           247  LOAD_ADDRESSES: 
00001192                           248              * clear all registers and push current registers onto the stack (so we can have fresh registers)
00001192                           249m             CLR_D_REGS
000011A2                           250m             CLR_A_REG       D0, A1
000011A6                           251  
000011A6                           252              * load start and end registers
000011A6  2478 1066                253              MOVEA.L startAddr, A2
000011AA  2678 106A                254              MOVEA.L endAddr, A3
000011AE                           255  
000011AE  6100 0058                256              BSR     GRAB_NEXT_WORD
000011B2  6100 0064                257              BSR     GRAB_FIRST_FOUR_BITS    ; grabs that opcode's ID (first four bits)
000011B6                           258  
000011B6  48E7 FFFE                259              MOVEM.L D0-D7/A0-A6,-(SP)       ; move the old registers onto the stack
000011BA  6000 002E                260              BRA     FIND_OPCODE
000011BE                           261  
000011BE                           262  *-------------------IDENTIFY OPCODES------------------------
000011BE                           263  * evaluates an opcode based on first four bits (aka opTag)
000011BE                           264  *-----------------------------------------------------------
000011BE                           265  IDENTIFY_OPCODE:
000011BE  B7CA                     266              CMPA.L  A2, A3
000011C0  6700 0100                267              BEQ     DONE
000011C4                           268  
000011C4  6100 0012                269              BSR     RESTORE_REGS
000011C8  6100 0014                270              BSR     PRINT_OPCODE
000011CC                           271  
000011CC  6100 003A                272              BSR     GRAB_NEXT_WORD
000011D0  6100 0046                273              BSR     GRAB_FIRST_FOUR_BITS    ; grabs that opcode's ID (first four bits)
000011D4  6000 0014                274              BRA     FIND_OPCODE
000011D8                           275  
000011D8                           276  RESTORE_REGS:
000011D8  4CDF 7FFF                277              MOVEM.L (SP)+, D0-D7/A0-A6      ; move the old registers onto the stack
000011DC  4E75                     278              RTS
000011DE                           279  
000011DE                           280  PRINT_OPCODE:
000011DE  4280                     281              CLR.L     D0
000011E0  103C 000E                282              MOVE.B    #14, D0
000011E4  4E4F                     283              TRAP      #15
000011E6                           284m             CLR_A_REG D0, A1
000011EA                           285  
000011EA                           286  FIND_OPCODE:
000011EA  B03C 0004                287              CMP.B   #%0000100, D0 
000011EE  4EF9 00001228            288              JMP     opc_0100
000011F4                           289  
000011F4  B03C 000D                290              CMP.B   #%00001101, D0
000011F8  4EF9 00001228            291              JMP     opc_1101
000011FE                           292  
000011FE                           293              * error, bad opcode
000011FE  6000 0002                294              BRA      BAD_OPCODE
00001202                           295  
00001202                           296  BAD_OPCODE:
00001202  4EF9 000012C2            297              JMP      DONE
00001208                           298  
00001208                           299  GRAB_NEXT_WORD:
00001208                           300              * load current word of bits into opcode
00001208  31DA 1082                301              MOVE.W (A2)+, opcode
0000120C                           302  
0000120C                           303              * load into A4 register for printing
0000120C  28F8 1082                304              MOVE.L   opcode, (A4)+
00001210  18FC 0020                305              MOVE.B  #' ', (A4)+
00001214  28F8 1082                306              MOVE.L   opcode, (A4)+
00001218                           307  
00001218                           308  GRAB_FIRST_FOUR_BITS:
00001218                           309              * find first four bits of opcode
00001218  1438 1082                310              MOVE.B  opcode, D2
0000121C  123C 000C                311              MOVE.B  #12, D1
00001220  E2AA                     312              LSR.L   D1, D2
00001222  11C2 1084                313              MOVE.B  D2, opTag
00001226  4E75                     314              RTS
00001228                           315  
00001228                           316  *-----------------------------------------------------------
00001228                           317  
00001228                           318  
00001228                           319  
00001228                           320  *-----------------------------------------------------------
00001228                           321  * First four bits = 0100
00001228                           322  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
00001228                           323  *-----------------------------------------------------------
00001228                           324  opc_0100:
00001228                           325              
00001228                           326  *-----------------------------------------------------------
00001228                           327  
00001228                           328  
00001228                           329  
00001228                           330  
00001228                           331  *-----------------------------------------------------------
00001228                           332  * First four bits = 1101
00001228                           333  * (ADD,ADDA)
00001228                           334  *-----------------------------------------------------------
00001228                           335  opc_1101:
00001228                           336              * fill in A1 register
00001228  18FC 0041                337              MOVE.B  #'A',(A4)+          * Put ADD into Buff
0000122C  18FC 0044                338              MOVE.B  #'D',(A4)+
00001230  18FC 0044                339              MOVE.B  #'D',(A4)+
00001234  18FC 002E                340              MOVE.B  #'.',(A4)+
00001238                           341  
00001238  6100 0016                342              BSR     GET_SIZE  
0000123C  4EB9 00001274            343              JSR     SIZE_TO_BUFFER
00001242  6100 0022                344              BSR     EA_TO_DN            ; boolean value (either <ea> -> Dn or Dn -> <ea>)  
00001246  4EB9 000012AA            345              JSR     EA_TO_BUFFER
0000124C                           346  
0000124C  6100 FF44                347              BSR     LOAD_ADDRESSES
00001250                           348              
00001250                           349  
00001250                           350  GET_SIZE:
00001250  4282                     351              CLR.L   D2
00001252  3438 1082                352              MOVE.W  opcode ,D2          ; copy current instruction to shift
00001256                           353              
00001256                           354              * shift left to get rid of opTag
00001256  123C 0007                355              MOVE.B  #7, D1
0000125A  E36A                     356              LSL.W   D1, D2
0000125C                           357  
0000125C                           358              * shift right to get rid of opmode, mode, and register bits
0000125C  123C 000D                359              MOVE.B  #13, D1
00001260  E26A                     360              LSR.W   D1, D2
00001262                           361  
00001262                           362              * store in appropriate register
00001262  1602                     363              MOVE.B  D2, D3
00001264  4E75                     364              RTS
00001266                           365  
00001266                           366  EA_TO_DN:
00001266                           367              * D3 should hold the size of the opcode operation
00001266  4282                     368              CLR.L   D2
00001268  3403                     369              MOVE.W  D3, D2  
0000126A                           370  
0000126A                           371              * shift left to identify
0000126A  123C 0002                372              MOVE.B  #2, D1
0000126E  E26A                     373              LSR.W   D1, D2
00001270                           374              
00001270                           375              * store in appropriate register
00001270  1802                     376              MOVE.B  D2, D4
00001272  4E75                     377              RTS
00001274                           378  *-----------------------------------------------------------
00001274                           379  
00001274                           380  
00001274                           381  *---------------------SIZE TO BUFFER------------------------
00001274                           382  * evaluates the size of an opcode and adds it to A1 to be printed out
00001274                           383  *-----------------------------------------------------------
00001274                           384  SIZE_TO_BUFFER: 
00001274  B63C 0000                385              CMP.B   #%00,D3            
00001278  6700 0016                386              BEQ     BYTE_TO_BUFFER              
0000127C                           387  
0000127C  BC3C 0001                388              CMP.B   #%01,D6             * is this a word?
00001280  6700 0016                389              BEQ     WORD_TO_BUFFER
00001284                           390  
00001284  BC3C 0002                391              CMP.B   #%10,D6             * is this a long?
00001288  6700 0016                392              BEQ     LONG_TO_BUFFER             
0000128C                           393        
0000128C                           394              
0000128C  4EF8 1202                395              JMP     BAD_OPCODE  
00001290                           396              
00001290                           397  BYTE_TO_BUFFER:
00001290  12BC 0042                398              MOVE.B  #'B', (A1)           * add B to buffer
00001294  6000 0012                399              BRA     STB_END             
00001298                           400              
00001298                           401  WORD_TO_BUFFER:
00001298  12BC 0057                402              MOVE.B  #'W', (A1)          * add W to buffer
0000129C  6000 000A                403              BRA     STB_END             
000012A0                           404  
000012A0                           405  LONG_TO_BUFFER:
000012A0  14FC 004C                406              MOVE.B  #'L',(A2)+          * add L to buffer
000012A4  6000 0002                407              BRA     STB_END             
000012A8                           408  
000012A8                           409  STB_END:
000012A8  4E75                     410              RTS                         
000012AA                           411  
000012AA                           412  *-----------------------EA TO BUFFER------------------------
000012AA                           413  * evaluates the size of an opcode and adds it to A1 to be printed out
000012AA                           414  * Registers:
000012AA                           415  *   D2 = destination for shifts
000012AA                           416  *   D3 = size of opcode
000012AA                           417  *-----------------------------------------------------------
000012AA                           418  EA_TO_BUFFER:
000012AA  4282                     419              CLR.L   D2
000012AC  1403                     420              MOVE.B  D3, D2               ; move size of opcode to be manipulated
000012AE  6100 0002                421              BSR     EA_TO_BUFFER_LOOP
000012B2                           422  
000012B2                           423  EA_TO_BUFFER_LOOP:
000012B2  B43C 0000                424              CMP.B   #0, D2
000012B6  6700 0008                425              BEQ     EA_TO_BUFFER_END
000012BA  4EB8 1208                426              JSR     GRAB_NEXT_WORD
000012BE  5302                     427              SUB.B   #1, D2
000012C0                           428  
000012C0                           429  EA_TO_BUFFER_END:
000012C0  4E75                     430              RTS
000012C2                           431  
000012C2                           432  
000012C2                           433  *-------------------------DONE-------------------------------
000012C2                           434  DONE:
000012C2  4280                     435              CLR.L     D0
000012C4  103C 000E                436              MOVE.B    #14, D0
000012C8  43F8 1045                437              LEA.L     doneMsg, A1
000012CC  4E4F                     438              TRAP      #15
000012CE                           439m             CLR_A_REG D0, A1
000012D2                           440  
000012D2                           441              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BADINPUT            1052
BAD_OPCODE          1202
BYTE_TO_BUFFER      1290
CHECK_LENGTH        10E6
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      1118
CR                  D
DONE                12C2
DONEMSG             1045
EA_TO_BUFFER        12AA
EA_TO_BUFFER_END    12C0
EA_TO_BUFFER_LOOP   12B2
EA_TO_DN            1266
ENDADDR             106A
ENDMSG              1023
FIND_OPCODE         11EA
GET_END_ADDRESS     10BC
GET_INPUT           1090
GET_SIZE            1250
GET_START_ADDRESS   10A2
GRAB_FIRST_FOUR_BITS  1218
GRAB_NEXT_WORD      1208
IDENTIFY_OPCODE     11BE
INVALID_INPUT       10FA
ITERATE             114C
LETTER_TO_HEX       113E
LF                  A
LOAD_ADDRESSES      1192
LONG_TO_BUFFER      12A0
MAIN                1086
NUM_TO_HEX          1136
OPCODE              1082
OPC_0100            1228
OPC_1101            1228
OPOUTPUT            106E
OPTAG               1084
PRINT_MSG           0
PRINT_OPCODE        11DE
RESTORE_REGS        11D8
SIZE_TO_BUFFER      1274
STARTADDR           1066
STARTMSG            1000
STB_END             12A8
STORE_CHAR          1146
STORE_END           117E
STORE_INPUT         115A
STORE_START         116A
USERADDR            1062
VALID               1085
VALIDATE_INPUT      10D6
WORD_TO_BUFFER      1298
