00001278 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/10/2021 4:47:09 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00000000                            11              
00001000                            12              ORG     $1000
00001000                            13  
00001000  =0000000D                 14  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 15  LF          EQU     $0A 
00001000                            16  
00001000= 31 2E 20 41 64 64 ...     17  rule1:      DC.B    '1. Addresses must be in the range $FFFFFF > x > $6FFF', CR, LF, 0 ' 
00001038= 77 68 65 72 65 20 ...     18  rule1c:     DC.B    'where x is your given address.', CR, LF, 0 '
00001059= 32 2E 20 49 66 20 ...     19  rule2:      DC.B    '2. If you use any letters (A-F), make sure they are upper case.', CR, LF, 0
0000109B= 33 2E 20 49 66 20 ...     20  rule3:      DC.B    '3. If you use constants (DC), make sure you give addresses that', CR, LF, 0 
000010DD= 64 6F 20 6E 6F 74 ...     21  rule3c:     DC.B    'do not include that part of memory (only want to parse instructions).', CR, LF, 0
00001125= 50 6C 65 61 73 65 ...     22  startMsg:   DC.B    'Please enter a starting address.  ', CR, LF, 0
0000114A= 50 6C 65 61 73 65 ...     23  endMsg:     DC.B    'Please enter an ending address. ', CR, LF, 0
0000116D= 65 78 69 74 69 6E ...     24  doneMsg:    DC.B    'exiting...', CR, LF, 0
0000117A= 49 6E 76 61 6C 69 ...     25  badInput:   DC.B    'Invalid Input', CR, LF, 0
0000118A= 0D 0A 00                  26  newline:    DC.B    '', CR, LF, 0
0000118D                            27  
0000118E                            28  userAddr:   DS.L    1
00001192                            29  startAddr:  DS.L    1
00001196                            30  endAddr:    DS.L    1
0000119A                            31  
0000119A                            32  opcode:     DS.W    1   
0000119C                            33  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
0000119D                            34  opSize:     DS.B    1
0000119E                            35  valid:      DS.B    1
0000119F                            36  
0000119F                            37  ea_mode     DS.B    1
000011A0                            38  ea_register DS.B    1
000011A1                            39  ea_valid    DS.B    1
000011A2                            40  
000011A2                            41  
000011A2                            42  
000011A2                            43  
000011A2                            44  
000011A2                            45  
000011A2                            46  
000011A2                            47  *-----------------------------------------------------------
000011A2                            48  * Macros:
000011A2                            49  *-----------------------------------------------------------
000011A2                            50  
000011A2                            51  PRINT_MSG:  MACRO 
000011A2                            52              CLR.L   D0
000011A2                            53              LEA     \1, A1      ; \1 acts as a parameter
000011A2                            54              MOVE.B  #14, D0     
000011A2                            55              TRAP    #15
000011A2                            56              ENDM
000011A2                            57  
000011A2                            58  CLR_D_REGS: MACRO
000011A2                            59              CLR.L   D0
000011A2                            60              CLR.L   D1
000011A2                            61              CLR.L   D2
000011A2                            62              CLR.L   D3
000011A2                            63              CLR.L   D4
000011A2                            64              CLR.L   D5
000011A2                            65              CLR.L   D6
000011A2                            66              CLR.L   D7
000011A2                            67              ENDM
000011A2                            68  
000011A2                            69  CLR_A_REG:  MACRO
000011A2                            70              CLR.L   \1
000011A2                            71              MOVE.L  \1, \2
000011A2                            72              ENDM              
000011A2                            73  
000011A2                            74  *-----------------------------------------------------------
000011A2                            75  * Parameters:
000011A2                            76  *   \1 should be highest bit in range
000011A2                            77  *   \2 should be lowest bit in range
000011A2                            78  * 
000011A2                            79  * Example: #11, #9
000011A2                            80  *
000011A2                            81  * Return Value:
000011A2                            82  *   D4 = value held within bits \1 and \2
000011A2                            83  *
000011A2                            84  * Registers:
000011A2                            85  *   D4 = holds opcode
000011A2                            86  *   D5 = highest bit in range 
000011A2                            87  *   D6 = lowest bit in range 
000011A2                            88  *   D7 = number of bits we want
000011A2                            89  *-----------------------------------------------------------
000011A2                            90  GET_BITS:   MACRO
000011A2                            91  
000011A2                            92              CLR_D_REGS
000011A2                            93  
000011A2                            94              * Subtract value to find amount to shift by 
000011A2                            95              ADD.B   \1, D7          
000011A2                            96              SUB.B   \2, D7 
000011A2                            97              ADD.B   #1, D7  * add 1 because we start our count from 0
000011A2                            98  
000011A2                            99              * Get high bit offset
000011A2                           100              ADD.B   #15, D5
000011A2                           101              SUB.B   \1, D5
000011A2                           102              
000011A2                           103              * shift out high bits
000011A2                           104              MOVE.W  opcode, D4
000011A2                           105              LSL.W   D5, D4
000011A2                           106              
000011A2                           107              *get low bit offset
000011A2                           108              *16 - NUMBER OF BITS WE WANT
000011A2                           109              ADD.B   #16, D6         * 16 total bits
000011A2                           110              SUB.L   D7, D6          * subtract numBits from 16
000011A2                           111              
000011A2                           112              * shift out low bits
000011A2                           113              LSR.W   D6, D4          * isolate bits
000011A2                           114              ENDM
000011A2                           115  
000011A2                           116  *----------------------Value To Buffer----------------------
000011A2                           117  * Description:
000011A2                           118  * Converts a Hex numbered address (1-9 or A-F) back to an
000011A2                           119  * ASCII value and pushes it to the buffer for printing
000011A2                           120  *
000011A2                           121  * Parameters:
000011A2                           122  *   \1 = should hold value (in hex) you want to push to the buffer
000011A2                           123  *
000011A2                           124  *-----------------------------------------------------------
000011A2                           125  VALUE_TO_BUFFER:  MACRO
000011A2                           126                    MOVE.L  \1, D2  
000011A2                           127                    JSR     NUMBER_OR_LETTER
000011A2                           128                    ENDM
000011A2                           129  *-----------------------------------------------------------
000011A2                           130  
000011A2                           131  *----------------------Size To Buffer-----------------------
000011A2                           132  * Description:
000011A2                           133  * Converts a binary size (Byte = 00, Word = 01, or Long = 10) 
000011A2                           134  * to a letter (B, W, L) and pushes it to the buffer
000011A2                           135  *
000011A2                           136  * Parameters:
000011A2                           137  *   \1 = should hold size (in binary) of the size you want
000011A2                           138  *        to push to the buffer
000011A2                           139  *
000011A2                           140  *-----------------------------------------------------------
000011A2                           141  SIZE_TO_BUFFER:   MACRO
000011A2                           142                    MOVE.L  \1, D3
000011A2                           143                    JSR     FIND_SIZE
000011A2                           144                    ENDM
000011A2                           145  *-----------------------------------------------------------
000011A2                           146  
000011A2                           147  
000011A2                           148  
000011A2                           149  
000011A2                           150  
000011A2                           151  
000011A2                           152  *----------------Decoding EA Mode and Register--------------
000011A2                           153  * Description:
000011A2                           154  * Decodes EA mode and register and pushes to buffer
000011A2                           155  * 
000011A2                           156  * Parameters:
000011A2                           157  *   \1 = high bit of ea
000011A2                           158  *   \2 = low bit of ea
000011A2                           159  *
000011A2                           160  * Registers Used:
000011A2                           161  *   D1 = temp variable
000011A2                           162  *
000011A2                           163  * For Example (most common): 
000011A2                           164  *   DECODE_EA    #5, #0
000011A2                           165  *
000011A2                           166  *-----------------------------------------------------------
000011A2                           167  DECODE_EA:  MACRO
000011A2                           168              CLR_D_REGS
000011A2                           169              MOVE.B      \1, D1
000011A2                           170              JSR         DECODE_EA_HELP
000011A2                           171              JSR         EA_TO_BUFFER
000011A2                           172              ENDM
000011A2                           173  
000011A2                           174  GET_EA_MODE: MACRO
000011A2                           175               GET_BITS        \1, \2
000011A2                           176               MOVE.B          D4, ea_mode
000011A2                           177               ENDM
000011A2                           178  
000011A2                           179  GET_EA_REG:  MACRO
000011A2                           180               GET_BITS        \1, \2
000011A2                           181               MOVE.B          D4, ea_register
000011A2                           182               ENDM
000011A2                           183  *-----------------------------------------------------------
000011A2                           184  
000011A2                           185  *-----------------------------------------------------------
000011A2                           186  DECODE_EA_HELP:
000011A2                           187          
000011A2  B23C 0005                188              CMP.B       #5, D1               * is this bits 5-0?
000011A6  6700 000A                189              BEQ         DECODE_6_TO_0
000011AA                           190  
000011AA  B23C 000B                191              CMP.B       #11, D1              * is this bits 11-6? 
000011AE  6700 0064                192              BEQ         DECODE_11_TO_6
000011B2                           193  
000011B2                           194  DECODE_6_TO_0:
000011B2                           195m             GET_EA_MODE #5, #3               * get ea mode
000011C2                           196mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011C8                           197mm             * GET HIGH BIT OFFSET
000011CE                           198mm             * SHIFT OUT HIGH BITS
000011D4                           199mm             *GET LOW BIT OFFSET
000011D4                           200mm             *16 - NUMBER OF BITS WE WANT
000011DA                           201mm             * SHIFT OUT LOW BITS
000011E0                           202m             GET_EA_REG  #2, #0               * get ea register
000011F0                           203mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011F8                           204mm             * GET HIGH BIT OFFSET
000011FE                           205mm             * SHIFT OUT HIGH BITS
00001204                           206mm             *GET LOW BIT OFFSET
00001204                           207mm             *16 - NUMBER OF BITS WE WANT
0000120A                           208mm             * SHIFT OUT LOW BITS
00001210  6000 0064                209              BRA         EA_END
00001214                           210  
00001214                           211  DECODE_11_TO_6:
00001214                           212m             GET_EA_MODE #8, #6               * get ea mode
00001224                           213mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000122A                           214mm             * GET HIGH BIT OFFSET
00001230                           215mm             * SHIFT OUT HIGH BITS
00001236                           216mm             *GET LOW BIT OFFSET
00001236                           217mm             *16 - NUMBER OF BITS WE WANT
0000123C                           218mm             * SHIFT OUT LOW BITS
00001242                           219m             GET_EA_REG  #11, #9              * get ea register
00001252                           220mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000125C                           221mm             * GET HIGH BIT OFFSET
00001264                           222mm             * SHIFT OUT HIGH BITS
0000126A                           223mm             *GET LOW BIT OFFSET
0000126A                           224mm             *16 - NUMBER OF BITS WE WANT
00001270                           225mm             * SHIFT OUT LOW BITS
00001276                           226  
00001276                           227  EA_END:
00001276  4E75                     228              RTS
00001278                           229  
00001278                           230  *-----------------------------------------------------------            
00001278                           231  
00001278                           232  
00001278                           233  
00001278                           234  
00001278                           235  
00001278                           236  *----------------------Buffer Macros------------------------
00001278                           237  * Description:
00001278                           238  * Pushes commonly used single characters to the buffer
00001278                           239  *-----------------------------------------------------------
00001278                           240  INSERT_SPACE:   MACRO
00001278                           241                  MOVE.B  #' ',(A1)+          * add blank space to buffer
00001278                           242                  ENDM
00001278                           243  
00001278                           244  INSERT_COMMA:   MACRO
00001278                           245                  MOVE.B  #',',(A1)+          * add blank space to buffer
00001278                           246                  ENDM
00001278                           247  
00001278                           248  INSERT_PERIOD:  MACRO
00001278                           249                  MOVE.B  #'.',(A1)+          * add blank space to buffer
00001278                           250                  ENDM
00001278                           251  
00001278                           252  INSERT_POUND:   MACRO
00001278                           253                  MOVE.B  #'#',(A1)+          * add blank space to buffer
00001278                           254                  ENDM
00001278                           255  
00001278                           256  INSERT_DOLLAR:  MACRO
00001278                           257                  MOVE.B  #'$',(A1)+          * add blank space to buffer
00001278                           258                  ENDM
00001278                           259  *-----------------------------------------------------------
00001278                           260  
00001278                           261  
00001278                           262  
00001278                           263  
00001278                           264  
00001278                           265  
00001278                           266  
00001278                           267  
00001278                           268  
00001278                           269  *-----------------------------------------------------------
00001278                           270  * Description:  
00001278                           271  * Main routine
00001278                           272  *-----------------------------------------------------------
00001278                           273  
00001278                           274  *-------------------------MAIN------------------------------
00001278                           275  MAIN:
00001278                           276m             PRINT_MSG    rule1
00001284                           277m             PRINT_MSG    rule1c                   
00001290                           278m             PRINT_MSG    rule2
0000129C                           279m             PRINT_MSG    rule3
000012A8                           280m             PRINT_MSG    rule3c
000012B4  6100 000A                281              BSR          GET_INPUT
000012B8  6100 0074                282              BSR          CHECK_ADDRESS
000012BC  6000 018C                283              BRA          LOAD_ADDRESSES
000012C0                           284  *-----------------------------------------------------------
000012C0                           285  
000012C0                           286  
000012C0                           287  
000012C0                           288  
000012C0                           289  
000012C0                           290  
000012C0                           291  
000012C0                           292  
000012C0                           293  *-----------------------------------------------------------
000012C0                           294  * Description:  
000012C0                           295  * Get User Input
000012C0                           296  *
000012C0                           297  * Registers Used:
000012C0                           298  *   D0 = task values
000012C0                           299  *   D1 = stores of size of ascii string in A1 from user input
000012C0                           300  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000012C0                           301  *   A1 = stores an ascii string from user input
000012C0                           302  *-----------------------------------------------------------
000012C0                           303  *-------------------------Get Input-------------------------
000012C0                           304  GET_INPUT:
000012C0                           305m             PRINT_MSG    startMsg
000012CC  6100 002C                306              BSR          GET_ADDRESS   
000012D0  21C7 1192                307              MOVE.L       D7, startAddr
000012D4                           308  
000012D4                           309m             CLR_D_REGS
000012E4                           310  
000012E4                           311m             PRINT_MSG    endMsg
000012F0  6100 0008                312              BSR          GET_ADDRESS   
000012F4  21C7 1196                313              MOVE.L       D7, endAddr
000012F8  4E75                     314              RTS 
000012FA                           315  *-----------------------------------------------------------
000012FA                           316  
000012FA                           317  *------------------------Get Address------------------------
000012FA                           318  GET_ADDRESS:
000012FA  43F8 118E                319              LEA.L   userAddr, A1
000012FE  103C 0002                320              MOVE.B  #2, D0
00001302  4E4F                     321              TRAP    #15
00001304                           322  
00001304  6100 0008                323              BSR     CHECK_LENGTH
00001308  6100 0054                324              BSR     CONVERT_TO_HEX
0000130C  4E75                     325              RTS
0000130E                           326  *-----------------------------------------------------------
0000130E                           327  
0000130E                           328  
0000130E                           329  
0000130E                           330  
0000130E                           331  
0000130E                           332  
0000130E                           333  
0000130E                           334  
0000130E                           335  
0000130E                           336  
0000130E                           337  *-----------------------------------------------------------
0000130E                           338  * Description:  Validate User Input
0000130E                           339  * Constraints:  
0000130E                           340  *   User input must be:
0000130E                           341  *   Length 4 or Length 8
0000130E                           342  *   ASCII character 0-9 or A-F
0000130E                           343  *   Starting and ending address with value < $00FFFFFF 
0000130E                           344  *   Starting address is before ending address
0000130E                           345  *
0000130E                           346  * Registers Used:
0000130E                           347  *   D0 = task values
0000130E                           348  *   D1 = stores of size of ascii string in A1 from user input
0000130E                           349  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
0000130E                           350  *   A1 = stores an ascii string from user input
0000130E                           351  *-----------------------------------------------------------
0000130E                           352  
0000130E                           353  *----------------------VALIDATE INPUT---------------------------      
0000130E                           354  CHECK_LENGTH:
0000130E  B23C 0001                355              CMP.B      #1, D1               ; for task 2, length of string is in D1                
00001312  6D00 000C                356              BLT        INVALID_INPUT 
00001316  B23C 0008                357              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
0000131A  6E00 0004                358              BGT        INVALID_INPUT
0000131E  4E75                     359              RTS
00001320                           360  
00001320                           361  INVALID_INPUT:  
00001320                           362m             PRINT_MSG  badInput
0000132C  6092                     363              BRA        GET_INPUT
0000132E                           364  *-----------------------------------------------------------
0000132E                           365  
0000132E                           366  *----------------------VALIDATE INPUT---------------------------      
0000132E                           367  CHECK_ADDRESS:
0000132E  2A38 1192                368              MOVE.L     startAddr, D5
00001332  BAB8 1196                369              CMP.L      endAddr, D5          ; starting address >= ending address?
00001336  6C00 0016                370              BGE        INVALID_ADDRESS
0000133A                           371  
0000133A  BABC 00006FFF            372              CMP.L      #$6FFF, D5
00001340  6FDE                     373              BLE        INVALID_INPUT 
00001342                           374              
00001342  0CB8 00FFFFFF 1196       375              CMP.L      #$FFFFFF, endAddr
0000134A  6CD4                     376              BGE        INVALID_INPUT
0000134C  4E75                     377              RTS
0000134E                           378  
0000134E                           379  INVALID_ADDRESS:  
0000134E                           380m             PRINT_MSG  badInput
0000135A  6000 FF64                381              BRA        GET_INPUT
0000135E                           382  *-----------------------------------------------------------
0000135E                           383  
0000135E                           384  *----------------CONVERT FROM ASCII TO HEX------------------
0000135E                           385  CONVERT_TO_HEX:
0000135E  0C11 0030                386              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001362  6DBC                     387              BLT        INVALID_INPUT        
00001364                           388  
00001364  0C11 003A                389              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001368  6D00 0012                390              BLT        NUM_TO_HEX      
0000136C                           391  
0000136C  0C11 0041                392              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001370  6DAE                     393              BLT        INVALID_INPUT             
00001372                           394  
00001372  0C11 0047                395              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001376  6D00 000C                396              BLT        LETTER_TO_HEX
0000137A                           397  
0000137A  60A4                     398              BRA        INVALID_INPUT    
0000137C                           399  
0000137C                           400  NUM_TO_HEX:      
0000137C  0411 0030                401              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001380  6000 000A                402              BRA        STORE_CHAR   
00001384                           403  
00001384                           404  LETTER_TO_HEX:     
00001384  0411 0037                405              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001388  6000 0002                406              BRA        STORE_CHAR
0000138C                           407  
0000138C                           408  STORE_CHAR:       
0000138C  D619                     409              ADD.B      (A1)+, D3           ; keep hex stored in D3           
0000138E  6000 0002                410              BRA        ITERATE                 
00001392                           411  
00001392                           412  ITERATE:
00001392  5301                     413              SUB.B      #$1, D1
00001394  B23C 0000                414              CMP.B      #0, D1
00001398  6700 0006                415              BEQ        STORE_INPUT
0000139C                           416  
0000139C  E98B                     417              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000139E  60BE                     418              BRA        CONVERT_TO_HEX
000013A0                           419  
000013A0                           420  STORE_INPUT:
000013A0  2E03                     421              MOVE.L     D3, D7
000013A2  4E75                     422              RTS
000013A4                           423  *-----------------------------------------------------------
000013A4                           424  
000013A4                           425  
000013A4                           426  
000013A4                           427  
000013A4                           428  
000013A4                           429  
000013A4                           430  
000013A4                           431  
000013A4                           432  
000013A4                           433  
000013A4                           434  
000013A4                           435  *--------------------------PRINT----------------------------
000013A4                           436  * Description:
000013A4                           437  * Prints hex addresses according to where we are in the .S file
000013A4                           438  * and source/destination effective addresses
000013A4                           439  *
000013A4                           440  * No Parameters
000013A4                           441  *
000013A4                           442  * Registers:
000013A4                           443  *   D0 = used for tasks and trap #15
000013A4                           444  *   D1 = size of comparison
000013A4                           445  *   D2 = destination for comparisons, holds an address
000013A4                           446  *   D3 = iterator
000013A4                           447  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000013A4                           448  *   A2 = current address (given by user)
000013A4                           449  *-----------------------------------------------------------
000013A4                           450  
000013A4                           451  *----------------------PRINT_ADDRESS------------------------
000013A4                           452  PRINT_ADDRESS:
000013A4                           453              * reset A1 to beginning of string
000013A4                           454m             CLR_D_REGS
000013B4                           455m             CLR_A_REG D0, A1
000013B8                           456              
000013B8                           457              * move current address to D2
000013B8  240A                     458              MOVE.L    A2, D2
000013BA                           459  
000013BA                           460              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
000013BA  223C 00008000            461              MOVE.L    #$8000, D1
000013C0  B481                     462              CMP.L     D1, D2
000013C2  6D00 000E                463              BLT       PRINT_WORD
000013C6                           464              
000013C6                           465              * if absolute long, print long. Range $8000 - $FFFF7FFF
000013C6  223C FFFF8000            466              MOVE.L    #$FFFF8000, D1
000013CC  B481                     467              CMP.L     D1, D2
000013CE  6C00 001C                468              BGE       PRINT_LONG                 
000013D2                           469  
000013D2                           470  PRINT_WORD:
000013D2                           471m             CLR_D_REGS
000013E2  123C 0001                472              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000013E6  3E0A                     473              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000013E8  6000 001C                474              BRA       FINISH_PRINT
000013EC                           475  
000013EC                           476  PRINT_LONG:
000013EC                           477m             CLR_D_REGS
000013FC  123C 0003                478              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
00001400  2E0A                     479              MOVE.L    A2, D7
00001402  6000 0002                480              BRA       FINISH_PRINT
00001406                           481  
00001406                           482  FINISH_PRINT:
00001406                           483              * convert hex values back to ASCII
00001406  4EB9 00001C80            484              JSR       HEX_TO_ASCII
0000140C                           485              
0000140C                           486              * print out string
0000140C  12BC 0000                487              MOVE.B    #00,(A1)
00001410                           488m             CLR_D_REGS
00001420                           489m             CLR_A_REG D0, A1
00001424  103C 000E                490              MOVE.B    #14, D0
00001428  4E4F                     491              TRAP      #15
0000142A  4E75                     492              RTS
0000142C                           493  *-----------------------------------------------------------
0000142C                           494  
0000142C                           495  *-------------------PRINT_INSTRUCTION-----------------------
0000142C                           496  PRINT_INSTRUCTION:    
0000142C                           497              * null terminator
0000142C  12BC 0000                498              MOVE.B    #00,(A1)              
00001430                           499  
00001430                           500              * reset A1 to beginning of string
00001430  4280                     501              CLR.L     D0
00001432                           502m             CLR_A_REG D0, A1
00001436                           503  
00001436                           504              * print out string
00001436  103C 000E                505              MOVE.B    #14, D0
0000143A  4E4F                     506              TRAP      #15
0000143C                           507  
0000143C                           508m             PRINT_MSG newline
00001448  4E75                     509              RTS
0000144A                           510  *-----------------------------------------------------------
0000144A                           511  
0000144A                           512  
0000144A                           513  
0000144A                           514  
0000144A                           515  
0000144A                           516  
0000144A                           517  
0000144A                           518  
0000144A                           519  
0000144A                           520  
0000144A                           521  
0000144A                           522  
0000144A                           523  
0000144A                           524  
0000144A                           525  
0000144A                           526  
0000144A                           527  
0000144A                           528  
0000144A                           529  
0000144A                           530  
0000144A                           531  *---------------------LOAD ADDRESSES------------------------
0000144A                           532  * Description:
0000144A                           533  * Stores INITIAL values into appropriate address registers 
0000144A                           534  * which is necessary to complete before starting identify opcodes loop
0000144A                           535  * Also pushes reigsters onto the stack
0000144A                           536  *
0000144A                           537  * No Parameters
0000144A                           538  *
0000144A                           539  * Registers:
0000144A                           540  *   A2 = current address (given by user)
0000144A                           541  *   A3 = ending address (given by user)
0000144A                           542  *-----------------------------------------------------------
0000144A                           543  LOAD_ADDRESSES: 
0000144A                           544              * reset A1 to beginning of string
0000144A  4280                     545              CLR.L       D0
0000144C                           546m             CLR_A_REG   D0, A1
00001450                           547  
00001450                           548              * load start and end registers and print starting address
00001450  2478 1192                549              MOVEA.L     startAddr, A2
00001454  2678 1196                550              MOVEA.L     endAddr, A3
00001458  6100 FF4A                551              BSR         PRINT_ADDRESS
0000145C                           552m             INSERT_SPACE
00001460                           553  
00001460  6100 0040                554              BSR         GRAB_NEXT_WORD
00001464  6100 0042                555              BSR         GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
00001468                           556  
00001468                           557              * Push current registers onto the stack (so we can have fresh registers)
00001468  48E7 FF00                558              MOVEM.L D0-D7,-(SP)                  ; move the old registers onto the stack
0000146C  6000 004C                559              BRA     FIND_OPCODE
00001470                           560  *-----------------------------------------------------------
00001470                           561  
00001470                           562  *-----------------------------------------------------------
00001470                           563  * Description:  IDENTIFY OPCODES LOOP
00001470                           564  * Registers:
00001470                           565  *   D0 = used for tasks and trap #15
00001470                           566  *   D1 = size of shifting bits
00001470                           567  *   D2 = destination for shifts
00001470                           568  *   D3 = size of opcode
00001470                           569  *   D4 = used to hold bits returned from SHIFT macro
00001470                           570  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001470                           571  *   A2 = current address (given by user)
00001470                           572  *   A3 = ending address (given by user)
00001470                           573  *-----------------------------------------------------------
00001470                           574  *-------------------IDENTIFY OPCODES------------------------
00001470                           575  * evaluates an opcode based on first four bits (aka opTag)
00001470                           576  * for now only works with one instruction
00001470                           577  *-----------------------------------------------------------
00001470                           578  IDENTIFY_OPCODE:
00001470                           579  
00001470                           580              * print opcode
00001470  61BA                     581              BSR     PRINT_INSTRUCTION
00001472                           582  
00001472                           583              * check if starting address >= ending address
00001472  B5CB                     584              CMPA.L  A3, A2
00001474  6C00 08B0                585              BGE     DONE
00001478                           586              
00001478                           587              * print next address
00001478  6100 FF2A                588              BSR     PRINT_ADDRESS
0000147C                           589m             INSERT_SPACE
00001480                           590              
00001480                           591              ;BSR     RESTORE_REGS           need to fix
00001480                           592  
00001480                           593m             CLR_D_REGS
00001490  6100 0010                594              BSR     GRAB_NEXT_WORD          * grab opcode
00001494  6100 0012                595              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
00001498                           596             
00001498  6000 0020                597              BRA     FIND_OPCODE
0000149C                           598  *------------------------------------------------------------
0000149C                           599  
0000149C                           600  *----------------------RESTORE_REGS--------------------------
0000149C                           601  * Description:
0000149C                           602  * Move the old registers onto the stack
0000149C                           603  *------------------------------------------------------------
0000149C                           604  RESTORE_REGS:
0000149C  4CDF 00FF                605              MOVEM.L (SP)+, D0-D7            
000014A0  4E75                     606              RTS
000014A2                           607  *-----------------------------------------------------------
000014A2                           608  
000014A2                           609  *---------Useful Subroutines For Identifying Opcodes--------
000014A2                           610  GRAB_NEXT_WORD:
000014A2                           611              * load current word of bits into D7
000014A2  31DA 119A                612              MOVE.W (A2)+, opcode
000014A6  4E75                     613              RTS
000014A8                           614  
000014A8                           615  GRAB_FIRST_FOUR_BITS:
000014A8                           616              * find first four bits of opcode
000014A8  3438 119A                617              MOVE.W  opcode, D2
000014AC  123C 000C                618              MOVE.B  #12, D1
000014B0  E2AA                     619              LSR.L   D1, D2
000014B2  1002                     620              MOVE.B  D2, D0
000014B4  11C0 119C                621              MOVE.B  D0, opTag
000014B8  4E75                     622              RTS
000014BA                           623  *-----------------------------------------------------------
000014BA                           624  
000014BA                           625  
000014BA                           626  
000014BA                           627  
000014BA                           628  
000014BA                           629  
000014BA                           630  
000014BA                           631  
000014BA                           632  
000014BA                           633  *----------------------FIND OPCODE--------------------------
000014BA                           634  * Description:
000014BA                           635  * Finds a matching opTag (first four bits of opcode) and 
000014BA                           636  * jumps to that opcode's encoding subroutine
000014BA                           637  *
000014BA                           638  * For example:
000014BA                           639  *               ADD's first four bits = 1101, so I put
000014BA                           640  *               CMP.B #%1101, D0
000014BA                           641  *
000014BA                           642  * No Parameters
000014BA                           643  *
000014BA                           644  * No Registers Used
000014BA                           645  *-----------------------------------------------------------        
000014BA                           646  FIND_OPCODE:
000014BA  0C38 0000 119C           647              CMP.B   #%0000, opTag 
000014C0  6700 0066                648              BEQ     OPC_0000
000014C4                           649  
000014C4  0C38 0001 119C           650              CMP.B   #%0001, opTag 
000014CA  6700 0158                651              BEQ     OPC_0001
000014CE                           652  
000014CE  0C38 0002 119C           653              CMP.B   #%0010, opTag 
000014D4  6700 0178                654              BEQ     OPC_0010
000014D8                           655  
000014D8  0C38 0003 119C           656              CMP.B   #%0011, opTag 
000014DE  6700 0198                657              BEQ     OPC_0011
000014E2                           658  
000014E2  0C38 0004 119C           659              CMP.B   #%0100, opTag 
000014E8  6700 01FE                660              BEQ     OPC_0100
000014EC                           661  
000014EC  0C38 0005 119C           662              CMP.B   #%0101, opTag 
000014F2  6700 038C                663              BEQ     OPC_0101
000014F6                           664  
000014F6  0C38 0008 119C           665              CMP.B   #%1000, opTag
000014FC  6700 0350                666              BEQ     OPC_1000
00001500                           667  
00001500  0C38 0009 119C           668              CMP.B   #%1001, opTag
00001506  6700 0486                669              BEQ     OPC_1001
0000150A                           670  
0000150A  0C38 000C 119C           671              CMP.B   #%1100, opTag
00001510  6700 0490                672              BEQ     OPC_1100
00001514                           673  
00001514  0C38 000D 119C           674              CMP.B   #%1101, opTag
0000151A  6700 04FE                675              BEQ     OPC_1101
0000151E                           676  
0000151E                           677              * error, bad opcode
0000151E  6000 0002                678              BRA      BAD_OPCODE
00001522                           679  
00001522                           680  *-----------------------------------------------------------
00001522                           681  
00001522                           682  *-----------------------BAD OPCODE--------------------------
00001522                           683  BAD_OPCODE:
00001522  4EF9 00001D26            684              JMP      DONE
00001528                           685  *-----------------------------------------------------------
00001528                           686  
00001528                           687  *------------------------OPC_0000---------------------------
00001528                           688  * First four bits = 0000
00001528                           689  * (ADDI, SUBI)
00001528                           690  *-----------------------------------------------------------
00001528                           691  OPC_0000:
00001528                           692m             GET_BITS  #11, #8
00001538                           693m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001540                           694m             * GET HIGH BIT OFFSET
00001548                           695m             * SHIFT OUT HIGH BITS
0000154E                           696m             *GET LOW BIT OFFSET
0000154E                           697m             *16 - NUMBER OF BITS WE WANT
00001554                           698m             * SHIFT OUT LOW BITS
00001556                           699              
00001556                           700              * is the opcode ADDI?
00001556  B83C 0006                701              CMP.B     #%0110, D4
0000155A  6700 000E                702              BEQ       OPC_ADDI
0000155E                           703  
0000155E                           704              * is the opcode SUBI?
0000155E  B83C 0004                705              CMP.B     #%0100, D4
00001562  6700 001E                706              BEQ       OPC_SUBI
00001566                           707  
00001566  4EF8 1522                708              JMP       BAD_OPCODE
0000156A                           709  
0000156A                           710  *------------------------OPC_ADDI---------------------------
0000156A                           711  OPC_ADDI:
0000156A  12FC 0041                712              MOVE.B  #'A',(A1)+          * Put ADD into Buff
0000156E  12FC 0044                713              MOVE.B  #'D',(A1)+
00001572  12FC 0044                714              MOVE.B  #'D',(A1)+
00001576  12FC 0049                715              MOVE.B  #'I',(A1)+
0000157A                           716m             INSERT_PERIOD
0000157E                           717  
0000157E  6100 001A                718              BSR     DECODE_IMMEDIATE
00001582                           719  
00001582                           720  *------------------------OPC_SUBI---------------------------
00001582                           721  OPC_SUBI:            
00001582  12FC 0053                722              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001586  12FC 0055                723              MOVE.B  #'U',(A1)+
0000158A  12FC 0042                724              MOVE.B  #'B',(A1)+
0000158E  12FC 0049                725              MOVE.B  #'I',(A1)+
00001592                           726m             INSERT_PERIOD
00001596                           727  
00001596  6100 0002                728              BSR     DECODE_IMMEDIATE
0000159A                           729  
0000159A                           730  *--------------Subroutines for OPC_0000---------------------  
0000159A                           731  DECODE_IMMEDIATE:
0000159A                           732              * push size to buffer
0000159A                           733m             GET_BITS        #7, #6              * get size bits (gets returned to D4)
000015AA                           734m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000015B0                           735m             * GET HIGH BIT OFFSET
000015B6                           736m             * SHIFT OUT HIGH BITS
000015BC                           737m             *GET LOW BIT OFFSET
000015BC                           738m             *16 - NUMBER OF BITS WE WANT
000015C2                           739m             * SHIFT OUT LOW BITS
000015C4  11C4 119D                740              MOVE.B          D4, opSize
000015C8                           741m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000015D0                           742  
000015D0                           743              * push #<data> to buffer
000015D0  4EB9 00001600            744              JSR             CHECK_IMMEDIATE
000015D6                           745  
000015D6                           746m             INSERT_COMMA
000015DA                           747m             INSERT_SPACE
000015DE                           748  
000015DE                           749              * push <ea> to buffer
000015DE                           750m             DECODE_EA       #5, #0
000015FC  6000 FE72                751              BRA             IDENTIFY_OPCODE
00001600                           752   
00001600                           753  CHECK_IMMEDIATE:
00001600                           754m             INSERT_POUND
00001604                           755  
00001604  B67C 0001                756              CMP     #1, D3
00001608  6F00 000A                757              BLE     IMMEDIATE_WORD
0000160C                           758  
0000160C  B67C 0002                759              CMP     #2, D3
00001610  6000 000A                760              BRA     IMMEDIATE_LONG
00001614                           761  
00001614                           762  IMMEDIATE_WORD:
00001614  4EB9 00001C34            763              JSR     EA_WORD
0000161A  4E75                     764              RTS
0000161C                           765  
0000161C                           766  IMMEDIATE_LONG:
0000161C  4EB9 00001C48            767              JSR     EA_LONG      
00001622  4E75                     768              RTS
00001624                           769  *-----------------------------------------------------------
00001624                           770  
00001624                           771  *------------------------OPC_0001---------------------------
00001624                           772  * First four bits = 0001
00001624                           773  * (MOVE.B)
00001624                           774  *-----------------------------------------------------------
00001624                           775  OPC_0001:
00001624  12FC 004D                776              MOVE.B   #'M',(A1)+          * Put ADD into Buff
00001628  12FC 004F                777              MOVE.B   #'O',(A1)+
0000162C  12FC 0056                778              MOVE.B   #'V',(A1)+
00001630  12FC 0045                779              MOVE.B   #'E',(A1)+
00001634  12FC 002E                780              MOVE.B   #'.',(A1)+
00001638  12FC 0042                781              MOVE.B   #'B',(A1)+
0000163C                           782m             INSERT_SPACE
00001640                           783  
00001640  11FC 0000 119D           784              MOVE.B   #0, opSize
00001646                           785  
00001646  6100 005A                786              BSR      DECODE_MOVE
0000164A  6000 FE24                787              BRA      IDENTIFY_OPCODE
0000164E                           788  *-----------------------------------------------------------
0000164E                           789  
0000164E                           790  *------------------------OPC_0010---------------------------
0000164E                           791  * First four bits = 0010
0000164E                           792  * (MOVE.L)
0000164E                           793  *-----------------------------------------------------------
0000164E                           794  OPC_0010:
0000164E  12FC 004D                795              MOVE.B  #'M',(A1)+          * Put ADD into Buff
00001652  12FC 004F                796              MOVE.B  #'O',(A1)+
00001656  12FC 0056                797              MOVE.B  #'V',(A1)+
0000165A  12FC 0045                798              MOVE.B  #'E',(A1)+
0000165E  12FC 002E                799              MOVE.B  #'.',(A1)+
00001662  12FC 004C                800              MOVE.B  #'L',(A1)+
00001666                           801m             INSERT_SPACE
0000166A                           802  
0000166A  11FC 0002 119D           803              MOVE.B   #2, opSize
00001670                           804  
00001670  6100 0030                805              BSR      DECODE_MOVE
00001674  6000 FDFA                806              BRA      IDENTIFY_OPCODE
00001678                           807  *-----------------------------------------------------------
00001678                           808  
00001678                           809  *------------------------OPC_0011---------------------------
00001678                           810  * First four bits = 0011
00001678                           811  * (MOVE.W)
00001678                           812  *-----------------------------------------------------------
00001678                           813  OPC_0011:
00001678  12FC 004D                814              MOVE.B  #'M',(A1)+          * Put ADD into Buff
0000167C  12FC 004F                815              MOVE.B  #'O',(A1)+
00001680  12FC 0056                816              MOVE.B  #'V',(A1)+
00001684  12FC 0045                817              MOVE.B  #'E',(A1)+
00001688  12FC 002E                818              MOVE.B  #'.',(A1)+
0000168C  12FC 0057                819              MOVE.B  #'W',(A1)+
00001690                           820m             INSERT_SPACE
00001694                           821  
00001694  11FC 0001 119D           822              MOVE.B   #1, opSize
0000169A                           823  
0000169A  6100 0006                824              BSR      DECODE_MOVE
0000169E  6000 FDD0                825              BRA      IDENTIFY_OPCODE
000016A2                           826  *-----------------------------------------------------------
000016A2                           827  
000016A2                           828  *---------------------Decode Move---------------------------
000016A2                           829  DECODE_MOVE:
000016A2                           830m             DECODE_EA       #5, #0
000016C0                           831              
000016C0                           832m             INSERT_COMMA
000016C4                           833m             INSERT_SPACE
000016C8                           834  
000016C8                           835m             DECODE_EA       #11, #6
000016E6  4E75                     836              RTS
000016E8                           837  *-----------------------------------------------------------
000016E8                           838  
000016E8                           839  *------------------------OPC_0100---------------------------
000016E8                           840  * First four bits = 0100
000016E8                           841  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
000016E8                           842  *-----------------------------------------------------------
000016E8                           843  OPC_0100:
000016E8                           844  
000016E8                           845              * Check if the opcode is NOP
000016E8  3438 119A                846              MOVE.W  opcode, D2              * Copy opcode to D2
000016EC  B47C 4E71                847              CMP.W   #$4E71, D2              * Check if D2 is equal to NOP (0x4E71 in hex)
000016F0  6700 0054                848              BEQ     OPC_NOP                 * If equal branch to label to handle the opcode NOP
000016F4                           849              
000016F4                           850              * Check if the opcode is NOT
000016F4  E082                     851              ASR.L   #8, D2                  * Shift bits to compare
000016F6  B43C 0046                852              CMP.B   #%01000110, D2
000016FA  6700 005A                853              BEQ     OPC_NOT
000016FE  4282                     854              CLR.L   D2
00001700                           855              
00001700                           856              * Check if the opcode is LEA
00001700  3838 119A                857              MOVE.W   opcode, D4             * Put opcode in D4 to use the macro get bits
00001704                           858m             GET_BITS #8, #6 
00001714                           859m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000171A                           860m             * GET HIGH BIT OFFSET
00001720                           861m             * SHIFT OUT HIGH BITS
00001726                           862m             *GET LOW BIT OFFSET
00001726                           863m             *16 - NUMBER OF BITS WE WANT
0000172C                           864m             * SHIFT OUT LOW BITS
0000172E  B83C 0007                865              CMP.B    #%0111, D4              * if bits 6-8 are equal to 111, then the opocde is LEA
00001732  6700 008A                866              BEQ      OPC_LEA
00001736                           867  
00001736                           868              * Check if the opcode is JSR
00001736  B83C 0002                869              CMP.B   #%0010, D4              * if bits 6-8 are equal to 010, then the opocde is LEA
0000173A  6700 00D0                870              BEQ     OPC_JSR
0000173E                           871  
0000173E                           872              * Check if the opcode is RTS
0000173E  B83C 0001                873              CMP.B   #%0001, D4              * if bits 6-8 are equal to 001, then the opocde is LEA
00001742  6700 00FA                874              BEQ     OPC_RTS
00001746                           875  
00001746                           876  *---------------------------OPC_NOP--------------------------------
00001746                           877  
00001746                           878  OPC_NOP:
00001746                           879              * Put NOP into A1 buffer for printing
00001746  12FC 004E                880              MOVE.B  #'N',(A1)+      
0000174A  12FC 004F                881              MOVE.B  #'O',(A1)+ 
0000174E  12FC 0050                882              MOVE.B  #'P',(A1)+ 
00001752                           883              
00001752  6000 FD1C                884              BRA     IDENTIFY_OPCODE
00001756                           885  
00001756                           886  
00001756                           887  *-----------------------------OPC_NOT------------------------------
00001756                           888  
00001756                           889  OPC_NOT:
00001756                           890              * Put NOT into A1 buffer for printing
00001756  12FC 004E                891              MOVE.B  #'N',(A1)+ 
0000175A  12FC 004F                892              MOVE.B  #'O',(A1)+
0000175E  12FC 0054                893              MOVE.B  #'T',(A1)+
00001762                           894m             INSERT_PERIOD
00001766                           895              
00001766                           896              * Calculate Size (.b,.w.l)
00001766                           897m             GET_BITS        #7, #6
00001776                           898m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000177C                           899m             * GET HIGH BIT OFFSET
00001782                           900m             * SHIFT OUT HIGH BITS
00001788                           901m             *GET LOW BIT OFFSET
00001788                           902m             *16 - NUMBER OF BITS WE WANT
0000178E                           903m             * SHIFT OUT LOW BITS
00001790  11C4 119D                904              MOVE.B          D4, opSize
00001794                           905m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
0000179C                           906m             DECODE_EA       #5, #0
000017BA  6000 FCB4                907              BRA             IDENTIFY_OPCODE
000017BE                           908  
000017BE                           909  *-----------------------------OPC_LEA------------------------------
000017BE                           910  OPC_LEA:
000017BE                           911              * Put LEA into A1 buffer for printing
000017BE  12FC 004C                912              MOVE.B  #'L',(A1)+      
000017C2  12FC 0045                913              MOVE.B  #'E',(A1)+ 
000017C6  12FC 0041                914              MOVE.B  #'A',(A1)+
000017CA                           915m             INSERT_PERIOD
000017CE  12FC 004C                916              MOVE.B  #'L',(A1)+ 
000017D2                           917m             INSERT_SPACE
000017D6                           918  
000017D6  11FC 0002 119D           919              MOVE.B          #2, opSize      * required to always be long operation
000017DC                           920                      
000017DC                           921m             DECODE_EA       #5, #0
000017FA                           922m             INSERT_COMMA
000017FE                           923m             INSERT_SPACE
00001802  4EB9 00001B06            924              JSR GET_DATA_REG_NUM
00001808                           925  
00001808  6000 FC66                926              BRA IDENTIFY_OPCODE    
0000180C                           927  
0000180C                           928  
0000180C                           929  *-----------------------------------------------------------
0000180C                           930  
0000180C                           931  *-----------------------------OPC_JSR------------------------------
0000180C                           932  OPC_JSR:
0000180C                           933              * Put LEA into A1 buffer for printing
0000180C  12FC 004A                934              MOVE.B  #'J',(A1)+      
00001810  12FC 0053                935              MOVE.B  #'S',(A1)+ 
00001814  12FC 0052                936              MOVE.B  #'R',(A1)+
00001818                           937m             INSERT_SPACE
0000181C                           938              
0000181C                           939m             DECODE_EA       #5, #0
0000183A  6000 FC34                940              BRA             IDENTIFY_OPCODE  
0000183E                           941  
0000183E                           942  *-----------------------------OPC_RTS------------------------------
0000183E                           943  OPC_RTS:
0000183E                           944              * Put LEA into A1 buffer for printing
0000183E  12FC 0052                945              MOVE.B  #'R',(A1)+      
00001842  12FC 0054                946              MOVE.B  #'T',(A1)+ 
00001846  12FC 0053                947              MOVE.B  #'S',(A1)+
0000184A                           948          
0000184A  6000 FC24                949              BRA IDENTIFY_OPCODE
0000184E                           950  
0000184E                           951  *-----------------------------------------------------------
0000184E                           952  
0000184E                           953  *---------------------------OPC_1000------------------------
0000184E                           954  * First four bits = 1001
0000184E                           955  * (DIVU)
0000184E                           956  *-----------------------------------------------------------
0000184E                           957  OPC_1000:   * keeping this in case there's more that start with 1000
0000184E  6000 0002                958              BRA     OPC_DIVU
00001852                           959              
00001852                           960  OPC_DIVU:
00001852  12FC 0044                961              MOVE.B  #'D',(A1)+
00001856  12FC 0049                962              MOVE.B  #'I',(A1)+
0000185A  12FC 0056                963              MOVE.B  #'V',(A1)+
0000185E  12FC 0055                964              MOVE.B  #'U',(A1)+
00001862                           965m             INSERT_PERIOD
00001866  12FC 0057                966              MOVE.B  #'W',(A1)+  * always size word
0000186A                           967m             INSERT_SPACE
0000186E                           968  
0000186E  11FC 0001 119D           969              MOVE.B  #1, opSize
00001874                           970              
00001874                           971              * set the valid bits (since there's only one adressing mode)
00001874  11FC 00BF 119E           972              MOVE.B  #%10111111, valid
0000187A                           973              
0000187A  4EF9 00001ACE            974              JMP     EA_TO_D
00001880                           975  
00001880                           976  *-----------------------------------------------------------
00001880                           977  
00001880                           978  
00001880                           979  
00001880                           980  *-----------------------OPC_0101----------------------------
00001880                           981  * First four bits = 0101
00001880                           982  * (ADDQ, SUBQ)
00001880                           983  *-----------------------------------------------------------
00001880                           984  OPC_0101:
00001880                           985m             GET_BITS  #8, #8
00001890                           986m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001896                           987m             * GET HIGH BIT OFFSET
0000189C                           988m             * SHIFT OUT HIGH BITS
000018A2                           989m             *GET LOW BIT OFFSET
000018A2                           990m             *16 - NUMBER OF BITS WE WANT
000018A8                           991m             * SHIFT OUT LOW BITS
000018AA                           992              
000018AA                           993              * is the opcode ADDQ?
000018AA  B83C 0000                994              CMP.B     #%0000, D4
000018AE  6700 000E                995              BEQ       OPC_ADDQ
000018B2                           996  
000018B2                           997              * is the opcode SUBI?
000018B2  B83C 0001                998              CMP.B     #%0001, D4
000018B6  6700 001E                999              BEQ       OPC_SUBQ
000018BA                          1000  
000018BA  4EF8 1522               1001              JMP       BAD_OPCODE
000018BE                          1002  
000018BE                          1003  *------------------------OPC_ADDQ---------------------------
000018BE                          1004  OPC_ADDQ:
000018BE  12FC 0041               1005              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000018C2  12FC 0044               1006              MOVE.B  #'D',(A1)+
000018C6  12FC 0044               1007              MOVE.B  #'D',(A1)+
000018CA  12FC 0051               1008              MOVE.B  #'Q',(A1)+
000018CE                          1009m             INSERT_PERIOD
000018D2                          1010  
000018D2  6100 001A               1011              BSR     DECODE_QUICK
000018D6                          1012  
000018D6                          1013  *------------------------OPC_SUBI---------------------------
000018D6                          1014  OPC_SUBQ:            
000018D6  12FC 0053               1015              MOVE.B  #'S',(A1)+          * Put ADD into Buff
000018DA  12FC 0055               1016              MOVE.B  #'U',(A1)+
000018DE  12FC 0042               1017              MOVE.B  #'B',(A1)+
000018E2  12FC 0051               1018              MOVE.B  #'Q',(A1)+
000018E6                          1019m             INSERT_PERIOD
000018EA                          1020  
000018EA  6100 0002               1021              BSR     DECODE_QUICK
000018EE                          1022  
000018EE                          1023  *------------------Subroutines for OPC_0101-----------------
000018EE                          1024  DECODE_QUICK:            
000018EE                          1025              * Get size of operation and push to buffer
000018EE  4284                    1026              CLR.L           D4
000018F0                          1027m             GET_BITS        #7, #6
00001900                          1028m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001906                          1029m             * GET HIGH BIT OFFSET
0000190C                          1030m             * SHIFT OUT HIGH BITS
00001912                          1031m             *GET LOW BIT OFFSET
00001912                          1032m             *16 - NUMBER OF BITS WE WANT
00001918                          1033m             * SHIFT OUT LOW BITS
0000191A  11C4 119D               1034              MOVE.B          D4, opSize
0000191E                          1035m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001926                          1036  
00001926                          1037              * push value of #<data> to buffer
00001926  4284                    1038              CLR.L            D4
00001928                          1039m             GET_BITS         #11, #9
00001938                          1040m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001942                          1041m             * GET HIGH BIT OFFSET
0000194A                          1042m             * SHIFT OUT HIGH BITS
00001950                          1043m             *GET LOW BIT OFFSET
00001950                          1044m             *16 - NUMBER OF BITS WE WANT
00001956                          1045m             * SHIFT OUT LOW BITS
00001958                          1046m             INSERT_POUND
0000195C                          1047m             VALUE_TO_BUFFER  D4
00001964                          1048  
00001964                          1049m             INSERT_COMMA
00001968                          1050m             INSERT_SPACE
0000196C                          1051  
0000196C                          1052              * push <ea> to buffer
0000196C                          1053m             DECODE_EA       #5, #0
0000198A  6000 FAE4               1054              BRA             IDENTIFY_OPCODE
0000198E                          1055  *-----------------------------------------------------------
0000198E                          1056  
0000198E                          1057  
0000198E                          1058  
0000198E                          1059  *-----------------------OPC_1001----------------------------
0000198E                          1060  * First four bits = 1001
0000198E                          1061  * (SUB)
0000198E                          1062  *-----------------------------------------------------------
0000198E                          1063  OPC_1001:
0000198E                          1064              * fill in A1 register
0000198E  12FC 0053               1065              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001992  12FC 0055               1066              MOVE.B  #'U',(A1)+
00001996  12FC 0042               1067              MOVE.B  #'B',(A1)+
0000199A                          1068m             INSERT_PERIOD
0000199E  6000 008E               1069              BRA     PROCESS_ROEA
000019A2                          1070  *-----------------------------------------------------------
000019A2                          1071  
000019A2                          1072  
000019A2                          1073  
000019A2                          1074  *-----------------------OPC_1100----------------------------
000019A2                          1075  * First four bits = 1100
000019A2                          1076  * (AND, MULS)
000019A2                          1077  *-----------------------------------------------------------
000019A2                          1078  OPC_1100:   
000019A2                          1079              ; check to see if bits 8-6 are 111
000019A2                          1080              ; if they are, then branch to PARSE_MULS
000019A2                          1081              ; else, keep going to parse AND
000019A2                          1082  
000019A2                          1083m             GET_BITS #8, #6
000019B2                          1084m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019B8                          1085m             * GET HIGH BIT OFFSET
000019BE                          1086m             * SHIFT OUT HIGH BITS
000019C4                          1087m             *GET LOW BIT OFFSET
000019C4                          1088m             *16 - NUMBER OF BITS WE WANT
000019CA                          1089m             * SHIFT OUT LOW BITS
000019CC  B83C 0007               1090              CMP.B    #%00000111, D4
000019D0  6700 001A               1091              BEQ      OPC_MULS
000019D4  6600 0002               1092              BNE      OPC_AND
000019D8                          1093  
000019D8                          1094  *---------------------------OPC_AND------------------------
000019D8                          1095  OPC_AND:    ; AND opcode subroutine
000019D8                          1096  
000019D8                          1097              ;-----------------------------
000019D8                          1098              ; fill A1 with the opcode name
000019D8  12FC 0041               1099              MOVE.B  #'A',(A1)+
000019DC  12FC 004E               1100              MOVE.B  #'N',(A1)+
000019E0  12FC 0044               1101              MOVE.B  #'D',(A1)+
000019E4                          1102m             INSERT_PERIOD
000019E8  6000 0044               1103              BRA     PROCESS_ROEA
000019EC                          1104  
000019EC                          1105  *---------------------------OPC_MULS------------------------
000019EC                          1106  OPC_MULS:  * MULS opcode subroutine
000019EC                          1107  
000019EC                          1108              * load the command name into the output
000019EC  12FC 004D               1109              MOVE.B  #'M',(A1)+
000019F0  12FC 0055               1110              MOVE.B  #'U',(A1)+
000019F4  12FC 004C               1111              MOVE.B  #'L',(A1)+
000019F8  12FC 0053               1112              MOVE.B  #'S',(A1)+
000019FC                          1113m             INSERT_PERIOD
00001A00  12FC 0057               1114              MOVE.B  #'W',(A1)+ * always size word
00001A04                          1115m             INSERT_SPACE
00001A08                          1116  
00001A08  11FC 0001 119D          1117              MOVE.B   #1, opSize
00001A0E                          1118              
00001A0E  11FC 00BF 119E          1119              MOVE.B  #%10111111, valid   * set the valid mode bits (to be used later)
00001A14                          1120              
00001A14  4EF9 00001ACE           1121              JMP     EA_TO_D
00001A1A                          1122  *-----------------------------------------------------------
00001A1A                          1123  
00001A1A                          1124  
00001A1A                          1125  *---------------------------opc_1101------------------------
00001A1A                          1126  * First four bits = 1101
00001A1A                          1127  * (ADD)
00001A1A                          1128  *-----------------------------------------------------------
00001A1A                          1129  OPC_1101:
00001A1A                          1130              * fill in A1 register
00001A1A  12FC 0041               1131              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001A1E  12FC 0044               1132              MOVE.B  #'D',(A1)+
00001A22  12FC 0044               1133              MOVE.B  #'D',(A1)+
00001A26                          1134m             INSERT_PERIOD
00001A2A  6000 0002               1135              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
00001A2E                          1136  
00001A2E                          1137  *-----------------------------------------------------------
00001A2E                          1138  
00001A2E                          1139  
00001A2E                          1140  
00001A2E                          1141  
00001A2E                          1142  
00001A2E                          1143  
00001A2E                          1144  
00001A2E                          1145  
00001A2E                          1146  
00001A2E                          1147  
00001A2E                          1148  
00001A2E                          1149  *--------------Process Register->Opmode->EA-----------------
00001A2E                          1150  * Description:
00001A2E                          1151  * Parses bits for opcodes that share bit placements:
00001A2E                          1152  * ROEA stands for Register, Opmode, and Effective Address,
00001A2E                          1153  * because the opcodes below share this bit order.
00001A2E                          1154  *
00001A2E                          1155  * Used by: (ADD, SUB, MULS)
00001A2E                          1156  *
00001A2E                          1157  *-----------------------------------------------------------
00001A2E                          1158  PROCESS_ROEA:
00001A2E                          1159m             GET_BITS        #7, #6              * retrieve size
00001A3E                          1160m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001A44                          1161m             * GET HIGH BIT OFFSET
00001A4A                          1162m             * SHIFT OUT HIGH BITS
00001A50                          1163m             *GET LOW BIT OFFSET
00001A50                          1164m             *16 - NUMBER OF BITS WE WANT
00001A56                          1165m             * SHIFT OUT LOW BITS
00001A58  11C4 119D               1166              MOVE.B          D4, opSize
00001A5C                          1167m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001A64                          1168  
00001A64                          1169m             GET_BITS        #8, #8              * retrieve type  
00001A74                          1170m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001A7A                          1171m             * GET HIGH BIT OFFSET
00001A80                          1172m             * SHIFT OUT HIGH BITS
00001A86                          1173m             *GET LOW BIT OFFSET
00001A86                          1174m             *16 - NUMBER OF BITS WE WANT
00001A8C                          1175m             * SHIFT OUT LOW BITS
00001A8E  B83C 0001               1176              CMP.B           #1, D4              * is this Dn + <ea> -> <ea>?
00001A92  6700 000A               1177              BEQ             D_TO_EA
00001A96  B83C 0000               1178              CMP.B           #0, D4              * is this <ea> + Dn -> <ea>?
00001A9A  6700 0032               1179              BEQ             EA_TO_D
00001A9E                          1180  
00001A9E                          1181  D_TO_EA:
00001A9E  4EB9 00001B06           1182              JSR             GET_DATA_REG_NUM
00001AA4                          1183m             INSERT_COMMA
00001AA8                          1184m             INSERT_SPACE
00001AAC                          1185m             DECODE_EA       #5, #0
00001ACA  6000 0032               1186              BRA             ROEA_DONE
00001ACE                          1187  
00001ACE                          1188  EA_TO_D:
00001ACE                          1189m             DECODE_EA       #5, #0
00001AEC                          1190m             INSERT_COMMA
00001AF0                          1191m             INSERT_SPACE
00001AF4  4EB9 00001B06           1192              JSR             GET_DATA_REG_NUM
00001AFA  6000 0002               1193              BRA             ROEA_DONE
00001AFE                          1194  
00001AFE                          1195  ROEA_DONE:
00001AFE                          1196m             INSERT_SPACE
00001B02  6000 F96C               1197              BRA     IDENTIFY_OPCODE
00001B06                          1198  
00001B06                          1199  GET_DATA_REG_NUM:
00001B06  4284                    1200              CLR.L    D4
00001B08                          1201m             GET_BITS #11, #9                     * retrieve high data register number
00001B18                          1202m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B22                          1203m             * GET HIGH BIT OFFSET
00001B2A                          1204m             * SHIFT OUT HIGH BITS
00001B30                          1205m             *GET LOW BIT OFFSET
00001B30                          1206m             *16 - NUMBER OF BITS WE WANT
00001B36                          1207m             * SHIFT OUT LOW BITS
00001B38                          1208  
00001B38                          1209              * store in appropriate register
00001B38  12FC 0044               1210              MOVE.B            #'D',(A1)+                  * add "D" to buffer
00001B3C                          1211m             VALUE_TO_BUFFER   D4          
00001B44  4E75                    1212              RTS
00001B46                          1213  *-----------------------------------------------------------
00001B46                          1214  
00001B46                          1215  
00001B46                          1216  
00001B46                          1217  
00001B46                          1218  
00001B46                          1219  
00001B46                          1220  
00001B46                          1221  
00001B46                          1222  
00001B46                          1223  
00001B46                          1224  
00001B46                          1225  
00001B46                          1226  *----------------------EA_TO_BUFFER------------------
00001B46                          1227  * Description:
00001B46                          1228  * Evaluates the ea mode and register of an opcode 
00001B46                          1229  * (usually last 6 bits of instruction format),
00001B46                          1230  * and adds it to A1 to be printed out
00001B46                          1231  *
00001B46                          1232  * No Parameters
00001B46                          1233  *
00001B46                          1234  * Registers Used:
00001B46                          1235  *   D1 = amount to shift the opcode
00001B46                          1236  *   D2 = destination for shifts
00001B46                          1237  *-----------------------------------------------------------
00001B46                          1238  EA_TO_BUFFER:                            
00001B46  0C38 0000 119F          1239              CMP.B   #%0000, ea_mode        * Direct Data Register
00001B4C  6700 004C               1240              BEQ     EA_000
00001B50                          1241  
00001B50  0C38 0001 119F          1242              CMP.B   #%0001, ea_mode        * Direct Address Register
00001B56  6700 0052               1243              BEQ     EA_001
00001B5A                          1244  
00001B5A  0C38 0002 119F          1245              CMP.B   #%0010, ea_mode        * Indirect Address Register
00001B60  6700 0058               1246              BEQ     EA_010
00001B64                          1247  
00001B64  0C38 0003 119F          1248              CMP.B   #%0011, ea_mode        * Post Increment
00001B6A  6700 0066               1249              BEQ     EA_011
00001B6E                          1250  
00001B6E  0C38 0004 119F          1251              CMP.B   #%0100, ea_mode        * Pre Decrement
00001B74  6700 0078               1252              BEQ     EA_100
00001B78                          1253  
00001B78  0C38 0005 119F          1254              CMP.B   #%0101, ea_mode        * Not necessary, go to bad EA
00001B7E  6700 008A               1255              BEQ     EA_101
00001B82                          1256  
00001B82  0C38 0006 119F          1257              CMP.B   #%0110, ea_mode        * Not necessary, go to bad EA
00001B88  6700 0084               1258              BEQ     EA_110
00001B8C                          1259  
00001B8C  0C38 0007 119F          1260              CMP.B   #%0111, ea_mode        * Absolute or immediate address
00001B92  6700 007E               1261              BEQ     EA_111
00001B96                          1262  
00001B96  6000 00E2               1263              BRA    INVALID_EA
00001B9A                          1264  
00001B9A                          1265  *----------------------------Direct Data Register------------------------
00001B9A                          1266  EA_000:
00001B9A  12FC 0044               1267              MOVE.B      #'D',(A1)+              * add "D" to buffer
00001B9E  0638 0030 11A0          1268              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001BA4  12F8 11A0               1269              MOVE.B      ea_register, (A1)+      * register # to buffer                  
00001BA8  4E75                    1270              RTS                                
00001BAA                          1271  
00001BAA                          1272  *----------------------------Direct Address Register------------------------
00001BAA                          1273  EA_001:
00001BAA  12FC 0041               1274              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001BAE  0638 0030 11A0          1275              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001BB4  12F8 11A0               1276              MOVE.B      ea_register, (A1)+      * register # to buffer               
00001BB8  4E75                    1277              RTS                            
00001BBA                          1278  
00001BBA                          1279  *----------------------------Indirect Address Register------------------------
00001BBA                          1280  EA_010:
00001BBA  12FC 0028               1281              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001BBE  12FC 0041               1282              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001BC2  0638 0030 11A0          1283              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001BC8  12F8 11A0               1284              MOVE.B      ea_register, (A1)+      * register # to buffer     
00001BCC  12FC 0029               1285              MOVE.B      #')',(A1)+              * add ")" to buffer
00001BD0  4E75                    1286              RTS                            
00001BD2                          1287  
00001BD2                          1288  *----------------------------Post Increment------------------------
00001BD2                          1289  EA_011:
00001BD2  12FC 0028               1290              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001BD6  12FC 0041               1291              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001BDA  0638 0030 11A0          1292              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001BE0  12F8 11A0               1293              MOVE.B      ea_register, (A1)+      * register # to buffer 
00001BE4  12FC 0029               1294              MOVE.B      #')',(A1)+              * add ")" to buffer
00001BE8  12FC 002B               1295              MOVE.B      #'+',(A1)+              * add "+" to buffer 
00001BEC  4E75                    1296              RTS                              
00001BEE                          1297  
00001BEE                          1298  *----------------------------Pre Decrement------------------------
00001BEE                          1299  EA_100:
00001BEE  12FC 002D               1300              MOVE.B      #'-',(A1)+              * add "-" to buffer
00001BF2  12FC 0028               1301              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001BF6  12FC 0041               1302              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001BFA  0638 0030 11A0          1303              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001C00  12F8 11A0               1304              MOVE.B      ea_register, (A1)+      * register # to buffer 
00001C04  12FC 0029               1305              MOVE.B      #')',(A1)+              * add ")" to buffer
00001C08  4E75                    1306              RTS
00001C0A                          1307  
00001C0A                          1308  *----------------------------Not necessary, go to bad EA------------------------
00001C0A                          1309  EA_101:
00001C0A  6000 006E               1310              BRA         INVALID_EA        
00001C0E                          1311  
00001C0E                          1312  *----------------------------Not necessary, go to bad EA------------------------
00001C0E                          1313  EA_110:
00001C0E  6000 006A               1314              BRA         INVALID_EA        
00001C12                          1315  
00001C12                          1316  *----------------------------Absolute or immediate address------------------------
00001C12                          1317  EA_111:
00001C12                          1318              * D405      0 0003456  23345245
00001C12                          1319              * ADD.L     $1234, D0
00001C12                          1320  
00001C12                          1321              * 8 bit value
00001C12                          1322              * 11111111
00001C12                          1323  
00001C12                          1324              * 11111011 - Direct data register would be Invalid
00001C12                          1325              * 00000100
00001C12                          1326              * 00000000 -> invalid code
00001C12                          1327  
00001C12                          1328              * and.b     #$F, Dn        ---->  10000000
00001C12                          1329              * cmp.b     #%10000000, Dn  
00001C12                          1330  
00001C12                          1331              * check against valid bits
00001C12                          1332                  * if invalid, branch to invalid opcode subroutine
00001C12                          1333                      * if the mode is 111, then go back and print out addresses
00001C12                          1334  
00001C12  0C38 0000 11A0          1335              CMP.B       #%000, ea_register                * compare to determine if it's a word
00001C18  6700 001A               1336              BEQ         EA_WORD                  * put word address in buffer
00001C1C                          1337  
00001C1C  0C38 0001 11A0          1338              CMP.B       #%001, ea_register                * compare to determine if it's a long
00001C22  6700 0024               1339              BEQ         EA_LONG                  * put long address in buffer
00001C26                          1340              
00001C26  0C38 0004 11A0          1341              CMP.B       #%100, ea_register
00001C2C  6700 002E               1342              BEQ         EA_IMMEDIATE             * always print a long if it's immediate data
00001C30                          1343  
00001C30                          1344              * Invalid EA mode/register
00001C30  6000 0048               1345              BRA         INVALID_EA
00001C34                          1346  
00001C34                          1347  EA_WORD:
00001C34  12FC 0024               1348              MOVE.B      #'$', (A1)+
00001C38  4281                    1349              CLR.L       D1
00001C3A  123C 0001               1350              MOVE.B      #1, D1
00001C3E  3E1A                    1351              MOVE.W      (A2)+, D7
00001C40  6100 003E               1352              BSR         HEX_TO_ASCII
00001C44  6000 0032               1353              BRA         GET_EA_DONE
00001C48                          1354  
00001C48                          1355  EA_LONG:
00001C48  12FC 0024               1356              MOVE.B      #'$', (A1)+
00001C4C  4281                    1357              CLR.L       D1
00001C4E  123C 0003               1358              MOVE.B      #3, D1
00001C52  2E1A                    1359              MOVE.L      (A2)+, D7   
00001C54  6100 002A               1360              BSR         HEX_TO_ASCII
00001C58  6000 001E               1361              BRA         GET_EA_DONE
00001C5C                          1362  
00001C5C                          1363  EA_IMMEDIATE:
00001C5C  12FC 0023               1364              MOVE.B      #'#', (A1)+
00001C60                          1365  
00001C60  0C38 0000 119D          1366              CMP.B       #0, opSize          
00001C66  67CC                    1367              BEQ         EA_WORD
00001C68                          1368  
00001C68  0C38 0001 119D          1369              CMP.B       #1, opSize          
00001C6E  67C4                    1370              BEQ         EA_WORD          
00001C70                          1371              
00001C70  0C38 0002 119D          1372              CMP.B       #2, opSize
00001C76  60D0                    1373              BRA         EA_LONG             
00001C78                          1374  
00001C78                          1375  GET_EA_DONE:
00001C78  4E75                    1376              RTS
00001C7A                          1377  
00001C7A                          1378  *------------------Invalid Effective Address----------------
00001C7A                          1379  INVALID_EA:
00001C7A  4EF9 00001D26           1380              JMP      DONE
00001C80                          1381  *-----------------------------------------------------------
00001C80                          1382  
00001C80                          1383  
00001C80                          1384  
00001C80                          1385  
00001C80                          1386  
00001C80                          1387  
00001C80                          1388  
00001C80                          1389  
00001C80                          1390  
00001C80                          1391  *----------------------HEX TO ASCII-------------------------
00001C80                          1392  * Description:
00001C80                          1393  * Converts a Hex numbered address (1-9 or A-F) back to an
00001C80                          1394  * ASCII value for printing
00001C80                          1395  *
00001C80                          1396  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
00001C80                          1397  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
00001C80                          1398  *   D7 = holds the original address to parse (either word or long, for example: $7000)
00001C80                          1399  *
00001C80                          1400  *
00001C80                          1401  * Registers Used:
00001C80                          1402  *   D0 = number of bits to remove
00001C80                          1403  *   D2 = holds either top four bits or bottom four bits of each byte in D6
00001C80                          1404  *   D3 = holds temp data
00001C80                          1405  *   D6 = holds part of address (used as temp variable)
00001C80                          1406  *   A1 = used for buffer
00001C80                          1407  *-----------------------------------------------------------
00001C80                          1408  HEX_TO_ASCII:
00001C80  1001                    1409              MOVE.B   D1, D0             * current number of bytes to remove
00001C82  C1FC 0008               1410              MULS.W   #8, D0             * number of bits to remove
00001C86                          1411  
00001C86  2C07                    1412              MOVE.L   D7, D6             * load original address to parse
00001C88  E0AE                    1413              LSR.L    D0, D6             * remove lowest byte(s)
00001C8A                          1414  
00001C8A                          1415              * isolate first four bits
00001C8A  1406                    1416              MOVE.B   D6, D2
00001C8C  E80A                    1417              LSR.B    #4, D2 
00001C8E  6100 0018               1418              BSR      NUMBER_OR_LETTER
00001C92                          1419  
00001C92                          1420              * isolate second set of four bits
00001C92  1406                    1421              MOVE.B   D6, D2
00001C94  E90A                    1422              LSL.B    #4, D2 
00001C96  E80A                    1423              LSR.B    #4, D2 
00001C98  6100 000E               1424              BSR      NUMBER_OR_LETTER
00001C9C                          1425  
00001C9C  5301                    1426              SUB.B    #1, D1             * iterate
00001C9E  B23C 0000               1427              CMP.B    #0, D1             * done if equal
00001CA2  6D00 0036               1428              BLT      ATH_DONE
00001CA6                          1429  
00001CA6  60D8                    1430              BRA      HEX_TO_ASCII
00001CA8                          1431  
00001CA8                          1432  NUMBER_OR_LETTER:
00001CA8  1602                    1433              MOVE.B   D2, D3
00001CAA  0603 0030               1434              ADD.B    #$30, D3           
00001CAE  B63C 0039               1435              CMP.B    #$39, D3           * is byte in D2 a number?
00001CB2  6F00 0012               1436              BLE      NUMBER_TO_ASCII
00001CB6                          1437              
00001CB6  1602                    1438              MOVE.B   D2, D3
00001CB8  0603 0037               1439              ADD.B    #$37, D3           
00001CBC  B63C 0039               1440              CMP.B    #$39, D3           * is byte in D2 a letter?
00001CC0  6C00 000C               1441              BGE      LETTER_TO_ASCII
00001CC4                          1442  
00001CC4  60B4                    1443              BRA      INVALID_EA
00001CC6                          1444  
00001CC6                          1445  NUMBER_TO_ASCII:
00001CC6  0602 0030               1446              ADD.B    #$30, D2           * Get the hex range from '0-9'
00001CCA  6000 000A               1447              BRA      ADD_TO_BUFFER
00001CCE                          1448  
00001CCE                          1449  LETTER_TO_ASCII:
00001CCE  0602 0037               1450              ADD.B    #$37, D2           * Get the hex range from 'A-F'
00001CD2  6000 0002               1451              BRA      ADD_TO_BUFFER
00001CD6                          1452  
00001CD6                          1453  ADD_TO_BUFFER:
00001CD6  12C3                    1454              MOVE.B   D3, (A1)+          * add part of address to buffer    
00001CD8  4E75                    1455              RTS
00001CDA                          1456  
00001CDA                          1457  ATH_DONE:
00001CDA                          1458m             CLR_D_REGS
00001CEA  4E75                    1459              RTS
00001CEC                          1460  *-----------------------------------------------------------
00001CEC                          1461  
00001CEC                          1462  
00001CEC                          1463  
00001CEC                          1464  
00001CEC                          1465  
00001CEC                          1466  
00001CEC                          1467  
00001CEC                          1468  
00001CEC                          1469  
00001CEC                          1470  *---------------------SIZE TO BUFFER------------------------
00001CEC                          1471  * Description:
00001CEC                          1472  * Evaluates the size of an opcode and adds it to A1 to be printed out
00001CEC                          1473  *
00001CEC                          1474  * Parameters:
00001CEC                          1475  *   D3 = size of opcode
00001CEC                          1476  *
00001CEC                          1477  * Registers Used:
00001CEC                          1478  *   A1: adding words/numbers to buffer
00001CEC                          1479  *-----------------------------------------------------------
00001CEC                          1480  FIND_SIZE: 
00001CEC  B63C 0000               1481              CMP.B   #%0000,D3            
00001CF0  6700 0016               1482              BEQ     BYTE_TO_BUFFER              
00001CF4                          1483  
00001CF4  B63C 0001               1484              CMP.B   #%0001,D3             * is this a word?
00001CF8  6700 0016               1485              BEQ     WORD_TO_BUFFER
00001CFC                          1486  
00001CFC  B63C 0002               1487              CMP.B   #%0010,D3             * is this a long?
00001D00  6700 0016               1488              BEQ     LONG_TO_BUFFER             
00001D04                          1489        
00001D04  4EF8 1522               1490              JMP     BAD_OPCODE  
00001D08                          1491              
00001D08                          1492  BYTE_TO_BUFFER:
00001D08  12FC 0042               1493              MOVE.B  #'B', (A1)+           * add B to buffer
00001D0C  6000 0012               1494              BRA     STB_END             
00001D10                          1495              
00001D10                          1496  WORD_TO_BUFFER:
00001D10  12FC 0057               1497              MOVE.B  #'W', (A1)+          * add W to buffer
00001D14  6000 000A               1498              BRA     STB_END             
00001D18                          1499  
00001D18                          1500  LONG_TO_BUFFER:
00001D18  12FC 004C               1501              MOVE.B  #'L',(A1)+          * add L to buffer
00001D1C  6000 0002               1502              BRA     STB_END             
00001D20                          1503  
00001D20                          1504  STB_END:
00001D20  12FC 0020               1505              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001D24  4E75                    1506              RTS                         
00001D26                          1507  *-----------------------------------------------------------
00001D26                          1508  
00001D26                          1509  
00001D26                          1510  
00001D26                          1511  
00001D26                          1512  
00001D26                          1513  
00001D26                          1514  *-------------------------DONE-------------------------------
00001D26                          1515  DONE:
00001D26                          1516m             CLR_A_REG D0, A1
00001D2A                          1517  
00001D2A                          1518              * add 'SIMHAULT' to buffer
00001D2A  12FC 0053               1519              MOVE.B  #'S',(A1)+      
00001D2E  12FC 0049               1520              MOVE.B  #'I',(A1)+         
00001D32  12FC 004D               1521              MOVE.B  #'M',(A1)+         
00001D36  12FC 0048               1522              MOVE.B  #'H',(A1)+        
00001D3A  12FC 0041               1523              MOVE.B  #'A',(A1)+         
00001D3E  12FC 0055               1524              MOVE.B  #'U',(A1)+         
00001D42  12FC 004C               1525              MOVE.B  #'L',(A1)+          
00001D46  12FC 0054               1526              MOVE.B  #'T',(A1)+         
00001D4A  12FC 0000               1527              MOVE.B  #00,(A1)+         
00001D4E                          1528  
00001D4E                          1529m             CLR_A_REG D0, A1
00001D52                          1530              
00001D52                          1531              * print out string
00001D52  103C 000E               1532              MOVE.B    #14, D0
00001D56  4E4F                    1533              TRAP      #15
00001D58                          1534              
00001D58                          1535m             CLR_A_REG D0, A1
00001D5C                          1536  
00001D5C                          1537  
00001D5C                          1538              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       1CD6
ATH_DONE            1CDA
BADINPUT            117A
BAD_OPCODE          1522
BYTE_TO_BUFFER      1D08
CHECK_ADDRESS       132E
CHECK_IMMEDIATE     1600
CHECK_LENGTH        130E
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      135E
CR                  D
DECODE_11_TO_6      1214
DECODE_6_TO_0       11B2
DECODE_EA           57B
DECODE_EA_HELP      11A2
DECODE_IMMEDIATE    159A
DECODE_MOVE         16A2
DECODE_QUICK        18EE
DONE                1D26
DONEMSG             116D
D_TO_EA             1A9E
EA_000              1B9A
EA_001              1BAA
EA_010              1BBA
EA_011              1BD2
EA_100              1BEE
EA_101              1C0A
EA_110              1C0E
EA_111              1C12
EA_END              1276
EA_IMMEDIATE        1C5C
EA_LONG             1C48
EA_MODE             119F
EA_REGISTER         11A0
EA_TO_BUFFER        1B46
EA_TO_D             1ACE
EA_VALID            11A1
EA_WORD             1C34
ENDADDR             1196
ENDMSG              114A
FIND_OPCODE         14BA
FIND_SIZE           1CEC
FINISH_PRINT        1406
GET_ADDRESS         12FA
GET_BITS            1C5
GET_DATA_REG_NUM    1B06
GET_EA_DONE         1C78
GET_EA_MODE         613
GET_EA_REG          675
GET_INPUT           12C0
GRAB_FIRST_FOUR_BITS  14A8
GRAB_NEXT_WORD      14A2
HEX_TO_ASCII        1C80
IDENTIFY_OPCODE     1470
IMMEDIATE_LONG      161C
IMMEDIATE_WORD      1614
INSERT_COMMA        73A
INSERT_DOLLAR       857
INSERT_PERIOD       799
INSERT_POUND        7F8
INSERT_SPACE        6DB
INVALID_ADDRESS     134E
INVALID_EA          1C7A
INVALID_INPUT       1320
ITERATE             1392
LETTER_TO_ASCII     1CCE
LETTER_TO_HEX       1384
LF                  A
LOAD_ADDRESSES      144A
LONG_TO_BUFFER      1D18
MAIN                1278
NEWLINE             118A
NUMBER_OR_LETTER    1CA8
NUMBER_TO_ASCII     1CC6
NUM_TO_HEX          137C
OPCODE              119A
OPC_0000            1528
OPC_0001            1624
OPC_0010            164E
OPC_0011            1678
OPC_0100            16E8
OPC_0101            1880
OPC_1000            184E
OPC_1001            198E
OPC_1100            19A2
OPC_1101            1A1A
OPC_ADDI            156A
OPC_ADDQ            18BE
OPC_AND             19D8
OPC_DIVU            1852
OPC_JSR             180C
OPC_LEA             17BE
OPC_MULS            19EC
OPC_NOP             1746
OPC_NOT             1756
OPC_RTS             183E
OPC_SUBI            1582
OPC_SUBQ            18D6
OPSIZE              119D
OPTAG               119C
PRINT_ADDRESS       13A4
PRINT_INSTRUCTION   142C
PRINT_LONG          13EC
PRINT_MSG           0
PRINT_WORD          13D2
PROCESS_ROEA        1A2E
RESTORE_REGS        149C
ROEA_DONE           1AFE
RULE1               1000
RULE1C              1038
RULE2               1059
RULE3               109B
RULE3C              10DD
SIZE_TO_BUFFER      51C
STARTADDR           1192
STARTMSG            1125
STB_END             1D20
STORE_CHAR          138C
STORE_INPUT         13A0
USERADDR            118E
VALID               119E
VALUE_TO_BUFFER     4B4
WORD_TO_BUFFER      1D10
