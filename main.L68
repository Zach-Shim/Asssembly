0000107E Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/5/2021 4:55:46 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00000000                            11              
00001000                            12              ORG     $1000
00001000                            13  
00001000  =0000000D                 14  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 15  LF          EQU     $0A 
00001000                            16  
00001000= 50 6C 65 61 73 65 ...     17  startMsg:   DC.B    'Please enter a starting address ', CR, LF, 0
00001023= 50 6C 65 61 73 65 ...     18  endMsg:     DC.B    'Please enter an ending address ', CR, LF, 0
00001045= 65 78 69 74 69 6E ...     19  doneMsg:    DC.B    'exiting...', CR, LF, 0
00001052= 49 6E 76 61 6C 69 ...     20  badInput:   DC.B    'Invalid Input', CR, LF, 0
00001062= 0D 0A 00                  21  newline:    DC.B    '', CR, LF, 0
00001065                            22  
00001066                            23  userAddr:   DS.L    1
0000106A                            24  startAddr:  DS.L    1
0000106E                            25  endAddr:    DS.L    1
00001072                            26  
00001072                            27  opOutput:   DS.L    2
0000107A                            28  
0000107A                            29  opcode:     DS.W    1   
0000107C                            30  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
0000107D                            31  valid:      DS.B    1
0000107E                            32  
0000107E                            33  
0000107E                            34  
0000107E                            35  
0000107E                            36  
0000107E                            37  
0000107E                            38  *-----------------------------------------------------------
0000107E                            39  * Macros:
0000107E                            40  *-----------------------------------------------------------
0000107E                            41  
0000107E                            42  PRINT_MSG:  MACRO 
0000107E                            43              CLR.L   D0
0000107E                            44              LEA     \1, A1      ; \1 acts as a parameter
0000107E                            45              MOVE.B  #14, D0     
0000107E                            46              TRAP    #15
0000107E                            47              ENDM
0000107E                            48  
0000107E                            49  CLR_D_REGS: MACRO
0000107E                            50              CLR.L   D0
0000107E                            51              CLR.L   D1
0000107E                            52              CLR.L   D2
0000107E                            53              CLR.L   D3
0000107E                            54              CLR.L   D4
0000107E                            55              CLR.L   D5
0000107E                            56              CLR.L   D6
0000107E                            57              CLR.L   D7
0000107E                            58              ENDM
0000107E                            59  
0000107E                            60  CLR_A_REG:  MACRO
0000107E                            61              CLR.L   \1
0000107E                            62              MOVE.L  \1, \2
0000107E                            63              ENDM              
0000107E                            64  
0000107E                            65  *-----------------------------------------------------------
0000107E                            66  * \1 should be highest bit in range
0000107E                            67  * \2 should be lowest bit in range
0000107E                            68  * Result will be returned in D4
0000107E                            69  * Example: #11, #9
0000107E                            70  *
0000107E                            71  * Return Value:
0000107E                            72  *   D4 = value held within bits \1 and \2
0000107E                            73  *
0000107E                            74  * Registers:
0000107E                            75  *   D4 = holds opcode
0000107E                            76  *   D5 = highest bit in range 
0000107E                            77  *   D6 = lowest bit in range 
0000107E                            78  *   D7 = number of bits we want
0000107E                            79  *-----------------------------------------------------------
0000107E                            80  GET_BITS:   MACRO
0000107E                            81              * Subtract value to find amount to shift by 
0000107E                            82              ADD.B   \1, D7          
0000107E                            83              SUB.B   \2, D7 
0000107E                            84              ADD.B   #1, D7  * add 1 because we start our count from 0
0000107E                            85  
0000107E                            86              * Get high bit offset
0000107E                            87              ADD.B   #15, D5
0000107E                            88              SUB.B   \1, D5
0000107E                            89              
0000107E                            90              * shift out high bits
0000107E                            91              MOVE.W  opcode, D4
0000107E                            92              LSL.W   D5, D4
0000107E                            93              
0000107E                            94              *get low bit offset
0000107E                            95              *16 - NUMBER OF BITS WE WANT
0000107E                            96              ADD.B   #16, D6         * 16 total bits
0000107E                            97              SUB.L   D7, D6          * subtract numBits from 16
0000107E                            98              
0000107E                            99              * shift out low bits
0000107E                           100              LSR.W   D6, D4          * isolate bits
0000107E                           101              ENDM
0000107E                           102  
0000107E                           103  
0000107E                           104  *-----------------------------------------------------------
0000107E                           105  * Description:  
0000107E                           106  * Main routine
0000107E                           107  *-----------------------------------------------------------
0000107E                           108  
0000107E                           109  *-------------------------MAIN------------------------------
0000107E                           110  MAIN:
0000107E  6100 0006                111              BSR     GET_INPUT
00001082  6000 01C8                112              BRA     LOAD_ADDRESSES
00001086                           113  *-----------------------------------------------------------
00001086                           114  
00001086                           115  
00001086                           116  
00001086                           117  
00001086                           118  
00001086                           119  
00001086                           120  
00001086                           121  
00001086                           122  *-----------------------------------------------------------
00001086                           123  * Description:  
00001086                           124  * Get User Input
00001086                           125  *
00001086                           126  * Registers Used:
00001086                           127  *   D0 = task values
00001086                           128  *   D1 = stores of size of ascii string in A1 from user input
00001086                           129  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
00001086                           130  *   A1 = stores an ascii string from user input
00001086                           131  *-----------------------------------------------------------
00001086                           132  *-------------------------Get Input-------------------------
00001086                           133  GET_INPUT:
00001086  B87C 0000                134              CMP      #0, D4
0000108A  6700 000C                135              BEQ      GET_START_ADDRESS
0000108E                           136                 
0000108E  21C6 106A                137              MOVE.L   D6, startAddr
00001092  21C7 106E                138              MOVE.L   D7, endAddr
00001096  4E75                     139              RTS 
00001098                           140  *-----------------------------------------------------------
00001098                           141  
00001098                           142  *----------------------Get Starting Address-----------------
00001098                           143  GET_START_ADDRESS:
00001098  4280                     144              CLR.L   D0
0000109A  43F8 1000                145              LEA.L   startMsg, A1      
0000109E  103C 000E                146              MOVE.B  #14, D0     
000010A2  4E4F                     147              TRAP    #15
000010A4                           148  
000010A4  43F8 1066                149              LEA.L   userAddr, A1
000010A8  103C 0002                150              MOVE.B  #2, D0
000010AC  4E4F                     151              TRAP    #15
000010AE                           152              ;MOVE.B  D1, startSize
000010AE  6000 001C                153              BRA     VALIDATE_INPUT
000010B2                           154  *-----------------------------------------------------------
000010B2                           155  
000010B2                           156  *----------------------Get Ending Address-------------------
000010B2                           157  GET_END_ADDRESS:
000010B2  4280                     158              CLR.L   D0
000010B4  43F8 1023                159              LEA.L   endMsg, A1      
000010B8  103C 000E                160              MOVE.B  #14, D0     
000010BC  4E4F                     161              TRAP    #15
000010BE                           162  
000010BE  43F8 1066                163              LEA.L   userAddr, A1
000010C2  103C 0002                164              MOVE.B  #2, D0
000010C6  4E4F                     165              TRAP    #15
000010C8                           166              ;MOVE.B  D1, endSize
000010C8  6000 0012                167              BRA     CHECK_LENGTH
000010CC                           168  *-----------------------------------------------------------
000010CC                           169  
000010CC                           170  
000010CC                           171  
000010CC                           172  
000010CC                           173  
000010CC                           174  
000010CC                           175  
000010CC                           176  
000010CC                           177  
000010CC                           178  
000010CC                           179  *-----------------------------------------------------------
000010CC                           180  * Description:  Validate User Input
000010CC                           181  * Constraints:  
000010CC                           182  *   User input must be:
000010CC                           183  *   Length 4 or Length 8
000010CC                           184  *   ASCII character 0-9 or A-F
000010CC                           185  *   Starting and ending address with value < $00FFFFFF 
000010CC                           186  *   Starting address is before ending address
000010CC                           187  *
000010CC                           188  * Registers Used:
000010CC                           189  *   D0 = task values
000010CC                           190  *   D1 = stores of size of ascii string in A1 from user input
000010CC                           191  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000010CC                           192  *   A1 = stores an ascii string from user input
000010CC                           193  *-----------------------------------------------------------
000010CC                           194  
000010CC                           195  *----------------------VALIDATE INPUT---------------------------      
000010CC                           196  
000010CC                           197  VALIDATE_INPUT:        
000010CC  B83C 0000                198              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
000010D0  6700 000A                199              BEQ        CHECK_LENGTH         ; if equal, parse START address 
000010D4  B83C 0001                200              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
000010D8  67D8                     201              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
000010DA  60AA                     202              BRA        GET_INPUT            ; done parsing, D4 = 2
000010DC                           203  
000010DC                           204  CHECK_LENGTH:
000010DC  B23C 0004                205              CMP.B      #4, D1               ; for task 2, length of string is in D1                
000010E0  6700 002C                206              BEQ        CONVERT_TO_HEX 
000010E4  B23C 0008                207              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
000010E8  6700 0024                208              BEQ        CONVERT_TO_HEX
000010EC  6000 0002                209              BRA        INVALID_INPUT
000010F0                           210  
000010F0                           211  INVALID_INPUT:  
000010F0  4283                     212              CLR.L      D3
000010F2                           213m             PRINT_MSG  badInput
000010FE  B83C 0000                214              CMP.B      #0, D4 
00001102  6794                     215              BEQ        GET_START_ADDRESS  
00001104  B83C 0001                216              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001108  67A8                     217              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
0000110A  6000 FF72                218              BRA        MAIN
0000110E                           219  *-----------------------------------------------------------
0000110E                           220  
0000110E                           221  *----------------CONVERT FROM ASCII TO HEX------------------
0000110E                           222  CONVERT_TO_HEX:
0000110E  0C11 0030                223              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001112  6DDC                     224              BLT        INVALID_INPUT        
00001114                           225  
00001114  0C11 003A                226              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001118  6D00 0012                227              BLT        NUM_TO_HEX      
0000111C                           228  
0000111C  0C11 0041                229              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001120  6DCE                     230              BLT        INVALID_INPUT             
00001122                           231  
00001122  0C11 0047                232              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001126  6D00 000C                233              BLT        LETTER_TO_HEX
0000112A                           234  
0000112A  60C4                     235              BRA        INVALID_INPUT    
0000112C                           236  
0000112C                           237  NUM_TO_HEX:      
0000112C  0411 0030                238              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001130  6000 000A                239              BRA        STORE_CHAR   
00001134                           240  
00001134                           241  LETTER_TO_HEX:     
00001134  0411 0037                242              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001138  6000 0002                243              BRA        STORE_CHAR
0000113C                           244  
0000113C                           245  STORE_CHAR:       
0000113C  D619                     246              ADD.B     (A1)+, D3            ; keep hex stored in D3           
0000113E  6000 0002                247              BRA        ITERATE                 
00001142                           248  
00001142                           249  ITERATE:
00001142  5301                     250              SUB.B      #$1, D1
00001144  B23C 0000                251              CMP.B      #0, D1
00001148  6700 0006                252              BEQ        STORE_INPUT
0000114C                           253  
0000114C  E98B                     254              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000114E  60BE                     255              BRA        CONVERT_TO_HEX
00001150                           256  
00001150                           257  STORE_INPUT:
00001150  B83C 0000                258              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
00001154  6700 000A                259              BEQ        STORE_START          ; if equal, parse START address 
00001158                           260              
00001158  B83C 0001                261              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
0000115C  6700 0022                262              BEQ        STORE_END         
00001160                           263  
00001160                           264  STORE_START:
00001160  2C03                     265              MOVE.L     D3, D6
00001162  5204                     266              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001164                           267              ;CLR        D3
00001164                           268              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001164                           269  
00001164                           270              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001164  4281                     271              CLR.L       D1
00001166  2203                     272              MOVE.L      D3, D1   
00001168  103C 0003                273              MOVE.B      #3, D0     
0000116C  4E4F                     274              TRAP        #15
0000116E                           275m             PRINT_MSG   newline
0000117A                           276              
0000117A  4243                     277              CLR         D3
0000117C  6000 FF4E                278              BRA         VALIDATE_INPUT
00001180                           279  
00001180                           280  STORE_END:
00001180  2E03                     281              MOVE.L     D3, D7
00001182  5204                     282              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001184                           283              ;CLR        D3
00001184                           284              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001184                           285  
00001184                           286              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001184  4281                     287              CLR.L       D1
00001186  2203                     288              MOVE.L      D3, D1   
00001188  103C 0003                289              MOVE.B      #3, D0     
0000118C  4E4F                     290              TRAP        #15
0000118E                           291m             PRINT_MSG   newline
0000119A                           292  
0000119A  4243                     293              CLR         D3
0000119C  6000 FF2E                294              BRA         VALIDATE_INPUT
000011A0                           295  *-----------------------------------------------------------
000011A0                           296  
000011A0                           297  
000011A0                           298  
000011A0                           299  
000011A0                           300  
000011A0                           301  
000011A0                           302  
000011A0                           303  
000011A0                           304  
000011A0                           305  
000011A0                           306  
000011A0                           307  *--------------------------PRINT----------------------------
000011A0                           308  * Description:
000011A0                           309  * Prints hex addresses according to where we are in the .S file
000011A0                           310  * and source/destination effective addresses
000011A0                           311  *
000011A0                           312  * No Parameters
000011A0                           313  *
000011A0                           314  * Registers:
000011A0                           315  *   D0 = used for tasks and trap #15
000011A0                           316  *   D1 = size of comparison
000011A0                           317  *   D2 = destination for comparisons, holds an address
000011A0                           318  *   D3 = iterator
000011A0                           319  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000011A0                           320  *   A2 = current address (given by user)
000011A0                           321  *-----------------------------------------------------------
000011A0                           322  
000011A0                           323  *----------------------PRINT_ADDRESS------------------------
000011A0                           324  PRINT_ADDRESS:
000011A0                           325              * reset A1 to beginning of string
000011A0                           326m             CLR_D_REGS
000011B0                           327m             CLR_A_REG D0, A1
000011B4                           328              
000011B4                           329              * move current address to D2
000011B4  240A                     330              MOVE.L    A2, D2
000011B6                           331  
000011B6                           332              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
000011B6  223C 00008000            333              MOVE.L    #$8000, D1
000011BC  B481                     334              CMP.L     D1, D2
000011BE  6D00 000E                335              BLT       PRINT_WORD
000011C2                           336              
000011C2                           337              * if absolute long, print long. Range $8000 - $FFFF7FFF
000011C2  223C FFFF8000            338              MOVE.L    #$FFFF8000, D1
000011C8  B481                     339              CMP.L     D1, D2
000011CA  6C00 0022                340              BGE       PRINT_LONG                 
000011CE                           341  
000011CE                           342  PRINT_WORD:
000011CE                           343m             CLR_D_REGS
000011DE  123C 0001                344              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000011E2  3E0A                     345              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000011E4  4EB9 00001700            346              JSR       HEX_TO_ASCII
000011EA  6000 0022                347              BRA       FINISH_PRINT
000011EE                           348  
000011EE                           349  PRINT_LONG:
000011EE                           350m             CLR_D_REGS
000011FE  123C 0003                351              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
00001202  2E0A                     352              MOVE.L    A2, D7
00001204  4EB9 00001700            353              JSR       HEX_TO_ASCII
0000120A  6000 0002                354              BRA       FINISH_PRINT
0000120E                           355  
0000120E                           356  FINISH_PRINT:
0000120E                           357              * print out string
0000120E  12BC 0000                358              MOVE.B    #00,(A1)
00001212                           359m             CLR_D_REGS
00001222                           360m             CLR_A_REG D0, A1
00001226  103C 000E                361              MOVE.B    #14, D0
0000122A  4E4F                     362              TRAP      #15
0000122C  4E75                     363              RTS
0000122E                           364  *-----------------------------------------------------------
0000122E                           365  
0000122E                           366  *-------------------PRINT_INSTRUCTION-----------------------
0000122E                           367  PRINT_INSTRUCTION:    
0000122E                           368              * null terminator
0000122E  12BC 0000                369              MOVE.B    #00,(A1)              
00001232                           370  
00001232                           371              * reset A1 to beginning of string
00001232  4280                     372              CLR.L     D0
00001234                           373m             CLR_A_REG D0, A1
00001238                           374  
00001238                           375              * print out string
00001238  103C 000E                376              MOVE.B    #14, D0
0000123C  4E4F                     377              TRAP      #15
0000123E                           378  
0000123E                           379m             PRINT_MSG newline
0000124A  4E75                     380              RTS
0000124C                           381  *-----------------------------------------------------------
0000124C                           382  
0000124C                           383  
0000124C                           384  
0000124C                           385  
0000124C                           386  
0000124C                           387  
0000124C                           388  
0000124C                           389  
0000124C                           390  
0000124C                           391  
0000124C                           392  
0000124C                           393  
0000124C                           394  
0000124C                           395  
0000124C                           396  
0000124C                           397  
0000124C                           398  
0000124C                           399  
0000124C                           400  
0000124C                           401  
0000124C                           402  *---------------------LOAD ADDRESSES------------------------
0000124C                           403  * Description:
0000124C                           404  * Stores INITIAL values into appropriate address registers 
0000124C                           405  * which is necessary to complete before starting identify opcodes loop
0000124C                           406  * Also pushes reigsters onto the stack
0000124C                           407  *
0000124C                           408  * No Parameters
0000124C                           409  *
0000124C                           410  * Registers:
0000124C                           411  *   A2 = current address (given by user)
0000124C                           412  *   A3 = ending address (given by user)
0000124C                           413  *-----------------------------------------------------------
0000124C                           414  LOAD_ADDRESSES: 
0000124C                           415              * reset A1 to beginning of string
0000124C  4280                     416              CLR.L     D0
0000124E                           417m             CLR_A_REG D0, A1
00001252                           418  
00001252                           419              * load start and end registers and print starting address
00001252  2478 106A                420              MOVEA.L startAddr, A2
00001256  2678 106E                421              MOVEA.L endAddr, A3
0000125A  6100 FF44                422              BSR     PRINT_ADDRESS
0000125E  4EB9 0000176C            423              JSR     INSERT_SPACE
00001264                           424  
00001264  6100 0042                425              BSR     GRAB_NEXT_WORD
00001268  6100 0044                426              BSR     GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
0000126C                           427  
0000126C                           428              * Push current registers onto the stack (so we can have fresh registers)
0000126C  48E7 FF00                429              MOVEM.L D0-D7,-(SP)              ; move the old registers onto the stack
00001270  6000 004E                430              BRA     FIND_OPCODE
00001274                           431  *-----------------------------------------------------------
00001274                           432  
00001274                           433  *-----------------------------------------------------------
00001274                           434  * Description:  IDENTIFY OPCODES LOOP
00001274                           435  * Registers:
00001274                           436  *   D0 = used for tasks and trap #15
00001274                           437  *   D1 = size of shifting bits
00001274                           438  *   D2 = destination for shifts
00001274                           439  *   D3 = size of opcode
00001274                           440  *   D4 = used to hold bits returned from SHIFT macro
00001274                           441  *   D7 = holds address (word in length)
00001274                           442  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001274                           443  *   A2 = current address (given by user)
00001274                           444  *   A3 = ending address (given by user)
00001274                           445  *-----------------------------------------------------------
00001274                           446  *-------------------IDENTIFY OPCODES------------------------
00001274                           447  * evaluates an opcode based on first four bits (aka opTag)
00001274                           448  * for now only works with one instruction
00001274                           449  *-----------------------------------------------------------
00001274                           450  IDENTIFY_OPCODE:
00001274                           451  
00001274                           452              * print opcode
00001274  61B8                     453              BSR     PRINT_INSTRUCTION
00001276                           454  
00001276                           455              * check if starting address >= ending address
00001276  B5CB                     456              CMPA.L  A3, A2
00001278  6C00 0532                457              BGE     DONE
0000127C                           458              
0000127C                           459              * print next address
0000127C  6100 FF22                460              BSR     PRINT_ADDRESS
00001280  4EB9 0000176C            461              JSR     INSERT_SPACE
00001286                           462              
00001286                           463              ;BSR     RESTORE_REGS           need to fix
00001286                           464  
00001286                           465m             CLR_D_REGS
00001296  6100 0010                466              BSR     GRAB_NEXT_WORD          * grab opcode
0000129A  6100 0012                467              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
0000129E                           468             
0000129E  6000 0020                469              BRA     FIND_OPCODE
000012A2                           470  *------------------------------------------------------------
000012A2                           471  
000012A2                           472  *----------------------RESTORE_REGS--------------------------
000012A2                           473  * Description:
000012A2                           474  * Move the old registers onto the stack
000012A2                           475  *------------------------------------------------------------
000012A2                           476  RESTORE_REGS:
000012A2  4CDF 00FF                477              MOVEM.L (SP)+, D0-D7            
000012A6  4E75                     478              RTS
000012A8                           479  *-----------------------------------------------------------
000012A8                           480  
000012A8                           481  *---------Useful Subroutines For Identifying Opcodes--------
000012A8                           482  GRAB_NEXT_WORD:
000012A8                           483              * load current word of bits into D7
000012A8  31DA 107A                484              MOVE.W (A2)+, opcode
000012AC  4E75                     485              RTS
000012AE                           486  
000012AE                           487  GRAB_FIRST_FOUR_BITS:
000012AE                           488              * find first four bits of opcode
000012AE  3438 107A                489              MOVE.W  opcode, D2
000012B2  123C 000C                490              MOVE.B  #12, D1
000012B6  E2AA                     491              LSR.L   D1, D2
000012B8  1002                     492              MOVE.B  D2, D0
000012BA  11C0 107C                493              MOVE.B  D0, opTag
000012BE  4E75                     494              RTS
000012C0                           495  *-----------------------------------------------------------
000012C0                           496  
000012C0                           497  
000012C0                           498  
000012C0                           499  
000012C0                           500  
000012C0                           501  
000012C0                           502  
000012C0                           503  
000012C0                           504  
000012C0                           505  *----------------------FIND OPCODE--------------------------
000012C0                           506  * Description:
000012C0                           507  * Finds a matching opTag (first four bits of opcode) and 
000012C0                           508  * jumps to that opcode's encoding subroutine
000012C0                           509  *
000012C0                           510  * For example:
000012C0                           511  *               ADD's first four bits = 1101, so I put
000012C0                           512  *               CMP.B #%1101, D0
000012C0                           513  *
000012C0                           514  * No Parameters
000012C0                           515  *
000012C0                           516  * No Registers Used
000012C0                           517  *-----------------------------------------------------------        
000012C0                           518  FIND_OPCODE:
000012C0  0C38 0000 107C           519              CMP.B   #%0000, opTag 
000012C6  6700 003E                520              BEQ     OPC_0000
000012CA                           521  
000012CA  0C38 0004 107C           522              CMP.B   #%0100, opTag 
000012D0  6700 00A6                523              BEQ     OPC_0100
000012D4                           524  
000012D4  0C38 0008 107C           525              CMP.B   #%1000, opTag
000012DA  6700 015E                526              BEQ     OPC_1000
000012DE                           527  
000012DE  0C38 0009 107C           528              CMP.B   #%1001, opTag
000012E4  6700 017E                529              BEQ     OPC_1001
000012E8                           530  
000012E8  0C38 000C 107C           531              CMP.B   #%1100, opTag
000012EE  6700 0188                532              BEQ     OPC_1100
000012F2                           533  
000012F2  0C38 000D 107C           534              CMP.B   #%1101, opTag
000012F8  6700 01DE                535              BEQ     OPC_1101
000012FC                           536  
000012FC                           537              * error, bad opcode
000012FC  6000 0002                538              BRA      BAD_OPCODE
00001300                           539  
00001300                           540  *-----------------------------------------------------------
00001300                           541  
00001300                           542  *-----------------------BAD OPCODE--------------------------
00001300                           543  BAD_OPCODE:
00001300  4EF9 000017AC            544              JMP      DONE
00001306                           545  *-----------------------------------------------------------
00001306                           546  
00001306                           547  *------------------------OPC_0000---------------------------
00001306                           548  * First four bits = 0000
00001306                           549  * (ADDI)
00001306                           550  *-----------------------------------------------------------
00001306                           551  OPC_0000:
00001306  12FC 0041                552              MOVE.B  #'A',(A1)+          * Put ADD into Buff
0000130A  12FC 0044                553              MOVE.B  #'D',(A1)+
0000130E  12FC 0044                554              MOVE.B  #'D',(A1)+
00001312  12FC 0049                555              MOVE.B  #'I',(A1)+
00001316  12FC 002E                556              MOVE.B  #'.',(A1)+
0000131A                           557  
0000131A                           558m             GET_BITS #7, #6             * get size bits (gets returned to D4)
0000131A                           559m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001320                           560m             * GET HIGH BIT OFFSET
00001326                           561m             * SHIFT OUT HIGH BITS
0000132C                           562m             *GET LOW BIT OFFSET
0000132C                           563m             *16 - NUMBER OF BITS WE WANT
00001332                           564m             * SHIFT OUT LOW BITS
00001334  3604                     565              MOVE    D4, D3              * load parameter for SIZE_TO_BUFFER
00001336  4EB9 00001772            566              JSR     SIZE_TO_BUFFER      * put operation size in buffer
0000133C  6100 0016                567              BSR     CHECK_IMMEDIATE
00001340  12FC 002C                568              MOVE.B  #',',(A1)+
00001344  4EB9 0000176C            569              JSR     INSERT_SPACE
0000134A  4EB9 00001596            570              JSR     GET_EA_MODE
00001350  6000 FF22                571              BRA     IDENTIFY_OPCODE
00001354                           572  
00001354                           573  CHECK_IMMEDIATE:
00001354  12FC 0023                574              MOVE.B  #'#', (A1)+
00001358                           575  
00001358  B67C 0001                576              CMP     #1, D3
0000135C  6F00 000A                577              BLE     IMMEDIATE_WORD
00001360                           578  
00001360  B67C 0002                579              CMP     #2, D3
00001364  6000 000A                580              BRA     IMMEDIATE_LONG
00001368                           581  
00001368                           582  IMMEDIATE_WORD:
00001368  4EB9 000016CA            583              JSR     EA_WORD
0000136E  4E75                     584              RTS
00001370                           585  
00001370                           586  IMMEDIATE_LONG:
00001370  4EB9 000016DE            587              JSR     EA_LONG      
00001376  4E75                     588              RTS
00001378                           589  
00001378                           590  
00001378                           591  *------------------------OPC_0100---------------------------
00001378                           592  * First four bits = 0100
00001378                           593  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
00001378                           594  *-----------------------------------------------------------
00001378                           595  OPC_0100:
00001378                           596  
00001378                           597              ;Check if the opcode is NOP
00001378  3438 107A                598              MOVE.W  opcode, D2          ;Copy opcode to D2
0000137C  B47C 4E71                599              CMP.W   #$4E71, D2          ;Check if D2 is equal to NOP (0x4E71 in hex)
00001380  6700 0038                600              BEQ     OPC_NOP             ;If equal branch to label to handle the opcode NOP
00001384                           601              
00001384                           602              ;Check if the opcode is NOT
00001384  E082                     603              ASR.L   #8, D2 ;Shift bits to compare
00001386  B43C 0046                604              CMP.B   #%01000110, D2
0000138A  6700 003E                605              BEQ     OPC_NOT
0000138E  4282                     606              CLR.L   D2
00001390                           607              
00001390                           608              ;Check if the opcode is LEA
00001390  3838 107A                609              MOVE.W  opcode, D4 ;Put opcode in D4 to use the macro get bits
00001394                           610m             GET_BITS #8, #6 
00001394                           611m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000139A                           612m             * GET HIGH BIT OFFSET
000013A0                           613m             * SHIFT OUT HIGH BITS
000013A6                           614m             *GET LOW BIT OFFSET
000013A6                           615m             *16 - NUMBER OF BITS WE WANT
000013AC                           616m             * SHIFT OUT LOW BITS
000013AE  B83C 0007                617              CMP.B #%00000111, D4 ;if bits 6-8 are equal to 111, then the opocde is LEA
000013B2  6700 0052                618              BEQ     OPC_LEA
000013B6  4282                     619              CLR.L   D2 ;If opcode doesn't match clear appropriate registers 
000013B8  4284                     620              CLR.L   D4
000013BA                           621  
000013BA                           622  *---------------------------OPC_NOP--------------------------------
000013BA                           623  
000013BA                           624  OPC_NOP:
000013BA                           625              * Put NOP into A1 buffer for printing
000013BA  12FC 004E                626              MOVE.B  #'N',(A1)+      
000013BE  12FC 004F                627              MOVE.B  #'O',(A1)+ 
000013C2  12FC 0050                628              MOVE.B  #'P',(A1)+ 
000013C6                           629              
000013C6  6000 FEAC                630              BRA     IDENTIFY_OPCODE
000013CA                           631  
000013CA                           632  
000013CA                           633  *-----------------------------OPC_NOT------------------------------
000013CA                           634  
000013CA                           635  OPC_NOT:
000013CA                           636              * Put NOT into A1 buffer for printing
000013CA  12FC 004E                637              MOVE.B  #'N',(A1)+ 
000013CE  12FC 004F                638              MOVE.B  #'O',(A1)+
000013D2  12FC 0054                639              MOVE.B  #'T',(A1)+
000013D6  12FC 002E                640              MOVE.B  #'.',(A1)+
000013DA                           641              
000013DA                           642              * Calculate Size (.b,.w.l)
000013DA  4EB9 000013F0            643              JSR     GET_NOT_SIZE
000013E0  4EB9 00001772            644              JSR     SIZE_TO_BUFFER 
000013E6  4EB9 00001596            645              JSR     GET_EA_MODE
000013EC  6000 FE86                646              BRA     IDENTIFY_OPCODE
000013F0                           647              
000013F0                           648  GET_NOT_SIZE:
000013F0  4282                     649              CLR.L   D2
000013F2  3438 107A                650              MOVE.W  opcode, D2
000013F6                           651  
000013F6                           652              * shift left to get rid of opTag
000013F6  123C 0008                653              MOVE.B  #8, D1
000013FA  E36A                     654              LSL.W   D1, D2
000013FC                           655  
000013FC                           656              * shift right to get rid of opmode, mode, and register bits
000013FC  123C 000E                657              MOVE.B  #14, D1
00001400  E26A                     658              LSR.W   D1, D2
00001402                           659  
00001402                           660              * store in appropriate register
00001402  1602                     661              MOVE.B  D2, D3
00001404  4E75                     662              RTS
00001406                           663  
00001406                           664  OPC_LEA:
00001406                           665             * Put LEA into A1 buffer for printing
00001406  12FC 004C                666              MOVE.B  #'L',(A1)+      
0000140A  12FC 0045                667              MOVE.B  #'E',(A1)+ 
0000140E  12FC 0041                668              MOVE.B  #'A',(A1)+
00001412  12FC 002E                669              MOVE.B  #'.',(A1)+ 
00001416  12FC 004C                670              MOVE.B  #'L',(A1)+ 
0000141A  4EB9 0000176C            671              JSR INSERT_SPACE
00001420                           672                      
00001420  4EB9 00001596            673              JSR GET_EA_MODE
00001426  12FC 002C                674              MOVE.B  #',',(A1)+ 
0000142A  4EB9 0000176C            675              JSR INSERT_SPACE
00001430  4EB9 00001576            676              JSR GET_DATA_REG_NUM
00001436  6000 FE3C                677              BRA IDENTIFY_OPCODE    
0000143A                           678  
0000143A                           679  *-----------------------------------------------------------
0000143A                           680  
0000143A                           681  *---------------------------opc_1001------------------------
0000143A                           682  
0000143A                           683  OPC_1000:   * keeping this in case there's more that start with 1000
0000143A  6000 0002                684              BRA     OPC_DIVU
0000143E                           685              
0000143E                           686  OPC_DIVU:
0000143E  12FC 0044                687              MOVE.B  #'D',(A1)+
00001442  12FC 0049                688              MOVE.B  #'I',(A1)+
00001446  12FC 0056                689              MOVE.B  #'V',(A1)+
0000144A  12FC 0055                690              MOVE.B  #'U',(A1)+
0000144E  12FC 002E                691              MOVE.B  #'.',(A1)+
00001452  12FC 0057                692              MOVE.B  #'W',(A1)+  * always size word
00001456  12FC 0020                693              MOVE.B  #' ',(A1)+
0000145A                           694              
0000145A                           695              * set the valid bits (since there's only one adressing mode)
0000145A  11FC 00BF 107D           696              MOVE.B  #%10111111, valid
00001460                           697              
00001460  6000 00C6                698              BRA     EA_TO_D
00001464                           699  
00001464                           700  *-----------------------------------------------------------
00001464                           701  
00001464                           702  *-----------------------OPC_1001----------------------------
00001464                           703  * First four bits = 1001
00001464                           704  * (SUB)
00001464                           705  *-----------------------------------------------------------
00001464                           706  OPC_1001:
00001464                           707              * fill in A1 register
00001464  12FC 0053                708              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001468  12FC 0055                709              MOVE.B  #'U',(A1)+
0000146C  12FC 0042                710              MOVE.B  #'B',(A1)+
00001470  12FC 002E                711              MOVE.B  #'.',(A1)+
00001474  6000 0076                712              BRA     PROCESS_ROEA
00001478                           713  *-----------------------------------------------------------
00001478                           714  
00001478                           715  *-----------------------OPC_1100----------------------------
00001478                           716  * First four bits = 1100
00001478                           717  * (AND, MULS)
00001478                           718  *-----------------------------------------------------------
00001478                           719  OPC_1100:   
00001478                           720              ; check to see if bits 8-6 are 111
00001478                           721              ; if they are, then branch to PARSE_MULS
00001478                           722              ; else, keep going to parse AND
00001478                           723  
00001478                           724m             GET_BITS #8, #6
00001478                           725m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000147E                           726m             * GET HIGH BIT OFFSET
00001484                           727m             * SHIFT OUT HIGH BITS
0000148A                           728m             *GET LOW BIT OFFSET
0000148A                           729m             *16 - NUMBER OF BITS WE WANT
00001490                           730m             * SHIFT OUT LOW BITS
00001492  B83C 0007                731              CMP.B   #%00000111, D4
00001496  6700 001A                732              BEQ     OPC_MULS
0000149A  6600 0002                733              BNE     OPC_AND
0000149E                           734  
0000149E                           735  
0000149E                           736  *---------------------------OPC_AND------------------------
0000149E                           737  OPC_AND:    ; AND opcode subroutine
0000149E                           738  
0000149E                           739              ;-----------------------------
0000149E                           740              ; fill A1 with the opcode name
0000149E  12FC 0041                741              MOVE.B  #'A',(A1)+
000014A2  12FC 004E                742              MOVE.B  #'N',(A1)+
000014A6  12FC 0044                743              MOVE.B  #'D',(A1)+
000014AA  12FC 002E                744              MOVE.B  #'.',(A1)+
000014AE  6000 003C                745              BRA     PROCESS_ROEA
000014B2                           746  
000014B2                           747  *---------------------------OPC_MULS------------------------
000014B2                           748  OPC_MULS:  * MULS opcode subroutine
000014B2                           749  
000014B2                           750              * load the command name into the output
000014B2  12FC 004D                751              MOVE.B  #'M',(A1)+
000014B6  12FC 0055                752              MOVE.B  #'U',(A1)+
000014BA  12FC 004C                753              MOVE.B  #'L',(A1)+
000014BE  12FC 0053                754              MOVE.B  #'S',(A1)+
000014C2  12FC 002E                755              MOVE.B  #'.',(A1)+
000014C6  12FC 0057                756              MOVE.B  #'W',(A1)+ * always size word
000014CA  12FC 0020                757              MOVE.B  #' ',(A1)+
000014CE                           758              
000014CE  11FC 00BF 107D           759              MOVE.B  #%10111111, valid   * set the valid mode bits (to be used later)
000014D4                           760              
000014D4  6000 0052                761              BRA     EA_TO_D * just the one addressing mode
000014D8                           762  
000014D8                           763  *---------------------------opc_1101------------------------
000014D8                           764  * First four bits = 1101
000014D8                           765  * (ADD)
000014D8                           766  *-----------------------------------------------------------
000014D8                           767  OPC_1101:
000014D8                           768              * fill in A1 register
000014D8  12FC 0041                769              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000014DC  12FC 0044                770              MOVE.B  #'D',(A1)+
000014E0  12FC 0044                771              MOVE.B  #'D',(A1)+
000014E4  12FC 002E                772              MOVE.B  #'.',(A1)+
000014E8  6000 0002                773              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
000014EC                           774  
000014EC                           775  *-----------------------------------------------------------
000014EC                           776  
000014EC                           777  
000014EC                           778  
000014EC                           779  
000014EC                           780  
000014EC                           781  
000014EC                           782  
000014EC                           783  
000014EC                           784  
000014EC                           785  
000014EC                           786  
000014EC                           787  *--------------Process Register->Opmode->EA-----------------
000014EC                           788  * Description:
000014EC                           789  * Parses bits for opcodes that share bit placements:
000014EC                           790  * ROEA stands for Register, Opmode, and Effective Address,
000014EC                           791  * because the opcodes below share this bit order.
000014EC                           792  *
000014EC                           793  * Used by: (ADD, SUB, MULS)
000014EC                           794  *
000014EC                           795  *-----------------------------------------------------------
000014EC                           796  PROCESS_ROEA:
000014EC  4EB9 0000154A            797              JSR     GET_SIZE
000014F2  4EB9 00001772            798              JSR     SIZE_TO_BUFFER
000014F8  4EB9 00001560            799              JSR     OPMODE_TYPE         * 0 or 1 value (either <ea> -> Dn or Dn -> <ea>)  
000014FE  B83C 0001                800              CMP.B   #1, D4              * is this Dn + <ea> -> <ea>?
00001502  6700 000A                801              BEQ     D_TO_EA
00001506  B83C 0000                802              CMP.B   #0, D4              * is this Dn + <ea> -> <ea>?
0000150A  6700 001C                803              BEQ     EA_TO_D
0000150E                           804  
0000150E                           805  D_TO_EA:
0000150E  4EB9 00001576            806              JSR     GET_DATA_REG_NUM
00001514  12FC 002C                807              MOVE.B  #',',(A1)+
00001518  4EB9 0000176C            808              JSR     INSERT_SPACE
0000151E  4EB9 00001596            809              JSR     GET_EA_MODE
00001524  6000 001C                810              BRA     ROEA_DONE
00001528                           811  
00001528                           812  EA_TO_D:
00001528  4EB9 00001596            813              JSR     GET_EA_MODE
0000152E  12FC 002C                814              MOVE.B  #',',(A1)+
00001532  4EB9 0000176C            815              JSR     INSERT_SPACE
00001538  4EB9 00001576            816              JSR     GET_DATA_REG_NUM
0000153E  6000 0002                817              BRA     ROEA_DONE
00001542                           818  
00001542                           819  ROEA_DONE:
00001542  12FC 0020                820              MOVE.B  #' ',(A1)+
00001546  6000 FD2C                821              BRA     IDENTIFY_OPCODE
0000154A                           822              
0000154A                           823  
0000154A                           824  GET_SIZE:
0000154A                           825              * copy current instruction to shift
0000154A  4282                     826              CLR.L   D2
0000154C  3438 107A                827              MOVE.W  opcode ,D2          
00001550                           828              
00001550                           829              * shift left to get rid of opTag
00001550  123C 0008                830              MOVE.B  #8, D1
00001554  E36A                     831              LSL.W   D1, D2
00001556                           832  
00001556                           833              * shift right to get rid of opmode, mode, and register bits
00001556  123C 000E                834              MOVE.B  #14, D1
0000155A  E26A                     835              LSR.W   D1, D2
0000155C                           836  
0000155C                           837              * store in appropriate register
0000155C  1602                     838              MOVE.B  D2, D3
0000155E                           839              
0000155E  4E75                     840              RTS
00001560                           841  
00001560                           842  OPMODE_TYPE:
00001560                           843              * copy current instruction to shift
00001560  4282                     844              CLR.L   D2
00001562  3438 107A                845              MOVE.W  opcode ,D2          
00001566                           846  
00001566                           847              * shift left to identify
00001566  123C 0007                848              MOVE.B  #7, D1
0000156A  E36A                     849              LSL.W   D1, D2
0000156C                           850              
0000156C                           851              * shift left to identify
0000156C  123C 000F                852              MOVE.B  #15, D1
00001570  E26A                     853              LSR.W   D1, D2
00001572                           854  
00001572                           855              * store in appropriate register
00001572  1802                     856              MOVE.B  D2, D4
00001574                           857  
00001574  4E75                     858              RTS
00001576                           859  
00001576                           860  GET_DATA_REG_NUM:
00001576                           861              * D3 should hold the size of the opcode operation
00001576  4282                     862              CLR.L   D2
00001578  3438 107A                863              MOVE.W  opcode, D2  
0000157C                           864  
0000157C                           865              * shift left to identify
0000157C  123C 0004                866              MOVE.B  #4, D1
00001580  E36A                     867              LSL.W   D1, D2
00001582                           868              
00001582                           869              * shift right to isolate high register bits
00001582  123C 000D                870              MOVE.B  #13, D1
00001586  E26A                     871              LSR.W   D1, D2
00001588                           872  
00001588                           873              * store in appropriate register
00001588  12FC 0044                874              MOVE.B  #'D',(A1)+              * add "D" to buffer
0000158C  0602 0030                875              ADD.B   #$30,D2                   * convert data register # to hex digit
00001590  12C2                     876              MOVE.B  D2,(A1)+                * register # to buffer             
00001592  1C02                     877              MOVE.B  D2, D6
00001594                           878  
00001594  4E75                     879              RTS
00001596                           880  
00001596                           881  
00001596                           882  
00001596                           883  
00001596                           884  
00001596                           885  
00001596                           886  
00001596                           887  
00001596                           888  
00001596                           889  
00001596                           890  
00001596                           891  
00001596                           892  
00001596                           893  *----------------------------GET_EA_MODE------------------------
00001596                           894  * Description:
00001596                           895  * Evaluates the ea mode and register of an opcode 
00001596                           896  * (usually last 6 bits of instruction format),
00001596                           897  * and adds it to A1 to be printed out
00001596                           898  *
00001596                           899  * No Parameters
00001596                           900  *
00001596                           901  * Registers Used:
00001596                           902  *   D1 = amount to shift the opcode
00001596                           903  *   D2 = destination for shifts
00001596                           904  *   D5 = addressing mode
00001596                           905  *-----------------------------------------------------------
00001596                           906  GET_EA_MODE:
00001596                           907m             CLR_D_REGS
000015A6                           908              * move size of opcode to be manipulated
000015A6  4282                     909              CLR.L   D2
000015A8  3438 107A                910              MOVE.W  opcode, D2     
000015AC                           911  
000015AC                           912              * shift left to identify
000015AC  123C 000A                913              MOVE.B  #10, D1
000015B0  E36A                     914              LSL.W   D1, D2
000015B2                           915              
000015B2                           916              * shift right to isolate mode bits for EA 
000015B2  123C 000D                917              MOVE.B  #13, D1
000015B6  E26A                     918              LSR.W   D1, D2
000015B8                           919  
000015B8                           920              * store in appropriate register
000015B8  1A02                     921              MOVE.B  D2, D5
000015BA                           922              
000015BA  6000 0002                923              BRA     FIND_MODE
000015BE                           924  
000015BE                           925  *----------------------------FIND_MODE------------------------
000015BE                           926  FIND_MODE:                            
000015BE  BA3C 0000                927              CMP.B   #%0000, D5        * Direct Data Register
000015C2  6700 003E                928              BEQ     ea_000
000015C6                           929  
000015C6  BA3C 0001                930              CMP.B   #%0001, D5        * Direct Address Register
000015CA  6700 004E                931              BEQ     ea_001
000015CE                           932  
000015CE  BA3C 0002                933              CMP.B   #%0010, D5        * Indirect Address Register
000015D2  6700 005E                934              BEQ     ea_010
000015D6                           935  
000015D6  BA3C 0003                936              CMP.B   #%0011, D5        * Post Increment
000015DA  6700 0076                937              BEQ     ea_011
000015DE                           938  
000015DE  BA3C 0004                939              CMP.B   #%0100, D5        * Pre Decrement
000015E2  6700 0092                940              BEQ     ea_100
000015E6                           941  
000015E6  BA3C 0005                942              CMP.B   #%0101, D5        * Not necessary, go to bad ea
000015EA  6700 00AE                943              BEQ     ea_101
000015EE                           944  
000015EE  BA3C 0006                945              CMP.B   #%0110, D5        * Not necessary, go to bad ea
000015F2  6700 00AA                946              BEQ     ea_110
000015F6                           947  
000015F6  BA3C 0007                948              CMP.B   #%0111, D5        * Absolute or immediate address
000015FA  6700 00A6                949              BEQ     ea_111
000015FE                           950  
000015FE  6000 00FA                951              BRA    INVALID_EA
00001602                           952  
00001602                           953  *----------------------------Direct Data Register------------------------
00001602                           954  ea_000:
00001602  3438 107A                955              MOVE.W      opcode, D2              * move current working word into temp storage
00001606  12FC 0044                956              MOVE.B      #'D',(A1)+              * add "D" to buffer
0000160A                           957              
0000160A  123C 000D                958              MOVE.B      #13, D1
0000160E  E36A                     959              LSL.W       D1,D2                   * isolate register bits (last 3)
00001610  E26A                     960              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
00001612  0602 0030                961              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001616                           962  
00001616  12C2                     963              MOVE.B      D2,(A1)+                * register # to buffer                  
00001618                           964              
00001618  4E75                     965              RTS                                
0000161A                           966  
0000161A                           967  *----------------------------Direct Address Register------------------------
0000161A                           968  ea_001:
0000161A  3438 107A                969              MOVE.W      opcode, D2              * move current working word into temp storage
0000161E  12FC 0041                970              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001622                           971              
00001622  123C 000D                972              MOVE.B      #13, D1
00001626  E36A                     973              LSL.W       D1,D2                   * isolate register bits (last 3)
00001628  E26A                     974              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
0000162A  0602 0030                975              ADD.B       #$30,D2                 * convert data register # to ASCII digit
0000162E                           976  
0000162E  12C2                     977              MOVE.B      D2,(A1)+                * register # to buffer               
00001630                           978                
00001630  4E75                     979              RTS                            
00001632                           980  
00001632                           981  *----------------------------Indirect Address Register------------------------
00001632                           982  ea_010:
00001632  3438 107A                983              MOVE.W      opcode, D2              * move current working word into temp storage
00001636  12FC 0028                984              MOVE.B      #'(',(A1)+              * add "(" to buffer
0000163A  12FC 0041                985              MOVE.B      #'A',(A1)+              * add "A" to buffer
0000163E                           986  
0000163E  123C 000D                987              MOVE.B      #13, D1
00001642  E36A                     988              LSL.W       D1,D2                   * isolate register bits (last 3)
00001644  E26A                     989              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
00001646  0602 0030                990              ADD.B       #$30,D2                 * convert data register # to ASCII digit
0000164A  12C2                     991              MOVE.B      D2,(A1)+                * register # to buffer     
0000164C                           992  
0000164C  12FC 0029                993              MOVE.B      #')',(A1)+              * add ")" to buffer
00001650                           994               
00001650  4E75                     995              RTS                            
00001652                           996  
00001652                           997  *----------------------------Post Increment------------------------
00001652                           998  ea_011:
00001652  3438 107A                999              MOVE.W      opcode, D2              * move current working word into temp storage
00001656                          1000  
00001656  12FC 0028               1001              MOVE.B      #'(',(A1)+              * add "(" to buffer
0000165A  12FC 0041               1002              MOVE.B      #'A',(A1)+              * add "A" to buffer
0000165E                          1003              
0000165E  123C 000D               1004              MOVE.B      #13, D1
00001662  E36A                    1005              LSL.W       D1,D2                   * isolate register bits (last 3)
00001664  E26A                    1006              LSR.W       D1,D2                  
00001666  0602 0030               1007              ADD.B       #$30,D2                 * convert data register # to ASCII digit
0000166A  12C2                    1008              MOVE.B      D2,(A1)+                * register # to buffer     
0000166C                          1009  
0000166C  12FC 0029               1010              MOVE.B      #')',(A1)+              * add ")" to buffer
00001670  12FC 002B               1011              MOVE.B      #'+',(A1)+              * add "+" to buffer
00001674                          1012                   
00001674  4E75                    1013              RTS                              
00001676                          1014  
00001676                          1015  *----------------------------Pre Decrement------------------------
00001676                          1016  ea_100:
00001676  3438 107A               1017              MOVE.W      opcode, D2              * move current working word into temp storage
0000167A                          1018  
0000167A  12FC 002D               1019              MOVE.B      #'-',(A1)+              * add "-" to buffer
0000167E  12FC 0028               1020              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001682  12FC 0041               1021              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001686                          1022              
00001686  123C 000D               1023              MOVE.B      #13, D1
0000168A  E36A                    1024              LSL.W       D1, D2                   * isolate register bits (last 3)
0000168C  E26A                    1025              LSR.W       D1, D2                   * D2 now holds the mode of the opcode
0000168E  0602 0030               1026              ADD.B       #$30, D2                 * convert data register # to ASCII digit
00001692  12C2                    1027              MOVE.B      D2, (A1)+                * register # to buffer     
00001694                          1028  
00001694  12FC 0029               1029              MOVE.B      #')',(A1)+               * add ")" to buffer
00001698                          1030              
00001698  4E75                    1031              RTS
0000169A                          1032  
0000169A                          1033  *----------------------------Not necessary, go to bad ea------------------------
0000169A                          1034  ea_101:
0000169A  6000 005E               1035              BRA         INVALID_EA        
0000169E                          1036  
0000169E                          1037  
0000169E                          1038  *----------------------------Not necessary, go to bad ea------------------------
0000169E                          1039  ea_110:
0000169E  6000 005A               1040              BRA         INVALID_EA        
000016A2                          1041  
000016A2                          1042  
000016A2                          1043  *----------------------------Absolute or immediate address------------------------
000016A2                          1044  ea_111:
000016A2                          1045              * D405      0 0003456  23345245
000016A2                          1046              * ADD.L     $1234, D0
000016A2                          1047  
000016A2                          1048              * 8 bit value
000016A2                          1049              * 11111111
000016A2                          1050  
000016A2                          1051              * 11111011 - Direct data register would be Invalid
000016A2                          1052              * 00000100
000016A2                          1053              * 00000000 -> invalid code
000016A2                          1054  
000016A2                          1055              * and.b     #$F, Dn        ---->  10000000
000016A2                          1056              * cmp.b     #%10000000, Dn  
000016A2                          1057  
000016A2                          1058              * check against valid bits
000016A2                          1059                  * if invalid, branch to invalid opcode subroutine
000016A2                          1060                      * if the mode is 111, then go back and print out addresses
000016A2                          1061  
000016A2  3438 107A               1062              MOVE.W      opcode, D2
000016A6  123C 000D               1063              MOVE.B      #13, D1
000016AA  E36A                    1064              LSL.W       D1, D2                   * isolate register bits (last 3)
000016AC  E26A                    1065              LSR.W       D1, D2                   * isolate register bits (last 3)
000016AE                          1066  
000016AE  B43C 0000               1067              CMP.B       #%000, D2                * compare to determine if it's a word
000016B2  6700 0016               1068              BEQ         EA_WORD                  * put word address in buffer
000016B6                          1069  
000016B6  B43C 0001               1070              CMP.B       #%001, D2                * compare to determine if it's a long
000016BA  6700 0022               1071              BEQ         EA_LONG                  * put long address in buffer
000016BE                          1072              
000016BE  B43C 0004               1073              CMP.B       #%100, D2
000016C2  6700 002E               1074              BEQ         EA_IMMEDIATE             * always print a long if it's immediate data
000016C6                          1075  
000016C6                          1076              * Invalid EA mode/register
000016C6  6000 0032               1077              BRA         INVALID_EA
000016CA                          1078  
000016CA                          1079  EA_WORD:
000016CA  12FC 0024               1080              MOVE.B      #'$', (A1)+
000016CE  4281                    1081              CLR.L       D1
000016D0  123C 0001               1082              MOVE.B      #1, D1
000016D4  3E1A                    1083              MOVE.W      (A2)+, D7
000016D6  6100 0028               1084              BSR         HEX_TO_ASCII
000016DA  6000 001C               1085              BRA         GET_EA_DONE
000016DE                          1086  
000016DE                          1087  EA_LONG:
000016DE  12FC 0024               1088              MOVE.B      #'$', (A1)+
000016E2  4281                    1089              CLR.L       D1
000016E4  123C 0003               1090              MOVE.B      #3, D1
000016E8  2E1A                    1091              MOVE.L      (A2)+, D7   
000016EA  6100 0014               1092              BSR         HEX_TO_ASCII
000016EE  6000 0008               1093              BRA         GET_EA_DONE
000016F2                          1094  
000016F2                          1095  EA_IMMEDIATE:
000016F2  12FC 0023               1096              MOVE.B      #'#', (A1)+
000016F6  60E6                    1097              BRA         EA_LONG
000016F8                          1098  
000016F8                          1099  GET_EA_DONE:
000016F8  4E75                    1100              RTS
000016FA                          1101  
000016FA                          1102  *------------------Invalid Effective Address----------------
000016FA                          1103  INVALID_EA:
000016FA  4EF9 000017AC           1104              JMP      DONE
00001700                          1105  *-----------------------------------------------------------
00001700                          1106  
00001700                          1107  
00001700                          1108  
00001700                          1109  
00001700                          1110  
00001700                          1111  
00001700                          1112  
00001700                          1113  
00001700                          1114  *----------------------HEX TO ASCII-------------------------
00001700                          1115  * Description:
00001700                          1116  * Converts a Hex numbered address (1-9 or A-F) back to an
00001700                          1117  * ASCII value for printing
00001700                          1118  *
00001700                          1119  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
00001700                          1120  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
00001700                          1121  *   D7 = holds the original address to parse (either word or long, for example: $7000)
00001700                          1122  *
00001700                          1123  * Parameters (if calling NUMBER_OR_LETTER (usually done in opcode sections)):
00001700                          1124  *   D2 = should hold value (in hex) you want to push to the buffer
00001700                          1125  *
00001700                          1126  * Registers Used:
00001700                          1127  *   D0 = number of bits to remove
00001700                          1128  *   D2 = holds either top four bits or bottom four bits of each byte in D6
00001700                          1129  *   D3 = holds temp data
00001700                          1130  *   D6 = holds part of address (used as temp variable)
00001700                          1131  *   A1 = used for buffer
00001700                          1132  *-----------------------------------------------------------
00001700                          1133  HEX_TO_ASCII:
00001700  1001                    1134              MOVE.B   D1, D0             * current number of bytes to remove
00001702  C1FC 0008               1135              MULS.W   #8, D0             * number of bits to remove
00001706                          1136  
00001706  2C07                    1137              MOVE.L   D7, D6             * load original address to parse
00001708  E0AE                    1138              LSR.L    D0, D6             * remove lowest byte(s)
0000170A                          1139  
0000170A                          1140              * isolate first four bits
0000170A  1406                    1141              MOVE.B   D6, D2
0000170C  E80A                    1142              LSR.B    #4, D2 
0000170E  6100 0018               1143              BSR      NUMBER_OR_LETTER
00001712                          1144  
00001712                          1145              * isolate second set of four bits
00001712  1406                    1146              MOVE.B   D6, D2
00001714  E90A                    1147              LSL.B    #4, D2 
00001716  E80A                    1148              LSR.B    #4, D2 
00001718  6100 000E               1149              BSR      NUMBER_OR_LETTER
0000171C                          1150  
0000171C  5301                    1151              SUB.B    #1, D1             * iterate
0000171E  B23C 0000               1152              CMP.B    #0, D1             * done if equal
00001722  6D00 0036               1153              BLT      ATH_DONE
00001726                          1154  
00001726  60D8                    1155              BRA      HEX_TO_ASCII
00001728                          1156  
00001728                          1157  NUMBER_OR_LETTER:
00001728  1602                    1158              MOVE.B   D2, D3
0000172A  0603 0030               1159              ADD.B    #$30, D3           
0000172E  B63C 0039               1160              CMP.B    #$39, D3           * is byte in D2 a number?
00001732  6F00 0012               1161              BLE      NUMBER_TO_ASCII
00001736                          1162              
00001736  1602                    1163              MOVE.B   D2, D3
00001738  0603 0037               1164              ADD.B    #$37, D3           
0000173C  B63C 0039               1165              CMP.B    #$39, D3           * is byte in D2 a letter?
00001740  6C00 000C               1166              BGE      LETTER_TO_ASCII
00001744                          1167  
00001744  60B4                    1168              BRA      INVALID_EA
00001746                          1169  
00001746                          1170  NUMBER_TO_ASCII:
00001746  0602 0030               1171              ADD.B    #$30, D2           * Get the hex range from '0-9'
0000174A  6000 000A               1172              BRA      ADD_TO_BUFFER
0000174E                          1173  
0000174E                          1174  LETTER_TO_ASCII:
0000174E  0602 0037               1175              ADD.B    #$37, D2           * Get the hex range from 'A-F'
00001752  6000 0002               1176              BRA      ADD_TO_BUFFER
00001756                          1177  
00001756                          1178  ADD_TO_BUFFER:
00001756  12C3                    1179              MOVE.B   D3, (A1)+          * add part of address to buffer    
00001758  4E75                    1180              RTS
0000175A                          1181  
0000175A                          1182  ATH_DONE:
0000175A                          1183m             CLR_D_REGS
0000176A  4E75                    1184              RTS
0000176C                          1185  *-----------------------------------------------------------
0000176C                          1186  
0000176C                          1187  INSERT_SPACE:
0000176C  12FC 0020               1188              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001770  4E75                    1189              RTS
00001772                          1190  
00001772                          1191  
00001772                          1192  
00001772                          1193  
00001772                          1194  
00001772                          1195  
00001772                          1196  
00001772                          1197  
00001772                          1198  
00001772                          1199  *---------------------SIZE TO BUFFER------------------------
00001772                          1200  * Description:
00001772                          1201  * Evaluates the size of an opcode and adds it to A1 to be printed out
00001772                          1202  *
00001772                          1203  * Parameters:
00001772                          1204  *   D3 = size of opcode
00001772                          1205  *
00001772                          1206  * Registers Used:
00001772                          1207  *   A1: adding words/numbers to buffer
00001772                          1208  *-----------------------------------------------------------
00001772                          1209  SIZE_TO_BUFFER: 
00001772  B63C 0000               1210              CMP.B   #%0000,D3            
00001776  6700 0016               1211              BEQ     BYTE_TO_BUFFER              
0000177A                          1212  
0000177A  B63C 0001               1213              CMP.B   #%0001,D3             * is this a word?
0000177E  6700 0016               1214              BEQ     WORD_TO_BUFFER
00001782                          1215  
00001782  B63C 0002               1216              CMP.B   #%0010,D3             * is this a long?
00001786  6700 0016               1217              BEQ     LONG_TO_BUFFER             
0000178A                          1218        
0000178A  4EF8 1300               1219              JMP     BAD_OPCODE  
0000178E                          1220              
0000178E                          1221  BYTE_TO_BUFFER:
0000178E  12FC 0042               1222              MOVE.B  #'B', (A1)+           * add B to buffer
00001792  6000 0012               1223              BRA     STB_END             
00001796                          1224              
00001796                          1225  WORD_TO_BUFFER:
00001796  12FC 0057               1226              MOVE.B  #'W', (A1)+          * add W to buffer
0000179A  6000 000A               1227              BRA     STB_END             
0000179E                          1228  
0000179E                          1229  LONG_TO_BUFFER:
0000179E  12FC 004C               1230              MOVE.B  #'L',(A1)+          * add L to buffer
000017A2  6000 0002               1231              BRA     STB_END             
000017A6                          1232  
000017A6                          1233  STB_END:
000017A6  12FC 0020               1234              MOVE.B  #' ',(A1)+          * add blank space to buffer
000017AA  4E75                    1235              RTS                         
000017AC                          1236  
000017AC                          1237  
000017AC                          1238  
000017AC                          1239  
000017AC                          1240  
000017AC                          1241  
000017AC                          1242  
000017AC                          1243  *-------------------------DONE-------------------------------
000017AC                          1244  DONE:
000017AC                          1245m             CLR_A_REG D0, A1
000017B0                          1246  
000017B0                          1247              * add 'SIMHAULT' to buffer
000017B0  12FC 0053               1248              MOVE.B  #'S',(A1)+      
000017B4  12FC 0049               1249              MOVE.B  #'I',(A1)+         
000017B8  12FC 004D               1250              MOVE.B  #'M',(A1)+         
000017BC  12FC 0048               1251              MOVE.B  #'H',(A1)+        
000017C0  12FC 0041               1252              MOVE.B  #'A',(A1)+         
000017C4  12FC 0055               1253              MOVE.B  #'U',(A1)+         
000017C8  12FC 004C               1254              MOVE.B  #'L',(A1)+          
000017CC  12FC 0054               1255              MOVE.B  #'T',(A1)+         
000017D0  12FC 0000               1256              MOVE.B  #00,(A1)+         
000017D4                          1257  
000017D4                          1258m             CLR_A_REG D0, A1
000017D8                          1259              
000017D8                          1260              * print out string
000017D8  103C 000E               1261              MOVE.B    #14, D0
000017DC  4E4F                    1262              TRAP      #15
000017DE                          1263              
000017DE                          1264m             CLR_A_REG D0, A1
000017E2                          1265  
000017E2                          1266  
000017E2                          1267              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       1756
ATH_DONE            175A
BADINPUT            1052
BAD_OPCODE          1300
BYTE_TO_BUFFER      178E
CHECK_IMMEDIATE     1354
CHECK_LENGTH        10DC
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      110E
CR                  D
DONE                17AC
DONEMSG             1045
D_TO_EA             150E
EA_000              1602
EA_001              161A
EA_010              1632
EA_011              1652
EA_100              1676
EA_101              169A
EA_110              169E
EA_111              16A2
EA_IMMEDIATE        16F2
EA_LONG             16DE
EA_TO_D             1528
EA_WORD             16CA
ENDADDR             106E
ENDMSG              1023
FIND_MODE           15BE
FIND_OPCODE         12C0
FINISH_PRINT        120E
GET_BITS            1C5
GET_DATA_REG_NUM    1576
GET_EA_DONE         16F8
GET_EA_MODE         1596
GET_END_ADDRESS     10B2
GET_INPUT           1086
GET_NOT_SIZE        13F0
GET_SIZE            154A
GET_START_ADDRESS   1098
GRAB_FIRST_FOUR_BITS  12AE
GRAB_NEXT_WORD      12A8
HEX_TO_ASCII        1700
IDENTIFY_OPCODE     1274
IMMEDIATE_LONG      1370
IMMEDIATE_WORD      1368
INSERT_SPACE        176C
INVALID_EA          16FA
INVALID_INPUT       10F0
ITERATE             1142
LETTER_TO_ASCII     174E
LETTER_TO_HEX       1134
LF                  A
LOAD_ADDRESSES      124C
LONG_TO_BUFFER      179E
MAIN                107E
NEWLINE             1062
NUMBER_OR_LETTER    1728
NUMBER_TO_ASCII     1746
NUM_TO_HEX          112C
OPCODE              107A
OPC_0000            1306
OPC_0100            1378
OPC_1000            143A
OPC_1001            1464
OPC_1100            1478
OPC_1101            14D8
OPC_AND             149E
OPC_DIVU            143E
OPC_LEA             1406
OPC_MULS            14B2
OPC_NOP             13BA
OPC_NOT             13CA
OPMODE_TYPE         1560
OPOUTPUT            1072
OPTAG               107C
PRINT_ADDRESS       11A0
PRINT_INSTRUCTION   122E
PRINT_LONG          11EE
PRINT_MSG           0
PRINT_WORD          11CE
PROCESS_ROEA        14EC
RESTORE_REGS        12A2
ROEA_DONE           1542
SIZE_TO_BUFFER      1772
STARTADDR           106A
STARTMSG            1000
STB_END             17A6
STORE_CHAR          113C
STORE_END           1180
STORE_INPUT         1150
STORE_START         1160
USERADDR            1066
VALID               107D
VALIDATE_INPUT      10CC
WORD_TO_BUFFER      1796
