0000107E Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 4/29/2021 4:52:43 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00001000                            11              ORG     $1000
00001000                            12  
00001000  =0000000D                 13  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 14  LF          EQU     $0A 
00001000                            15  
00001000                            16  
00001000= 50 6C 65 61 73 65 ...     17  startMsg:   DC.B    'Please enter a starting address ', CR, LF, 0
00001023= 50 6C 65 61 73 65 ...     18  endMsg:     DC.B    'Please enter an ending address ', CR, LF, 0
00001045= 65 78 69 74 69 6E ...     19  doneMsg:    DC.B    'exiting...', CR, LF, 0
00001052= 49 6E 76 61 6C 69 ...     20  badInput:   DC.B    'Invalid Input', CR, LF, 0
00001062= 0D 0A 00                  21  newline:    DC.B    '', CR, LF, 0
00001065                            22  
00001066                            23  userAddr:   DS.L    1
0000106A                            24  startAddr:  DS.L    1
0000106E                            25  endAddr:    DS.L    1
00001072                            26  
00001072                            27  opOutput:   DS.L    2
0000107A                            28  
0000107A                            29  opcode:     DS.W    1   
0000107C                            30  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
0000107D                            31  valid:      DS.B    1
0000107E                            32  
0000107E                            33  *-----------------------------------------------------------
0000107E                            34  * Macros:
0000107E                            35  *-----------------------------------------------------------
0000107E                            36  
0000107E                            37  PRINT_MSG:  MACRO 
0000107E                            38              CLR.L   D0
0000107E                            39              LEA     \1, A1      ; \1 acts as a parameter
0000107E                            40              MOVE.B  #14, D0     
0000107E                            41              TRAP    #15
0000107E                            42              ENDM
0000107E                            43  
0000107E                            44  CLR_D_REGS: MACRO
0000107E                            45              CLR.L   D0
0000107E                            46              CLR.L   D1
0000107E                            47              CLR.L   D2
0000107E                            48              CLR.L   D3
0000107E                            49              CLR.L   D4
0000107E                            50              CLR.L   D5
0000107E                            51              CLR.L   D6
0000107E                            52              CLR.L   D7
0000107E                            53              ENDM
0000107E                            54  
0000107E                            55  CLR_A_REG:  MACRO
0000107E                            56              CLR.L   \1
0000107E                            57              MOVE.L  \1, \2
0000107E                            58              ENDM              
0000107E                            59  
0000107E                            60  *-----------------------------------------------------------
0000107E                            61  * Description:  Get User Input
0000107E                            62  *-----------------------------------------------------------
0000107E                            63  
0000107E                            64  *-------------------------MAIN------------------------------
0000107E                            65  MAIN:
0000107E  6100 0006                 66              BSR     GET_INPUT
00001082  6000 01C8                 67              BRA     LOAD_ADDRESSES
00001086                            68  *-----------------------------------------------------------
00001086                            69  
00001086                            70  *-------------------------Get Input-------------------------
00001086                            71  GET_INPUT:
00001086  B87C 0000                 72              CMP      #0, D4
0000108A  6700 000C                 73              BEQ      GET_START_ADDRESS
0000108E                            74                 
0000108E  21C6 106A                 75              MOVE.L   D6, startAddr
00001092  21C7 106E                 76              MOVE.L   D7, endAddr
00001096  4E75                      77              RTS 
00001098                            78  *-----------------------------------------------------------
00001098                            79  
00001098                            80  *----------------------Get Starting Address----------------------
00001098                            81  GET_START_ADDRESS:
00001098  4280                      82              CLR.L   D0
0000109A  43F8 1000                 83              LEA.L   startMsg, A1      
0000109E  103C 000E                 84              MOVE.B  #14, D0     
000010A2  4E4F                      85              TRAP    #15
000010A4                            86  
000010A4  43F8 1066                 87              LEA.L   userAddr, A1
000010A8  103C 0002                 88              MOVE.B  #2, D0
000010AC  4E4F                      89              TRAP    #15
000010AE                            90              ;MOVE.B  D1, startSize
000010AE  6000 001C                 91              BRA     VALIDATE_INPUT
000010B2                            92  *-----------------------------------------------------------
000010B2                            93  
000010B2                            94  *----------------------Get Ending Address----------------------
000010B2                            95  GET_END_ADDRESS:
000010B2  4280                      96              CLR.L   D0
000010B4  43F8 1023                 97              LEA.L   endMsg, A1      
000010B8  103C 000E                 98              MOVE.B  #14, D0     
000010BC  4E4F                      99              TRAP    #15
000010BE                           100  
000010BE  43F8 1066                101              LEA.L   userAddr, A1
000010C2  103C 0002                102              MOVE.B  #2, D0
000010C6  4E4F                     103              TRAP    #15
000010C8                           104              ;MOVE.B  D1, endSize
000010C8  6000 0012                105              BRA     CHECK_LENGTH
000010CC                           106  *-----------------------------------------------------------
000010CC                           107  
000010CC                           108  
000010CC                           109  
000010CC                           110  
000010CC                           111  
000010CC                           112  *-----------------------------------------------------------
000010CC                           113  * Description:  Validate User Input
000010CC                           114  * Constraints:  
000010CC                           115  *   User input must be:
000010CC                           116  *   Length 4 or Length 8
000010CC                           117  *   ASCII character 0-9 or A-F
000010CC                           118  *   Starting and ending address with value < $00FFFFFF 
000010CC                           119  *   Starting address is before ending address
000010CC                           120  *-----------------------------------------------------------
000010CC                           121  
000010CC                           122  *----------------------VALIDATE INPUT---------------------------      
000010CC                           123  
000010CC                           124  VALIDATE_INPUT:        
000010CC  B83C 0000                125              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
000010D0  6700 000A                126              BEQ        CHECK_LENGTH         ; if equal, parse START address 
000010D4  B83C 0001                127              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
000010D8  67D8                     128              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
000010DA  60AA                     129              BRA        GET_INPUT            ; done parsing, D4 = 2
000010DC                           130  
000010DC                           131  CHECK_LENGTH:
000010DC  B23C 0004                132              CMP.B      #4, D1               ; for task 2, length of string is in D1                
000010E0  6700 002C                133              BEQ        CONVERT_TO_HEX 
000010E4  B23C 0008                134              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
000010E8  6700 0024                135              BEQ        CONVERT_TO_HEX
000010EC  6000 0002                136              BRA        INVALID_INPUT
000010F0                           137  
000010F0                           138  INVALID_INPUT:  
000010F0  4283                     139              CLR.L      D3
000010F2                           140m             PRINT_MSG  badInput
000010FE  B83C 0000                141              CMP.B      #0, D4 
00001102  6794                     142              BEQ        GET_START_ADDRESS  
00001104  B83C 0001                143              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001108  67A8                     144              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
0000110A  6000 FF72                145              BRA        MAIN
0000110E                           146  *-----------------------------------------------------------
0000110E                           147  
0000110E                           148  *----------------CONVERT FROM ASCII TO HEX------------------
0000110E                           149  CONVERT_TO_HEX:
0000110E  0C11 0030                150              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001112  6DDC                     151              BLT        INVALID_INPUT        
00001114                           152  
00001114  0C11 003A                153              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001118  6D00 0012                154              BLT        NUM_TO_HEX      
0000111C                           155  
0000111C  0C11 0041                156              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001120  6DCE                     157              BLT        INVALID_INPUT             
00001122                           158  
00001122  0C11 0047                159              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001126  6D00 000C                160              BLT        LETTER_TO_HEX
0000112A                           161  
0000112A  60C4                     162              BRA        INVALID_INPUT    
0000112C                           163  
0000112C                           164  NUM_TO_HEX:      
0000112C  0411 0030                165              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001130  6000 000A                166              BRA        STORE_CHAR   
00001134                           167  
00001134                           168  LETTER_TO_HEX:     
00001134  0411 0037                169              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001138  6000 0002                170              BRA        STORE_CHAR
0000113C                           171  
0000113C                           172  STORE_CHAR:       
0000113C  D619                     173              ADD.B     (A1)+, D3            ; keep hex stored in D3           
0000113E  6000 0002                174              BRA        ITERATE                 
00001142                           175  
00001142                           176  ITERATE:
00001142  5301                     177              SUB.B      #$1, D1
00001144  B23C 0000                178              CMP.B      #0, D1
00001148  6700 0006                179              BEQ        STORE_INPUT
0000114C                           180  
0000114C  E98B                     181              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000114E  60BE                     182              BRA        CONVERT_TO_HEX
00001150                           183  
00001150                           184  STORE_INPUT:
00001150  B83C 0000                185              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
00001154  6700 000A                186              BEQ        STORE_START          ; if equal, parse START address 
00001158                           187              
00001158  B83C 0001                188              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
0000115C  6700 0022                189              BEQ        STORE_END         
00001160                           190  
00001160                           191  STORE_START:
00001160  2C03                     192              MOVE.L     D3, D6
00001162  5204                     193              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001164                           194              ;CLR        D3
00001164                           195              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001164                           196  
00001164                           197              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001164  4281                     198              CLR.L       D1
00001166  2203                     199              MOVE.L      D3, D1   
00001168  103C 0003                200              MOVE.B      #3, D0     
0000116C  4E4F                     201              TRAP        #15
0000116E                           202m             PRINT_MSG   newline
0000117A                           203              
0000117A  4243                     204              CLR         D3
0000117C  6000 FF4E                205              BRA         VALIDATE_INPUT
00001180                           206  
00001180                           207  STORE_END:
00001180  2E03                     208              MOVE.L     D3, D7
00001182  5204                     209              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001184                           210              ;CLR        D3
00001184                           211              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001184                           212  
00001184                           213              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001184  4281                     214              CLR.L       D1
00001186  2203                     215              MOVE.L      D3, D1   
00001188  103C 0003                216              MOVE.B      #3, D0     
0000118C  4E4F                     217              TRAP        #15
0000118E                           218m             PRINT_MSG   newline
0000119A                           219  
0000119A  4243                     220              CLR         D3
0000119C  6000 FF2E                221              BRA         VALIDATE_INPUT
000011A0                           222  *-----------------------------------------------------------
000011A0                           223  
000011A0                           224  
000011A0                           225  
000011A0                           226  
000011A0                           227  *--------------------------PRINT----------------------------
000011A0                           228  * printing addresses and instructions
000011A0                           229  * Registers:
000011A0                           230  *   D0 = used for tasks and trap #15
000011A0                           231  *   D1 = size of comparison
000011A0                           232  *   D2 = destination for comparisons, holds an address
000011A0                           233  *   D3 = iterator
000011A0                           234  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000011A0                           235  *   A2 = current address (given by user)
000011A0                           236  *-----------------------------------------------------------
000011A0                           237  
000011A0                           238  PRINT_ADDRESS:
000011A0                           239              * reset A1 to beginning of string
000011A0                           240m             CLR_D_REGS
000011B0                           241m             CLR_A_REG D0, A1
000011B4                           242              
000011B4                           243              * move current address to D2
000011B4  240A                     244              MOVE.L    A2, D2
000011B6                           245  
000011B6                           246              * if absolute short, print word
000011B6  223C 00008000            247              MOVE.L    #$8000, D1
000011BC  B481                     248              CMP.L     D1, D2
000011BE  6D00 000E                249              BLT       PRINT_WORD
000011C2                           250              
000011C2                           251              * if absolute long, print long
000011C2  223C FFFF8000            252              MOVE.L    #$FFFF8000, D1
000011C8  B481                     253              CMP.L     D1, D2
000011CA  6C00 0022                254              BGE       PRINT_LONG                 
000011CE                           255  
000011CE                           256  PRINT_WORD:
000011CE                           257m             CLR_D_REGS
000011DE  123C 0001                258              MOVE.B    #1, D1
000011E2  3E0A                     259              MOVE.W    A2, D7
000011E4  4EB9 000014A0            260              JSR       ASCII_TO_HEX
000011EA  6000 0022                261              BRA       FINISH_PRINT
000011EE                           262  
000011EE                           263  PRINT_LONG:
000011EE                           264m             CLR_D_REGS
000011FE  123C 0003                265              MOVE.B    #3, D1
00001202  2E0A                     266              MOVE.L    A2, D7
00001204  4EB9 000014A0            267              JSR       ASCII_TO_HEX
0000120A  6000 0002                268              BRA       FINISH_PRINT
0000120E                           269  
0000120E                           270  FINISH_PRINT:
0000120E                           271              * print out string
0000120E  12BC 0000                272              MOVE.B    #00,(A1)
00001212                           273m             CLR_D_REGS
00001222                           274m             CLR_A_REG D0, A1
00001226  103C 000E                275              MOVE.B    #14, D0
0000122A  4E4F                     276              TRAP      #15
0000122C  4E75                     277              RTS
0000122E                           278  
0000122E                           279  PRINT_INSTRUCTION:    
0000122E                           280              * null terminator
0000122E  12BC 0000                281              MOVE.B    #00,(A1)              
00001232                           282  
00001232                           283              * reset A1 to beginning of string
00001232  4280                     284              CLR.L     D0
00001234                           285m             CLR_A_REG D0, A1
00001238                           286  
00001238                           287              * print out string
00001238  103C 000E                288              MOVE.B    #14, D0
0000123C  4E4F                     289              TRAP      #15
0000123E                           290  
0000123E                           291m             PRINT_MSG newline
0000124A  4E75                     292              RTS
0000124C                           293  *-----------------------------------------------------------
0000124C                           294  
0000124C                           295  
0000124C                           296  *---------------------LOAD ADDRESSES------------------------
0000124C                           297  * stores INITIAL values into registers which is  necessary 
0000124C                           298  * to complete before starting identify opcodes loop
0000124C                           299  *-----------------------------------------------------------
0000124C                           300  LOAD_ADDRESSES: 
0000124C                           301              * reset A1 to beginning of string
0000124C  4280                     302              CLR.L     D0
0000124E                           303m             CLR_A_REG D0, A1
00001252                           304  
00001252                           305              * load start and end registers and print starting address
00001252  2478 106A                306              MOVEA.L startAddr, A2
00001256  2678 106E                307              MOVEA.L endAddr, A3
0000125A  6100 FF44                308              BSR     PRINT_ADDRESS
0000125E                           309  
0000125E  6100 002C                310              BSR     GRAB_NEXT_WORD
00001262  6100 002E                311              BSR     GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
00001266                           312  
00001266                           313              * Push current registers onto the stack (so we can have fresh registers)
00001266  48E7 FF00                314              MOVEM.L D0-D7,-(SP)              ; move the old registers onto the stack
0000126A  6000 0038                315              BRA     FIND_OPCODE
0000126E                           316  *-----------------------------------------------------------
0000126E                           317  
0000126E                           318  
0000126E                           319  *-----------------------------------------------------------
0000126E                           320  * Description:  IDENTIFY OPCODES LOOP
0000126E                           321  * Registers:
0000126E                           322  *   D0 = used for tasks and trap #15
0000126E                           323  *   D1 = size of shifting bits
0000126E                           324  *   D2 = destination for shifts
0000126E                           325  *   D3 = size of opcode
0000126E                           326  *   D4 = <ea> vs Dn (0 = <ea>, 1 = Dn)
0000126E                           327  *   D5 = addressing mode
0000126E                           328  *   D6 = register number
0000126E                           329  *   D7 = holds address (word in length)
0000126E                           330  *   A1 = used for task 14 (printing out strings to screen) and trap #15
0000126E                           331  *   A2 = current address (given by user)
0000126E                           332  *   A3 = ending address (given by user)
0000126E                           333  *-----------------------------------------------------------
0000126E                           334  
0000126E                           335  *-------------------IDENTIFY OPCODES------------------------
0000126E                           336  * evaluates an opcode based on first four bits (aka opTag)
0000126E                           337  * for now only works with one instruction
0000126E                           338  *-----------------------------------------------------------
0000126E                           339  IDENTIFY_OPCODE:
0000126E  61BE                     340              BSR     PRINT_INSTRUCTION
00001270                           341  
00001270                           342              * check to see if we are done (start address >= end address)
00001270  B7CA                     343              CMPA.L  A2, A3
00001272  6C00 02EC                344              BGE     DONE
00001276                           345  
00001276                           346              * print next address
00001276  6100 FF28                347              BSR     PRINT_ADDRESS
0000127A                           348              
0000127A                           349              ;BSR     RESTORE_REGS           need to fix
0000127A  6100 0010                350              BSR     GRAB_NEXT_WORD
0000127E  6100 0012                351              BSR     GRAB_FIRST_FOUR_BITS    ; grabs that opcode's ID (first four bits)
00001282                           352  
00001282  6000 0020                353              BRA     FIND_OPCODE
00001286                           354  
00001286                           355  RESTORE_REGS:
00001286  4CDF 00FF                356              MOVEM.L (SP)+, D0-D7            ; move the old registers onto the stack
0000128A  4E75                     357              RTS
0000128C                           358  
0000128C                           359  *---------Useful Subroutine For Identifying Opcodes---------
0000128C                           360  GRAB_NEXT_WORD:
0000128C                           361              * load current word of bits into D7
0000128C  31DA 107A                362              MOVE.W (A2)+, opcode
00001290  4E75                     363              RTS
00001292                           364  
00001292                           365  GRAB_FIRST_FOUR_BITS:
00001292                           366              * find first four bits of opcode
00001292  3438 107A                367              MOVE.W  opcode, D2
00001296  123C 000C                368              MOVE.B  #12, D1
0000129A  E2AA                     369              LSR.L   D1, D2
0000129C  1002                     370              MOVE.B  D2, D0
0000129E  11C0 107C                371              MOVE.B  D0, opTag
000012A2  4E75                     372              RTS
000012A4                           373  *-----------------------------------------------------------
000012A4                           374  
000012A4                           375  *----------------------FIND OPCODE--------------------------
000012A4                           376  * kind of like a jump table
000012A4                           377  * add in the first four bits of your opcode after four 0's to the list
000012A4                           378  *
000012A4                           379  * for example:
000012A4                           380  *               ADD's first four bits = 1101, so I put
000012A4                           381  *               CMP.B #%00001101, D0
000012A4                           382  *
000012A4                           383  * notice the first four zeroes before the 1101, because we need to compare a whole byte
000012A4                           384  * also note I'm comparing the result with D0, which should hold the first four bits of the opcode
000012A4                           385  * which was retrieved in either GRAB_FIRST_FOUR_BITS. Check registers above IDENTIFY_OPCODE for details
000012A4                           386  * if you're testing, i suggest going into the opcode_test file and replacing my ADD.B   D1, D2 code with
000012A4                           387  * a single line that you need to test, because I havent tested beyond a single command. Feel free to add
000012A4                           388  * anything or edit anything if it makes it simpler or less complicated
000012A4                           389  *-----------------------------------------------------------        
000012A4                           390  FIND_OPCODE:
000012A4  B03C 0004                391              CMP.B   #%00000100, D0 
000012A8  6700 0014                392              BEQ     opc_0100
000012AC                           393  
000012AC  B03C 000D                394              CMP.B   #%00001101, D0
000012B0  6700 0028                395              BEQ     opc_1101
000012B4                           396  
000012B4                           397              * error, bad opcode
000012B4  6000 0002                398              BRA      BAD_OPCODE
000012B8                           399  
000012B8                           400  *-----------------------------------------------------------
000012B8                           401  
000012B8                           402  
000012B8                           403  BAD_OPCODE:
000012B8  4EF9 00001560            404              JMP      DONE
000012BE                           405  
000012BE                           406  
000012BE                           407  *-----------------------------------------------------------
000012BE                           408  * First four bits = 0100
000012BE                           409  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
000012BE                           410  *-----------------------------------------------------------
000012BE                           411  opc_0100:
000012BE                           412  
000012BE                           413              ;Check if the opcode is NOP
000012BE  3438 107A                414              MOVE.W  opcode, D2 ;Copy opcode to D2
000012C2  B47C 4E71                415              CMP.W   #$4E71, D2 ;Check if D2 is equal to NOP (0x4E71 in hex)
000012C6  6700 0004                416              BEQ     opc_nop ;If equal branch to label to handle the opcode NOP
000012CA  4282                     417              CLR.L   D2 ;If instruction is not equal to NOP clear register and continue checks
000012CC                           418  
000012CC                           419  opc_nop:
000012CC  12FC 004E                420              MOVE.B  #'N',(A1)+ ;Put nop into a1 for printing
000012D0  12FC 004F                421              MOVE.B  #'O',(A1)+ 
000012D4  12FC 0050                422              MOVE.B  #'P',(A1)+ 
000012D8  6094                     423              BRA     IDENTIFY_OPCODE
000012DA                           424              
000012DA                           425  *-----------------------------------------------------------
000012DA                           426  
000012DA                           427  
000012DA                           428  
000012DA                           429  
000012DA                           430  *-----------------------------------------------------------
000012DA                           431  * First four bits = 1101
000012DA                           432  * (ADD)
000012DA                           433  *-----------------------------------------------------------
000012DA                           434  opc_1101:
000012DA                           435              * fill in A1 register
000012DA  12FC 0041                436              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000012DE  12FC 0044                437              MOVE.B  #'D',(A1)+
000012E2  12FC 0044                438              MOVE.B  #'D',(A1)+
000012E6  12FC 002E                439              MOVE.B  #'.',(A1)+
000012EA                           440  
000012EA  4EB9 00001314            441              JSR     GET_SIZE  
000012F0  4EB9 0000150E            442              JSR     SIZE_TO_BUFFER
000012F6  4EB9 0000132A            443              JSR     OPERATION_TYPE      ; boolean value (either <ea> -> Dn or Dn -> <ea>)  
000012FC  4EB9 0000135E            444              JSR     GET_EA
00001302                           445  
00001302  12FC 002C                446              MOVE.B  #',',(A1)+
00001306  12FC 0020                447              MOVE.B  #' ',(A1)+
0000130A  4EB9 0000133E            448              JSR     GET_REGISTER_NUMBER
00001310                           449  
00001310  6000 FF5C                450              BRA     IDENTIFY_OPCODE
00001314                           451              
00001314                           452  
00001314                           453  GET_SIZE:
00001314  4282                     454              CLR.L   D2
00001316  3438 107A                455              MOVE.W  opcode ,D2          ; copy current instruction to shift
0000131A                           456              
0000131A                           457              * shift left to get rid of opTag
0000131A  123C 0008                458              MOVE.B  #8, D1
0000131E  E36A                     459              LSL.W   D1, D2
00001320                           460  
00001320                           461              * shift right to get rid of opmode, mode, and register bits
00001320  123C 000E                462              MOVE.B  #14, D1
00001324  E26A                     463              LSR.W   D1, D2
00001326                           464  
00001326                           465              * store in appropriate register
00001326  1602                     466              MOVE.B  D2, D3
00001328                           467              
00001328  4E75                     468              RTS
0000132A                           469  
0000132A                           470  OPERATION_TYPE:
0000132A                           471              * D3 should hold the size of the opcode operation
0000132A  4282                     472              CLR.L   D2
0000132C  3403                     473              MOVE.W  D3, D2
0000132E                           474  
0000132E                           475              * shift left to identify
0000132E  123C 0007                476              MOVE.B  #7, D1
00001332  E36A                     477              LSL.W   D1, D2
00001334                           478              
00001334                           479              * shift left to identify
00001334  123C 000F                480              MOVE.B  #15, D1
00001338  E26A                     481              LSR.W   D1, D2
0000133A                           482  
0000133A                           483              * store in appropriate register
0000133A  1802                     484              MOVE.B  D2, D4
0000133C                           485  
0000133C  4E75                     486              RTS
0000133E                           487  
0000133E                           488  GET_REGISTER_NUMBER:
0000133E                           489              * D3 should hold the size of the opcode operation
0000133E  4282                     490              CLR.L   D2
00001340  3438 107A                491              MOVE.W  opcode, D2  
00001344                           492  
00001344                           493              * shift left to identify
00001344  123C 0004                494              MOVE.B  #4, D1
00001348  E36A                     495              LSL.W   D1, D2
0000134A                           496              
0000134A                           497              * shift right to isolate high register bits
0000134A  123C 000D                498              MOVE.B  #13, D1
0000134E  E26A                     499              LSR.W   D1, D2
00001350                           500  
00001350                           501              * store in appropriate register
00001350  12FC 0044                502              MOVE.B  #'D',(A1)+              * add "D" to buffer
00001354  0602 0030                503              ADD.B   #$30,D2                   * convert data register # to hex digit
00001358  12C2                     504              MOVE.B  D2,(A1)+                * register # to buffer             
0000135A  1C02                     505              MOVE.B  D2, D6
0000135C                           506  
0000135C  4E75                     507              RTS
0000135E                           508  *-----------------------------------------------------------
0000135E                           509  
0000135E                           510  
0000135E                           511  *----------------------------GET_EA------------------------
0000135E                           512  * evaluates the size of an opcode and adds it to A1 to be printed out
0000135E                           513  * prints out the effective address mode and register
0000135E                           514  * Registers:
0000135E                           515  *   D2 = destination for shifts
0000135E                           516  *   D3 = size of opcode
0000135E                           517  *   D5 = addressing mode
0000135E                           518  *-----------------------------------------------------------
0000135E                           519  GET_EA:
0000135E                           520              * move size of opcode to be manipulated
0000135E  4282                     521              CLR.L   D2
00001360  1403                     522              MOVE.B  D3, D2                     
00001362                           523  
00001362                           524              * shift left to identify
00001362  123C 000A                525              MOVE.B  #10, D1
00001366  E36A                     526              LSL.W   D1, D2
00001368                           527              
00001368                           528              * shift right to isolate mode bits for EA 
00001368  123C 000D                529              MOVE.B  #13, D1
0000136C  E26A                     530              LSR.W   D1, D2
0000136E                           531  
0000136E                           532              * store in appropriate register
0000136E  1A02                     533              MOVE.B  D2, D5
00001370                           534              
00001370  6000 0002                535              BRA     GET_EA_MODE
00001374                           536  
00001374                           537  *----------------------------GET_EA_MODE------------------------
00001374                           538  GET_EA_MODE:                              * table holds the different EA modes
00001374                           539  
00001374  BA3C 0000                540              CMP.B   #%00000000, D5        * Direct Data Register
00001378  6700 003A                541              BEQ     ea_000
0000137C                           542  
0000137C  BA3C 0001                543              CMP.B   #%00000001, D5        * Direct Address Register
00001380  6700 004A                544              BEQ     ea_001
00001384                           545  
00001384  BA3C 0002                546              CMP.B   #%00000010, D5        * Indirect Address Register
00001388  6700 005A                547              BEQ     ea_010
0000138C                           548  
0000138C  BA3C 0003                549              CMP.B   #%00000011, D5        * Post Increment
00001390  6700 0072                550              BEQ     ea_011
00001394                           551  
00001394  BA3C 0004                552              CMP.B   #%00000100, D5        * Pre Decrement
00001398  6700 008E                553              BEQ     ea_100
0000139C                           554  
0000139C  BA3C 0005                555              CMP.B   #%00000101, D5        * Not necessary, go to bad ea
000013A0  6700 00AA                556              BEQ     ea_101
000013A4                           557  
000013A4  BA3C 0007                558              CMP.B   #%00000111, D5        * Not necessary, go to bad ea
000013A8  6700 00A6                559              BEQ     ea_110
000013AC                           560  
000013AC  BA3C 0007                561              CMP.B   #%00000111, D5        * Absolute or immediate address
000013B0  6700 00A2                562              BEQ     ea_111
000013B4                           563  
000013B4                           564  *----------------------------Direct Data Register------------------------
000013B4                           565  ea_000:
000013B4  3438 107A                566              MOVE.W      opcode, D2              * move current working word into temp storage
000013B8  12FC 0044                567              MOVE.B      #'D',(A1)+              * add "D" to buffer
000013BC                           568              
000013BC  123C 000D                569              MOVE.B      #13, D1
000013C0  E36A                     570              LSL.W       D1,D2                   * isolate register bits (last 3)
000013C2  E26A                     571              LSR.W       D1,D2              
000013C4  0602 0030                572              ADD.B       #$30,D2                 * convert data register # to ASCII digit
000013C8                           573  
000013C8  12C2                     574              MOVE.B      D2,(A1)+                * register # to buffer                  
000013CA                           575              
000013CA  4E75                     576              RTS                                
000013CC                           577  
000013CC                           578  *----------------------------Direct Address Register------------------------
000013CC                           579  ea_001:
000013CC  3438 107A                580              MOVE.W      opcode, D2              * move current working word into temp storage
000013D0  12FC 0041                581              MOVE.B      #'A',(A1)+              * add "A" to buffer
000013D4                           582              
000013D4  123C 000D                583              MOVE.B      #13, D1
000013D8  E36A                     584              LSL.W       D1,D2                   * isolate register bits (last 3)
000013DA  E26A                     585              LSR.W       D1,D2                  
000013DC  0602 0030                586              ADD.B       #$30,D2                 * convert data register # to ASCII digit
000013E0                           587  
000013E0  12C2                     588              MOVE.B      D2,(A1)+                * register # to buffer               
000013E2                           589                
000013E2  4E75                     590              RTS                            
000013E4                           591  
000013E4                           592  *----------------------------Indirect Address Register------------------------
000013E4                           593  ea_010:
000013E4  3438 107A                594              MOVE.W      opcode, D2              * move current working word into temp storage
000013E8  12FC 0028                595              MOVE.B      #'(',(A1)+              * add "(" to buffer
000013EC  12FC 0041                596              MOVE.B      #'A',(A1)+              * add "A" to buffer
000013F0                           597  
000013F0  123C 000D                598              MOVE.B      #13, D1
000013F4  E36A                     599              LSL.W       D1,D2                   * isolate register bits (last 3)
000013F6  E26A                     600              LSR.W       D1,D2            
000013F8  0602 0030                601              ADD.B       #$30,D2                 * convert data register # to ASCII digit
000013FC  12C2                     602              MOVE.B      D2,(A1)+                * register # to buffer     
000013FE                           603  
000013FE  12FC 0029                604              MOVE.B      #')',(A1)+              * add ")" to buffer
00001402                           605               
00001402  4E75                     606              RTS                            
00001404                           607  
00001404                           608  *----------------------------Post Increment------------------------
00001404                           609  ea_011:
00001404  3438 107A                610              MOVE.W      opcode, D2              * move current working word into temp storage
00001408                           611  
00001408  12FC 0028                612              MOVE.B      #'(',(A1)+              * add "(" to buffer
0000140C  12FC 0041                613              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001410                           614              
00001410  123C 000D                615              MOVE.B      #13, D1
00001414  E36A                     616              LSL.W       D1,D2                   * isolate register bits (last 3)
00001416  E26A                     617              LSR.W       D1,D2                  
00001418  0602 0030                618              ADD.B       #$30,D2                 * convert data register # to ASCII digit
0000141C  12C2                     619              MOVE.B      D2,(A1)+                * register # to buffer     
0000141E                           620  
0000141E  12FC 0029                621              MOVE.B      #')',(A1)+              * add ")" to buffer
00001422  12FC 002B                622              MOVE.B      #'+',(A1)+              * add "+" to buffer
00001426                           623                   
00001426  4E75                     624              RTS                              
00001428                           625  
00001428                           626  *----------------------------Pre Decrement------------------------
00001428                           627  ea_100:
00001428  3438 107A                628              MOVE.W      opcode, D2              * move current working word into temp storage
0000142C                           629  
0000142C  12FC 002D                630              MOVE.B      #'-',(A1)+              * add "-" to buffer
00001430  12FC 0028                631              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001434  12FC 0041                632              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001438                           633              
00001438  123C 000D                634              MOVE.B      #13, D1
0000143C  E36A                     635              LSL.W       D1, D2                   * isolate register bits (last 3)
0000143E  E26A                     636              LSR.W       D1, D2                  
00001440  0602 0030                637              ADD.B       #$30, D2                 * convert data register # to ASCII digit
00001444  12C2                     638              MOVE.B      D2, (A1)+                * register # to buffer     
00001446                           639  
00001446  12FC 0029                640              MOVE.B      #')',(A1)+              * add ")" to buffer
0000144A                           641              
0000144A  4E75                     642              RTS                               
0000144C                           643  
0000144C                           644  *----------------------------Not necessary, go to bad ea------------------------
0000144C                           645  ea_101:
0000144C  6000 004C                646              BRA         INVALID_EA        
00001450                           647  
00001450                           648  
00001450                           649  *----------------------------Not necessary, go to bad ea------------------------
00001450                           650  ea_110:
00001450  6000 0048                651              BRA         INVALID_EA        
00001454                           652  
00001454                           653  
00001454                           654  *----------------------------Absolute or immediate address------------------------
00001454                           655  ea_111:
00001454                           656  
00001454  123C 000D                657              MOVE.B      #13, D1
00001458  E36A                     658              LSL.W       D1,D2                   * isolate register bits (last 3)
0000145A  E26A                     659              LSR.W       D1,D2                   * isolate register bits (last 3)
0000145C  0602 0030                660              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001460                           661  
00001460  BC3C 0000                662              CMP.B       #%0000,D6              * compare to determine if it's a word
00001464  6700 0012                663              BEQ         EA_WORD             * put word address in buffer
00001468                           664  
00001468  BC3C 0001                665              CMP.B       #%0001,D6              * compare to determine if it's a long
0000146C  6700 001A                666              BEQ         EA_LONG             * put long address in buffer
00001470                           667              
00001470  BC3C 0004                668              CMP.B       #%0100,D6
00001474  6700 002A                669              BEQ         PRINT_IMMEDIATE
00001478                           670  
00001478                           671              * NEED TO WORK ON IMMEDIATE
00001478                           672  
00001478                           673  EA_WORD:
00001478  4281                     674              CLR.L       D1
0000147A  123C 0001                675              MOVE.B      #1, D1
0000147E  3E1A                     676              MOVE.W      (A2)+, D7
00001480  6100 001E                677              BSR         ASCII_TO_HEX
00001484  6000 0012                678              BRA         GET_EA_DONE
00001488                           679  
00001488                           680  EA_LONG:
00001488  4281                     681              CLR.L       D1
0000148A  123C 0003                682              MOVE.B      #3, D1
0000148E  2E1A                     683              MOVE.L      (A2)+, D7   
00001490  6100 000E                684              BSR         ASCII_TO_HEX
00001494  6000 0002                685              BRA         GET_EA_DONE
00001498                           686  
00001498                           687  GET_EA_DONE:
00001498  4E75                     688              RTS
0000149A                           689  
0000149A                           690  *------------------Invalid Effective Address----------------
0000149A                           691  INVALID_EA:
0000149A  4EF9 00001560            692              JMP      DONE
000014A0                           693  *-----------------------------------------------------------
000014A0                           694  
000014A0                           695  *----------------------HEX TO ASCII-------------------------
000014A0                           696  * Registers:
000014A0                           697  *   D0 = number of bits to remove
000014A0                           698  *   D1 = iterator (word = 1, long = 3)
000014A0                           699  *   D2 = holds either top four bits of bottom four bits of each byte in D6
000014A0                           700  *   D3 = holds temp data
000014A0                           701  *   D6 = holds part of address (used as temp variable)
000014A0                           702  *   D7 = holds the original address to parse
000014A0                           703  *-----------------------------------------------------------
000014A0                           704  PRINT_IMMEDIATE:
000014A0                           705              
000014A0                           706  ASCII_TO_HEX:
000014A0  1001                     707              MOVE.B   D1, D0             * current number of bytes to remove
000014A2  C1FC 0008                708              MULS.W   #8, D0             * number of bits to remove
000014A6                           709  
000014A6  2C07                     710              MOVE.L   D7, D6             * load original address to parse
000014A8  E0AE                     711              LSR.L    D0, D6             * remove lowest byte(s)
000014AA                           712  
000014AA                           713              * isolate first four bits
000014AA  1406                     714              MOVE.B   D6, D2
000014AC  E80A                     715              LSR.B    #4, D2 
000014AE  6100 0018                716              BSR      NUMBER_OR_LETTER
000014B2                           717  
000014B2                           718              * isolate second set of four bits
000014B2  1406                     719              MOVE.B   D6, D2
000014B4  E90A                     720              LSL.B    #4, D2 
000014B6  E80A                     721              LSR.B    #4, D2 
000014B8  6100 000E                722              BSR      NUMBER_OR_LETTER
000014BC                           723  
000014BC  5301                     724              SUB.B    #1, D1             * iterate
000014BE  B23C 0000                725              CMP.B    #0, D1             * done if equal
000014C2  6D00 0034                726              BLT      ATH_DONE
000014C6                           727  
000014C6  60D8                     728              BRA      ASCII_TO_HEX
000014C8                           729  
000014C8                           730  NUMBER_OR_LETTER:
000014C8  1602                     731              MOVE.B   D2, D3
000014CA  0603 0030                732              ADD.B    #$30, D3           
000014CE  B63C 0039                733              CMP.B    #$39, D3           * is byte in D2 a number?
000014D2  6F00 0010                734              BLE      NUMBER_TO_ASCII
000014D6                           735              
000014D6  1602                     736              MOVE.B   D2, D3
000014D8  0603 0039                737              ADD.B    #$39, D3           
000014DC  B63C 0039                738              CMP.B    #$39, D3           * is byte in D2 a letter?
000014E0  6C00 000A                739              BGE      LETTER_TO_ASCII
000014E4                           740  
000014E4                           741  NUMBER_TO_ASCII:
000014E4  0602 0030                742              ADD.B    #$30, D2           * Get the hex range from '0-9'
000014E8  6000 000A                743              BRA      ADD_TO_BUFFER
000014EC                           744  
000014EC                           745  LETTER_TO_ASCII:
000014EC  0602 0039                746              ADD.B    #$39, D2           * Get the hex range from 'A-F'
000014F0  6000 0002                747              BRA      ADD_TO_BUFFER
000014F4                           748  
000014F4                           749  ADD_TO_BUFFER:
000014F4  12C2                     750              MOVE.B   D2, (A1)+          * add part of address to buffer    
000014F6  4E75                     751              RTS
000014F8                           752  
000014F8                           753  ATH_DONE:
000014F8  12FC 0020                754              MOVE.B  #' ',(A1)+          * add blank space to buffer
000014FC                           755m             CLR_D_REGS
0000150C  4E75                     756              RTS
0000150E                           757  
0000150E                           758  *---------------------SIZE TO BUFFER------------------------
0000150E                           759  * evaluates the size of an opcode and adds it to A1 to be printed out
0000150E                           760  *-----------------------------------------------------------
0000150E                           761  SIZE_TO_BUFFER: 
0000150E  B63C 0000                762              CMP.B   #%0000,D3            
00001512  6700 0016                763              BEQ     BYTE_TO_BUFFER              
00001516                           764  
00001516  B63C 0001                765              CMP.B   #%0001,D3             * is this a word?
0000151A  6700 0016                766              BEQ     WORD_TO_BUFFER
0000151E                           767  
0000151E  B63C 0002                768              CMP.B   #%0010,D3             * is this a long?
00001522  6700 0016                769              BEQ     LONG_TO_BUFFER             
00001526                           770        
00001526  4EF8 12B8                771              JMP     BAD_OPCODE  
0000152A                           772              
0000152A                           773  BYTE_TO_BUFFER:
0000152A  12FC 0042                774              MOVE.B  #'B', (A1)+           * add B to buffer
0000152E  6000 0012                775              BRA     STB_END             
00001532                           776              
00001532                           777  WORD_TO_BUFFER:
00001532  12FC 0057                778              MOVE.B  #'W', (A1)+          * add W to buffer
00001536  6000 000A                779              BRA     STB_END             
0000153A                           780  
0000153A                           781  LONG_TO_BUFFER:
0000153A  12FC 004C                782              MOVE.B  #'L',(A1)+          * add L to buffer
0000153E  6000 0002                783              BRA     STB_END             
00001542                           784  
00001542                           785  STB_END:
00001542  12FC 0020                786              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001546  4E75                     787              RTS                         
00001548                           788  
00001548                           789  *-----------------------EA TO BUFFER------------------------
00001548                           790  * evaluates the size of an opcode and adds it to A1 to be printed out
00001548                           791  * Registers:
00001548                           792  *   D2 = destination for shifts
00001548                           793  *   D3 = size of opcode
00001548                           794  *-----------------------------------------------------------
00001548                           795  EA_TO_BUFFER:
00001548  4282                     796              CLR.L   D2
0000154A  1403                     797              MOVE.B  D3, D2               ; move size of opcode to be manipulated
0000154C  6100 0002                798              BSR     EA_TO_BUFFER_LOOP
00001550                           799  
00001550                           800  EA_TO_BUFFER_LOOP:
00001550  B43C 0000                801              CMP.B   #0, D2
00001554  6700 0008                802              BEQ     EA_TO_BUFFER_END
00001558  4EB8 128C                803              JSR     GRAB_NEXT_WORD
0000155C  5302                     804              SUB.B   #1, D2
0000155E                           805  
0000155E                           806  EA_TO_BUFFER_END:
0000155E  4E75                     807              RTS
00001560                           808  
00001560                           809  
00001560                           810  *-------------------------DONE-------------------------------
00001560                           811  DONE:
00001560  4280                     812              CLR.L     D0
00001562  103C 000E                813              MOVE.B    #14, D0
00001566  43F8 1045                814              LEA.L     doneMsg, A1
0000156A  4E4F                     815              TRAP      #15
0000156C                           816m             CLR_A_REG D0, A1
00001570                           817  
00001570                           818              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       14F4
ASCII_TO_HEX        14A0
ATH_DONE            14F8
BADINPUT            1052
BAD_OPCODE          12B8
BYTE_TO_BUFFER      152A
CHECK_LENGTH        10DC
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      110E
CR                  D
DONE                1560
DONEMSG             1045
EA_000              13B4
EA_001              13CC
EA_010              13E4
EA_011              1404
EA_100              1428
EA_101              144C
EA_110              1450
EA_111              1454
EA_LONG             1488
EA_TO_BUFFER        1548
EA_TO_BUFFER_END    155E
EA_TO_BUFFER_LOOP   1550
EA_WORD             1478
ENDADDR             106E
ENDMSG              1023
FIND_OPCODE         12A4
FINISH_PRINT        120E
GET_EA              135E
GET_EA_DONE         1498
GET_EA_MODE         1374
GET_END_ADDRESS     10B2
GET_INPUT           1086
GET_REGISTER_NUMBER  133E
GET_SIZE            1314
GET_START_ADDRESS   1098
GRAB_FIRST_FOUR_BITS  1292
GRAB_NEXT_WORD      128C
IDENTIFY_OPCODE     126E
INVALID_EA          149A
INVALID_INPUT       10F0
ITERATE             1142
LETTER_TO_ASCII     14EC
LETTER_TO_HEX       1134
LF                  A
LOAD_ADDRESSES      124C
LONG_TO_BUFFER      153A
MAIN                107E
NEWLINE             1062
NUMBER_OR_LETTER    14C8
NUMBER_TO_ASCII     14E4
NUM_TO_HEX          112C
OPCODE              107A
OPC_0100            12BE
OPC_1101            12DA
OPC_NOP             12CC
OPERATION_TYPE      132A
OPOUTPUT            1072
OPTAG               107C
PRINT_ADDRESS       11A0
PRINT_IMMEDIATE     14A0
PRINT_INSTRUCTION   122E
PRINT_LONG          11EE
PRINT_MSG           0
PRINT_WORD          11CE
RESTORE_REGS        1286
SIZE_TO_BUFFER      150E
STARTADDR           106A
STARTMSG            1000
STB_END             1542
STORE_CHAR          113C
STORE_END           1180
STORE_INPUT         1150
STORE_START         1160
USERADDR            1066
VALID               107D
VALIDATE_INPUT      10CC
WORD_TO_BUFFER      1532
