0000107E Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/1/2021 12:50:38 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00007000                            11              ORG     $7000
00007000  C401                      12              AND.B   D1, D2
00007002                            13  
00001000                            14              ORG     $1000
00001000                            15  
00001000  =0000000D                 16  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 17  LF          EQU     $0A 
00001000                            18  
00001000= 50 6C 65 61 73 65 ...     19  startMsg:   DC.B    'Please enter a starting address ', CR, LF, 0
00001023= 50 6C 65 61 73 65 ...     20  endMsg:     DC.B    'Please enter an ending address ', CR, LF, 0
00001045= 65 78 69 74 69 6E ...     21  doneMsg:    DC.B    'exiting...', CR, LF, 0
00001052= 49 6E 76 61 6C 69 ...     22  badInput:   DC.B    'Invalid Input', CR, LF, 0
00001062= 0D 0A 00                  23  newline:    DC.B    '', CR, LF, 0
00001065                            24  
00001066                            25  userAddr:   DS.L    1
0000106A                            26  startAddr:  DS.L    1
0000106E                            27  endAddr:    DS.L    1
00001072                            28  
00001072                            29  opOutput:   DS.L    2
0000107A                            30  
0000107A                            31  opcode:     DS.W    1   
0000107C                            32  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
0000107D                            33  valid:      DS.B    1
0000107E                            34  
0000107E                            35  
0000107E                            36  
0000107E                            37  *-----------------------------------------------------------
0000107E                            38  * Macros:
0000107E                            39  *-----------------------------------------------------------
0000107E                            40  
0000107E                            41  PRINT_MSG:  MACRO 
0000107E                            42              CLR.L   D0
0000107E                            43              LEA     \1, A1      ; \1 acts as a parameter
0000107E                            44              MOVE.B  #14, D0     
0000107E                            45              TRAP    #15
0000107E                            46              ENDM
0000107E                            47  
0000107E                            48  CLR_D_REGS: MACRO
0000107E                            49              CLR.L   D0
0000107E                            50              CLR.L   D1
0000107E                            51              CLR.L   D2
0000107E                            52              CLR.L   D3
0000107E                            53              CLR.L   D4
0000107E                            54              CLR.L   D5
0000107E                            55              CLR.L   D6
0000107E                            56              CLR.L   D7
0000107E                            57              ENDM
0000107E                            58  
0000107E                            59  CLR_A_REG:  MACRO
0000107E                            60              CLR.L   \1
0000107E                            61              MOVE.L  \1, \2
0000107E                            62              ENDM              
0000107E                            63  
0000107E                            64  *-----------------------------------------------------------
0000107E                            65  * Description:  Get User Input
0000107E                            66  *-----------------------------------------------------------
0000107E                            67  
0000107E                            68  *-------------------------MAIN------------------------------
0000107E                            69  MAIN:
0000107E  6100 0006                 70              BSR     GET_INPUT
00001082  6000 011C                 71              BRA     LOAD_ADDRESSES
00001086                            72  *-----------------------------------------------------------
00001086                            73  
00001086                            74  *-------------------------Get Input-------------------------
00001086                            75  GET_INPUT:
00001086  B87C 0000                 76              CMP      #0, D4
0000108A  6700 000C                 77              BEQ      GET_START_ADDRESS
0000108E                            78                 
0000108E  21C6 106A                 79              MOVE.L   D6, startAddr
00001092  21C7 106E                 80              MOVE.L   D7, endAddr
00001096  4E75                      81              RTS 
00001098                            82  *-----------------------------------------------------------
00001098                            83  
00001098                            84  *----------------------Get Starting Address----------------------
00001098                            85  GET_START_ADDRESS:
00001098  4280                      86              CLR.L   D0
0000109A  43F8 1000                 87              LEA.L   startMsg, A1      
0000109E  103C 000E                 88              MOVE.B  #14, D0     
000010A2  4E4F                      89              TRAP    #15
000010A4                            90  
000010A4  43F8 1066                 91              LEA.L   userAddr, A1
000010A8  103C 0002                 92              MOVE.B  #2, D0
000010AC  4E4F                      93              TRAP    #15
000010AE                            94              ;MOVE.B  D1, startSize
000010AE  6000 001C                 95              BRA     VALIDATE_INPUT
000010B2                            96  *-----------------------------------------------------------
000010B2                            97  
000010B2                            98  *----------------------Get Ending Address----------------------
000010B2                            99  GET_END_ADDRESS:
000010B2  4280                     100              CLR.L   D0
000010B4  43F8 1023                101              LEA.L   endMsg, A1      
000010B8  103C 000E                102              MOVE.B  #14, D0     
000010BC  4E4F                     103              TRAP    #15
000010BE                           104  
000010BE  43F8 1066                105              LEA.L   userAddr, A1
000010C2  103C 0002                106              MOVE.B  #2, D0
000010C6  4E4F                     107              TRAP    #15
000010C8                           108              ;MOVE.B  D1, endSize
000010C8  6000 0012                109              BRA     CHECK_LENGTH
000010CC                           110  *-----------------------------------------------------------
000010CC                           111  
000010CC                           112  
000010CC                           113  
000010CC                           114  
000010CC                           115  
000010CC                           116  *-----------------------------------------------------------
000010CC                           117  * Description:  Validate User Input
000010CC                           118  * Constraints:  
000010CC                           119  *   User input must be:
000010CC                           120  *   Length 4 or Length 8
000010CC                           121  *   ASCII character 0-9 or A-F
000010CC                           122  *   Starting and ending address with value < $00FFFFFF 
000010CC                           123  *   Starting address is before ending address
000010CC                           124  *-----------------------------------------------------------
000010CC                           125  
000010CC                           126  *----------------------VALIDATE INPUT---------------------------      
000010CC                           127  
000010CC                           128  VALIDATE_INPUT:        
000010CC  B83C 0000                129              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
000010D0  6700 000A                130              BEQ        CHECK_LENGTH         ; if equal, parse START address 
000010D4  B83C 0001                131              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
000010D8  67D8                     132              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
000010DA  60AA                     133              BRA        GET_INPUT            ; done parsing, D4 = 2
000010DC                           134  
000010DC                           135  CHECK_LENGTH:
000010DC  B23C 0004                136              CMP.B      #4, D1               ; for task 2, length of string is in D1                
000010E0  6700 002C                137              BEQ        CONVERT_TO_HEX 
000010E4  B23C 0008                138              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
000010E8  6700 0024                139              BEQ        CONVERT_TO_HEX
000010EC  6000 0002                140              BRA        INVALID_INPUT
000010F0                           141  
000010F0                           142  INVALID_INPUT:  
000010F0  4283                     143              CLR.L      D3
000010F2                           144m             PRINT_MSG  badInput
000010FE  B83C 0000                145              CMP.B      #0, D4 
00001102  6794                     146              BEQ        GET_START_ADDRESS  
00001104  B83C 0001                147              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001108  67A8                     148              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
0000110A  6000 FF72                149              BRA        MAIN
0000110E                           150  *-----------------------------------------------------------
0000110E                           151  
0000110E                           152  *----------------CONVERT FROM ASCII TO HEX------------------
0000110E                           153  CONVERT_TO_HEX:
0000110E  0C11 0030                154              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001112  6DDC                     155              BLT        INVALID_INPUT        
00001114                           156  
00001114  0C11 003A                157              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001118  6D00 0012                158              BLT        NUM_TO_HEX      
0000111C                           159  
0000111C  0C11 0041                160              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001120  6DCE                     161              BLT        INVALID_INPUT             
00001122                           162  
00001122  0C11 0047                163              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001126  6D00 000C                164              BLT        LETTER_TO_HEX
0000112A                           165  
0000112A  60C4                     166              BRA        INVALID_INPUT    
0000112C                           167  
0000112C                           168  NUM_TO_HEX:      
0000112C  0411 0030                169              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001130  6000 000A                170              BRA        STORE_CHAR   
00001134                           171  
00001134                           172  LETTER_TO_HEX:     
00001134  0411 0037                173              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001138  6000 0002                174              BRA        STORE_CHAR
0000113C                           175  
0000113C                           176  STORE_CHAR:       
0000113C  D619                     177              ADD.B     (A1)+, D3            ; keep hex stored in D3           
0000113E  6000 0002                178              BRA        ITERATE                 
00001142                           179  
00001142                           180  ITERATE:
00001142  5301                     181              SUB.B      #$1, D1
00001144  B23C 0000                182              CMP.B      #0, D1
00001148  6700 0006                183              BEQ        STORE_INPUT
0000114C                           184  
0000114C  E98B                     185              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000114E  60BE                     186              BRA        CONVERT_TO_HEX
00001150                           187  
00001150                           188  STORE_INPUT:
00001150  B83C 0000                189              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
00001154  6700 000A                190              BEQ        STORE_START          ; if equal, parse START address 
00001158                           191              
00001158  B83C 0001                192              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
0000115C  6700 0022                193              BEQ        STORE_END         
00001160                           194  
00001160                           195  STORE_START:
00001160  2C03                     196              MOVE.L     D3, D6
00001162  5204                     197              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001164                           198              ;CLR        D3
00001164                           199              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001164                           200  
00001164                           201              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001164  4281                     202              CLR.L       D1
00001166  2203                     203              MOVE.L      D3, D1   
00001168  103C 0003                204              MOVE.B      #3, D0     
0000116C  4E4F                     205              TRAP        #15
0000116E                           206m             PRINT_MSG   newline
0000117A                           207              
0000117A  4243                     208              CLR         D3
0000117C  6000 FF4E                209              BRA         VALIDATE_INPUT
00001180                           210  
00001180                           211  STORE_END:
00001180  2E03                     212              MOVE.L     D3, D7
00001182  5204                     213              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001184                           214              ;CLR        D3
00001184                           215              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001184                           216  
00001184                           217              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001184  4281                     218              CLR.L       D1
00001186  2203                     219              MOVE.L      D3, D1   
00001188  103C 0003                220              MOVE.B      #3, D0     
0000118C  4E4F                     221              TRAP        #15
0000118E                           222m             PRINT_MSG   newline
0000119A                           223  
0000119A  4243                     224              CLR         D3
0000119C  6000 FF2E                225              BRA         VALIDATE_INPUT
000011A0                           226  *-----------------------------------------------------------
000011A0                           227  
000011A0                           228  
000011A0                           229  
000011A0                           230  
000011A0                           231  
000011A0                           232  *-----------------------------------------------------------
000011A0                           233  * Description:  IDENTIFY OPCODES LOOP
000011A0                           234  * Registers:
000011A0                           235  *   D0 = used for tasks and trap #15
000011A0                           236  *   D1 = size of shifting bits
000011A0                           237  *   D2 = destination for shifts
000011A0                           238  *   D3 = size of opcode
000011A0                           239  *   D4 = <ea> vs Dn (0 = <ea>, 1 = Dn)
000011A0                           240  *   D5 = addressing mode
000011A0                           241  *   D6 = register number
000011A0                           242  *   D7 = holds addresses (word in length)
000011A0                           243  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000011A0                           244  *   A2 = current address (given by user)
000011A0                           245  *   A3 = ending address (given by user)
000011A0                           246  *-----------------------------------------------------------
000011A0                           247  
000011A0                           248  
000011A0                           249  *---------------------LOAD ADDRESSES------------------------
000011A0                           250  * stores initial values into registers
000011A0                           251  *-----------------------------------------------------------
000011A0                           252  LOAD_ADDRESSES: 
000011A0                           253              * Clear all registers and output register
000011A0                           254m             CLR_D_REGS
000011B0                           255m             CLR_A_REG       D0, A1
000011B4                           256  
000011B4                           257  
000011B4                           258              * load start and end registers
000011B4  2478 106A                259              MOVEA.L startAddr, A2
000011B8  2678 106E                260              MOVEA.L endAddr, A3
000011BC                           261  
000011BC  6100 0050                262              BSR     GRAB_NEXT_WORD
000011C0  31C7 107A                263              MOVE.W  D7, opcode
000011C4                           264  
000011C4  6100 004C                265              BSR     GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
000011C8                           266  
000011C8                           267              * Push current registers onto the stack (so we can have fresh registers)
000011C8  48E7 FF00                268              MOVEM.L D0-D7,-(SP)              ; move the old registers onto the stack
000011CC  6000 0056                269              BRA     FIND_OPCODE
000011D0                           270  
000011D0                           271  *-------------------IDENTIFY OPCODES------------------------
000011D0                           272  * evaluates an opcode based on first four bits (aka opTag)
000011D0                           273  *-----------------------------------------------------------
000011D0                           274  IDENTIFY_OPCODE:
000011D0  B7CA                     275              CMPA.L  A2, A3
000011D2  6C00 02C8                276              BGE     DONE
000011D6                           277  
000011D6                           278              ;BSR     RESTORE_REGS           need to fix
000011D6  6000 0014                279              BRA     PRINT_INSTRUCTION
000011DA                           280  
000011DA  6100 0032                281              BSR     GRAB_NEXT_WORD
000011DE  6100 0032                282              BSR     GRAB_FIRST_FOUR_BITS    ; grabs that opcode's ID (first four bits)
000011E2  6000 0040                283              BRA     FIND_OPCODE
000011E6                           284  
000011E6                           285  RESTORE_REGS:
000011E6  4CDF 00FF                286              MOVEM.L (SP)+, D0-D7            ; move the old registers onto the stack
000011EA  4E75                     287              RTS
000011EC                           288  
000011EC                           289  PRINT_INSTRUCTION:    
000011EC                           290              * null terminator
000011EC  12BC 0000                291              MOVE.B    #00,(A1)              
000011F0                           292  
000011F0                           293              * reset A1 to beginning of string
000011F0  4280                     294              CLR.L     D0
000011F2                           295m             CLR_A_REG D0, A1
000011F6                           296  
000011F6                           297              * print out string
000011F6  103C 000E                298              MOVE.B    #14, D0
000011FA  4E4F                     299              TRAP      #15
000011FC                           300  
000011FC                           301m             PRINT_MSG newline
00001208                           302  
00001208                           303  BAD_OPCODE:
00001208  4EF9 0000149C            304              JMP      DONE
0000120E                           305  
0000120E                           306  GRAB_NEXT_WORD:
0000120E                           307              * load current word of bits into D7
0000120E  3E1A                     308              MOVE.W (A2)+, D7
00001210                           309  
00001210                           310              * load into A1 register for printing
00001210  4E75                     311              RTS
00001212                           312  
00001212                           313  GRAB_FIRST_FOUR_BITS:
00001212                           314              * find first four bits of opcode
00001212  3438 107A                315              MOVE.W  opcode, D2
00001216  123C 000C                316              MOVE.B  #12, D1
0000121A  E2AA                     317              LSR.L   D1, D2
0000121C  1002                     318              MOVE.B  D2, D0
0000121E  11C0 107C                319              MOVE.B  D0, opTag
00001222  4E75                     320              RTS
00001224                           321  
00001224                           322  
00001224                           323  
00001224                           324  *----------------------FIND OPCODE--------------------------
00001224                           325  FIND_OPCODE:
00001224  B03C 0004                326              CMP.B   #%0000100, D0 
00001228  6700 0014                327              BEQ     opc_0100
0000122C                           328              
0000122C  B03C 000C                329              CMP.B   #%00001100, D0
00001230  6700 000C                330              BEQ     opc_1100
00001234                           331  
00001234  B03C 000D                332              CMP.B   #%00001101, D0
00001238  6700 006E                333              BEQ     opc_1101
0000123C                           334  
0000123C                           335              * error, bad opcode
0000123C  60CA                     336              BRA      BAD_OPCODE
0000123E                           337  
0000123E                           338  *-----------------------------------------------------------
0000123E                           339  
0000123E                           340  
0000123E                           341  
0000123E                           342  
0000123E                           343  *-----------------------------------------------------------
0000123E                           344  * First four bits = 0100
0000123E                           345  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
0000123E                           346  *-----------------------------------------------------------
0000123E                           347  opc_0100:
0000123E                           348              
0000123E                           349  *-----------------------------------------------------------
0000123E                           350  
0000123E                           351  
0000123E                           352  *-----------------------------------------------------------
0000123E                           353  * First four bits = 1100
0000123E                           354  * (AND, MULS) 
0000123E                           355  *-----------------------------------------------------------
0000123E                           356  opc_1100:
0000123E                           357              ; determine which optag it should be, use bits 6-8
0000123E                           358                  ; bits = 7 (111), then it's MULS
0000123E  6000 0002                359              BRA     OPC_1100_AND ; just do this for now
00001242                           360  
00001242                           361  ;===========================================================
00001242                           362  OPC_1100_AND:   ; AND opcode subroutine
00001242                           363  
00001242                           364              ;-----------------------------
00001242                           365              ; fill A1 with the opcode name
00001242  12FC 0041                366              MOVE.B  #'A',(A1)+
00001246  12FC 004E                367              MOVE.B  #'N',(A1)+
0000124A  12FC 0044                368              MOVE.B  #'D',(A1)+
0000124E  12FC 002E                369              MOVE.B  #'.',(A1)+
00001252                           370              
00001252                           371              ;-----------------------------
00001252                           372              ; get the register
00001252                           373                  ; do a CMP to see if the register's been set
00001252  4282                     374              CLR.L   D2
00001254  3438 107A                375              MOVE.W  opcode,D2
00001258                           376              
00001258                           377              ; shift the optag out
00001258  123C 0005                378              MOVE.B  #5,D1
0000125C  E36A                     379              LSL.W   D1,D2
0000125E                           380              
0000125E                           381              ; isolate the register
0000125E  123C 000E                382              MOVE.B  #14,D1
00001262  E26A                     383              LSR.W   D1,D2
00001264                           384              
00001264                           385              ; store the register
00001264  2C01                     386              MOVE.L  D1,D6
00001266                           387              
00001266                           388  
00001266                           389              ; get the size and the operation type
00001266  4EB9 000012E2            390              JSR     GET_SIZE
0000126C  4EB9 0000144A            391              JSR     SIZE_TO_BUFFER
00001272                           392              
00001272                           393              ; TESTING, currently assuming register is the source
00001272  12FC 0044                394              MOVE.B  #'D',(A1)+
00001276  0601 0030                395              ADD.B   #$30,D1     ; convert register number to hex
0000127A  12C1                     396              MOVE.B  D1,(A1)+    ; push register number
0000127C  12FC 002C                397              MOVE.B  #',',(A1)+
00001280  12FC 0020                398              MOVE.B  #' ',(A1)+
00001284                           399              
00001284  4EB9 000012F8            400              JSR     OPERATION_TYPE
0000128A  4EB9 0000130C            401              JSR     GET_REGISTER_NUMBER
00001290                           402  
00001290  6000 FF3E                403              BRA     IDENTIFY_OPCODE
00001294                           404  
00001294                           405  ;===========================================================
00001294                           406  OPC_1100_MULS:  ; MULS opcode subroutine
00001294                           407  
00001294                           408              ; load the command name into the output
00001294  12FC 004D                409              MOVE.B  #'M',(A1)+
00001298  12FC 0055                410              MOVE.B  #'U',(A1)+
0000129C  12FC 004C                411              MOVE.B  #'L',(A1)+
000012A0  12FC 0053                412              MOVE.B  #'S',(A1)+
000012A4  12FC 002E                413              MOVE.B  #'.',(A1)+
000012A8                           414              
000012A8                           415  *-----------------------------------------------------------
000012A8                           416  
000012A8                           417  
000012A8                           418  *-----------------------------------------------------------
000012A8                           419  * First four bits = 1101
000012A8                           420  * (ADD)
000012A8                           421  *-----------------------------------------------------------
000012A8                           422  opc_1101:
000012A8                           423              * fill in A1 register
000012A8  12FC 0041                424              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000012AC  12FC 0044                425              MOVE.B  #'D',(A1)+
000012B0  12FC 0044                426              MOVE.B  #'D',(A1)+
000012B4  12FC 002E                427              MOVE.B  #'.',(A1)+
000012B8                           428  
000012B8  4EB9 000012E2            429              JSR     GET_SIZE  
000012BE  4EB9 0000144A            430              JSR     SIZE_TO_BUFFER
000012C4  4EB9 000012F8            431              JSR     OPERATION_TYPE      ; boolean value (either <ea> -> Dn or Dn -> <ea>)  
000012CA  4EB9 0000132C            432              JSR     GET_EA
000012D0                           433  
000012D0  12FC 002C                434              MOVE.B  #',',(A1)+
000012D4  12FC 0020                435              MOVE.B  #' ',(A1)+
000012D8  4EB9 0000130C            436              JSR     GET_REGISTER_NUMBER
000012DE                           437  
000012DE  6000 FEF0                438              BRA     IDENTIFY_OPCODE
000012E2                           439              
000012E2                           440  
000012E2                           441  GET_SIZE:
000012E2  4282                     442              CLR.L   D2
000012E4  3438 107A                443              MOVE.W  opcode ,D2          ; copy current instruction to shift
000012E8                           444              
000012E8                           445              * shift left to get rid of opTag
000012E8  123C 0008                446              MOVE.B  #8, D1
000012EC  E36A                     447              LSL.W   D1, D2
000012EE                           448  
000012EE                           449              * shift right to get rid of opmode, mode, and register bits
000012EE  123C 000E                450              MOVE.B  #14, D1
000012F2  E26A                     451              LSR.W   D1, D2
000012F4                           452  
000012F4                           453              * store in appropriate register
000012F4                           454              ;ADD.B   #$30,D2                   * convert data register # to hex digit
000012F4  1602                     455              MOVE.B  D2, D3
000012F6                           456              
000012F6  4E75                     457              RTS
000012F8                           458  
000012F8                           459  OPERATION_TYPE:
000012F8                           460              * D3 should hold the size of the opcode operation
000012F8  4282                     461              CLR.L   D2
000012FA  3403                     462              MOVE.W  D3, D2  
000012FC                           463  
000012FC                           464              * shift left to identify
000012FC  123C 0007                465              MOVE.B  #7, D1
00001300  E36A                     466              LSL.W   D1, D2
00001302                           467              
00001302                           468              * shift left to identify
00001302  123C 000F                469              MOVE.B  #15, D1
00001306  E26A                     470              LSR.W   D1, D2
00001308                           471  
00001308                           472              * store in appropriate register
00001308                           473              ;ADD.B   #$30,D2                   * convert data register # to hex digit
00001308                           474              ;MOVE.B  D2,(A1)+                  * register # to buffer    
00001308  1802                     475              MOVE.B  D2, D4
0000130A                           476  
0000130A  4E75                     477              RTS
0000130C                           478  
0000130C                           479  GET_REGISTER_NUMBER:
0000130C                           480              * D3 should hold the size of the opcode operation
0000130C  4282                     481              CLR.L   D2
0000130E  3438 107A                482              MOVE.W  opcode, D2  
00001312                           483  
00001312                           484              * shift left to identify
00001312  123C 0004                485              MOVE.B  #4, D1
00001316  E36A                     486              LSL.W   D1, D2
00001318                           487              
00001318                           488              * shift right to isolate high register bits
00001318  123C 000D                489              MOVE.B  #13, D1
0000131C  E26A                     490              LSR.W   D1, D2
0000131E                           491  
0000131E                           492              * store in appropriate register
0000131E  12FC 0044                493              MOVE.B  #'D',(A1)+              * add "D" to buffer
00001322  0602 0030                494              ADD.B   #$30,D2                   * convert data register # to hex digit
00001326  12C2                     495              MOVE.B  D2,(A1)+                * register # to buffer             
00001328  1C02                     496              MOVE.B  D2, D6
0000132A                           497  
0000132A  4E75                     498              RTS
0000132C                           499  *-----------------------------------------------------------
0000132C                           500  
0000132C                           501  
0000132C                           502  *----------------------------GET_EA------------------------
0000132C                           503  * evaluates the size of an opcode and adds it to A1 to be printed out
0000132C                           504  * prints out the effective address mode and register
0000132C                           505  * Registers:
0000132C                           506  *   D2 = destination for shifts
0000132C                           507  *   D3 = size of opcode
0000132C                           508  *   D5 = addressing mode
0000132C                           509  *-----------------------------------------------------------
0000132C                           510  GET_EA:
0000132C                           511              * move size of opcode to be manipulated
0000132C  4282                     512              CLR.L   D2
0000132E  1403                     513              MOVE.B  D3, D2                     
00001330                           514  
00001330                           515              * shift left to identify
00001330  123C 000A                516              MOVE.B  #10, D1
00001334  E36A                     517              LSL.W   D1, D2
00001336                           518              
00001336                           519              * shift right to isolate mode bits for EA 
00001336  123C 000D                520              MOVE.B  #13, D1
0000133A  E26A                     521              LSR.W   D1, D2
0000133C                           522  
0000133C                           523              * store in appropriate register
0000133C  1A02                     524              MOVE.B  D2, D5
0000133E                           525              
0000133E  6000 0002                526              BRA     GET_EA_MODE
00001342                           527  
00001342                           528  *----------------------------GET_EA_MODE------------------------
00001342                           529  GET_EA_MODE:                              * table holds the different EA modes
00001342                           530  
00001342  BA3C 0000                531              CMP.B   #%00000000, D5        * Direct Data Register
00001346  6700 003A                532              BEQ     ea_000
0000134A                           533  
0000134A  BA3C 0001                534              CMP.B   #%00000001, D5        * Direct Address Register
0000134E  6700 004A                535              BEQ     ea_001
00001352                           536  
00001352  BA3C 0002                537              CMP.B   #%00000010, D5        * Indirect Address Register
00001356  6700 005A                538              BEQ     ea_010
0000135A                           539  
0000135A  BA3C 0003                540              CMP.B   #%00000011, D5        * Post Increment
0000135E  6700 0072                541              BEQ     ea_011
00001362                           542  
00001362  BA3C 0004                543              CMP.B   #%00000100, D5        * Pre Decrement
00001366  6700 008E                544              BEQ     ea_100
0000136A                           545  
0000136A  BA3C 0005                546              CMP.B   #%00000101, D5        * Not necessary, go to bad ea
0000136E  6700 00AA                547              BEQ     ea_101
00001372                           548  
00001372  BA3C 0007                549              CMP.B   #%00000111, D5        * Not necessary, go to bad ea
00001376  6700 00A8                550              BEQ     ea_110
0000137A                           551  
0000137A  BA3C 0007                552              CMP.B   #%00000111, D5        * Absolute or immediate address
0000137E  6700 00A6                553              BEQ     ea_111
00001382                           554  
00001382                           555  *----------------------------Direct Data Register------------------------
00001382                           556  ea_000:
00001382  3438 107A                557              MOVE.W      opcode, D2              * move current working word into temp storage
00001386  12FC 0044                558              MOVE.B      #'D',(A1)+              * add "D" to buffer
0000138A                           559              
0000138A  123C 000D                560              MOVE.B      #13, D1
0000138E  E36A                     561              LSL.W       D1,D2                   * isolate register bits (last 3)
00001390  E26A                     562              LSR.W       D1,D2                   * isolate register bits (last 3)
00001392  0602 0030                563              ADD.B       #$30,D2                 * convert data register # to hex digit
00001396                           564  
00001396  12C2                     565              MOVE.B      D2,(A1)+                * register # to buffer                  
00001398                           566              
00001398  4E75                     567              RTS                                 * Return
0000139A                           568  
0000139A                           569  *----------------------------Direct Address Register------------------------
0000139A                           570  ea_001:
0000139A  3438 107A                571              MOVE.W      opcode, D2              * move current working word into temp storage
0000139E  12FC 0041                572              MOVE.B      #'A',(A1)+              * add "A" to buffer
000013A2                           573              
000013A2  123C 000D                574              MOVE.B      #13, D1
000013A6  E36A                     575              LSL.W       D1,D2                   * isolate register bits (last 3)
000013A8  E26A                     576              LSR.W       D1,D2                   * isolate register bits (last 3)
000013AA  0602 0030                577              ADD.B       #$30,D2                 * convert data register # to hex digit
000013AE                           578  
000013AE  12C2                     579              MOVE.B      D2,(A1)+                * register # to buffer               
000013B0                           580                
000013B0  4E75                     581              RTS                                 * Return
000013B2                           582  
000013B2                           583  *----------------------------Indirect Address Register------------------------
000013B2                           584  ea_010:
000013B2  3438 107A                585              MOVE.W      opcode, D2              * move current working word into temp storage
000013B6  12FC 0028                586              MOVE.B      #'(',(A1)+              * add "(" to buffer
000013BA  12FC 0041                587              MOVE.B      #'A',(A1)+              * add "A" to buffer
000013BE                           588  
000013BE  123C 000D                589              MOVE.B      #13, D1
000013C2  E36A                     590              LSL.W       D1,D2                   * isolate register bits (last 3)
000013C4  E26A                     591              LSR.W       D1,D2                   * isolate register bits (last 3)
000013C6  0602 0030                592              ADD.B       #$30,D2                 * convert data register # to hex digit
000013CA  12C2                     593              MOVE.B      D2,(A1)+                * register # to buffer     
000013CC                           594  
000013CC  12FC 0029                595              MOVE.B      #')',(A1)+              * add ")" to buffer
000013D0                           596               
000013D0  4E75                     597              RTS                                 * Return
000013D2                           598  
000013D2                           599  *----------------------------Post Increment------------------------
000013D2                           600  ea_011:
000013D2  3438 107A                601              MOVE.W      opcode, D2              * move current working word into temp storage
000013D6                           602  
000013D6  12FC 0028                603              MOVE.B      #'(',(A1)+              * add "D" to buffer
000013DA  12FC 0041                604              MOVE.B      #'A',(A1)+              * add "D" to buffer
000013DE                           605              
000013DE  123C 000D                606              MOVE.B      #13, D1
000013E2  E36A                     607              LSL.W       D1,D2                   * isolate register bits (last 3)
000013E4  E26A                     608              LSR.W       D1,D2                   * isolate register bits (last 3)
000013E6  0602 0030                609              ADD.B       #$30,D2                 * convert data register # to hex digit
000013EA  12C2                     610              MOVE.B      D2,(A1)+                * register # to buffer     
000013EC                           611  
000013EC  12FC 0029                612              MOVE.B      #')',(A1)+              * add "D" to buffer
000013F0  12FC 002B                613              MOVE.B      #'+',(A1)+              * add "D" to buffer
000013F4                           614                   
000013F4  4E75                     615              RTS                                 * Return
000013F6                           616  
000013F6                           617  *----------------------------Pre Decrement------------------------
000013F6                           618  ea_100:
000013F6  3438 107A                619              MOVE.W      opcode, D2              * move current working word into temp storage
000013FA                           620  
000013FA  12FC 002D                621              MOVE.B      #'-',(A1)+              * add "D" to buffer
000013FE  12FC 0028                622              MOVE.B      #'(',(A1)+              * add "D" to buffer
00001402  12FC 0041                623              MOVE.B      #'A',(A1)+              * add "D" to buffer
00001406                           624              
00001406  123C 000D                625              MOVE.B      #13, D1
0000140A  E36A                     626              LSL.W       D1,D2                   * isolate register bits (last 3)
0000140C  E26A                     627              LSR.W       D1,D2                   * isolate register bits (last 3)
0000140E  0602 0030                628              ADD.B       #$30,D2                 * convert data register # to hex digit
00001412  12C2                     629              MOVE.B      D2,(A1)+                * register # to buffer     
00001414                           630  
00001414  12FC 0029                631              MOVE.B      #')',(A1)+              * add "D" to buffer
00001418                           632              
00001418  4E75                     633              RTS                                     * Return
0000141A                           634  
0000141A                           635  *----------------------------Not necessary, go to bad ea------------------------
0000141A                           636  ea_101:
0000141A  4EF9 00001444            637              JMP         INVALID_EA             * set bad instruction flag
00001420                           638  
00001420                           639  
00001420                           640  *----------------------------Not necessary, go to bad ea------------------------
00001420                           641  ea_110:
00001420  4EF9 00001444            642              JMP         INVALID_EA             * set bad instruction flag
00001426                           643  
00001426                           644  
00001426                           645  
00001426                           646  *----------------------------Absolute or immediate address------------------------
00001426                           647  ea_111:
00001426  4EB8 12E2                648              JSR      GET_SIZE            * Get Register bits
0000142A                           649  
0000142A  BC3C 0000                650              CMP.B    #$0,D6              * compare to determine if it's a word
0000142E  6700 0054                651              BEQ      EA_TO_BUFFER        * put word address in buffer
00001432                           652  
00001432  BC3C 0001                653              CMP.B    #$1,D6              * compare to determine if it's a long
00001436  6700 004C                654              BEQ      EA_TO_BUFFER        * put long address in buffer
0000143A                           655              
0000143A  BC3C 0002                656              CMP.B    #$2,D6
0000143E  6700 0044                657              BEQ      EA_TO_BUFFER
00001442                           658  
00001442                           659              * NEED TO WORK ON IMMEDIATE
00001442                           660             
00001442  4E75                     661              RTS
00001444                           662  
00001444                           663  *----------------------------Invalid Effective Address------------------------
00001444                           664  INVALID_EA:
00001444  4EF9 0000149C            665              JMP      DONE
0000144A                           666  *-----------------------------------------------------------
0000144A                           667  
0000144A                           668  
0000144A                           669  *---------------------SIZE TO BUFFER------------------------
0000144A                           670  * evaluates the size of an opcode and adds it to A1 to be printed out
0000144A                           671  *-----------------------------------------------------------
0000144A                           672  SIZE_TO_BUFFER: 
0000144A  B63C 0000                673              CMP.B   #%0000,D3            
0000144E  6700 0016                674              BEQ     BYTE_TO_BUFFER              
00001452                           675  
00001452  B63C 0001                676              CMP.B   #%0001,D3             * is this a word?
00001456  6700 0016                677              BEQ     WORD_TO_BUFFER
0000145A                           678  
0000145A  B63C 0002                679              CMP.B   #%0010,D3             * is this a long?
0000145E  6700 0016                680              BEQ     LONG_TO_BUFFER             
00001462                           681        
00001462                           682              
00001462  4EF8 1208                683              JMP     BAD_OPCODE  
00001466                           684              
00001466                           685  BYTE_TO_BUFFER:
00001466  12FC 0042                686              MOVE.B  #'B', (A1)+           * add B to buffer
0000146A  6000 0012                687              BRA     STB_END             
0000146E                           688              
0000146E                           689  WORD_TO_BUFFER:
0000146E  12FC 0057                690              MOVE.B  #'W', (A1)+          * add W to buffer
00001472  6000 000A                691              BRA     STB_END             
00001476                           692  
00001476                           693  LONG_TO_BUFFER:
00001476  12FC 004C                694              MOVE.B  #'L',(A1)+          * add L to buffer
0000147A  6000 0002                695              BRA     STB_END             
0000147E                           696  
0000147E                           697  STB_END:
0000147E  12FC 0020                698              MOVE.B  #' ',(A1)+          * add L to buffer
00001482  4E75                     699              RTS                         
00001484                           700  
00001484                           701  *-----------------------EA TO BUFFER------------------------
00001484                           702  * evaluates the size of an opcode and adds it to A1 to be printed out
00001484                           703  * Registers:
00001484                           704  *   D2 = destination for shifts
00001484                           705  *   D3 = size of opcode
00001484                           706  *-----------------------------------------------------------
00001484                           707  EA_TO_BUFFER:
00001484  4282                     708              CLR.L   D2
00001486  1403                     709              MOVE.B  D3, D2               ; move size of opcode to be manipulated
00001488  6100 0002                710              BSR     EA_TO_BUFFER_LOOP
0000148C                           711  
0000148C                           712  EA_TO_BUFFER_LOOP:
0000148C  B43C 0000                713              CMP.B   #0, D2
00001490  6700 0008                714              BEQ     EA_TO_BUFFER_END
00001494  4EB8 120E                715              JSR     GRAB_NEXT_WORD
00001498  5302                     716              SUB.B   #1, D2
0000149A                           717  
0000149A                           718  EA_TO_BUFFER_END:
0000149A  4E75                     719              RTS
0000149C                           720  
0000149C                           721  
0000149C                           722  *-------------------------DONE-------------------------------
0000149C                           723  DONE:
0000149C  4280                     724              CLR.L     D0
0000149E  103C 000E                725              MOVE.B    #14, D0
000014A2  43F8 1045                726              LEA.L     doneMsg, A1
000014A6  4E4F                     727              TRAP      #15
000014A8                           728              
000014A8                           729              ; TESTING
000014A8                           730              ; print out the command
000014A8  12FC 0000                731              MOVE.B  #00,(A1)+ ; add the null
000014AC  227C 00000000            732              MOVE.L  #$00000000,A1
000014B2  103C 000D                733              MOVE.B  #13,D0
000014B6  4E4F                     734              TRAP    #15
000014B8                           735              
000014B8                           736m             CLR_A_REG D0, A1
000014BC                           737  
000014BC                           738              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BADINPUT            1052
BAD_OPCODE          1208
BYTE_TO_BUFFER      1466
CHECK_LENGTH        10DC
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      110E
CR                  D
DONE                149C
DONEMSG             1045
EA_000              1382
EA_001              139A
EA_010              13B2
EA_011              13D2
EA_100              13F6
EA_101              141A
EA_110              1420
EA_111              1426
EA_TO_BUFFER        1484
EA_TO_BUFFER_END    149A
EA_TO_BUFFER_LOOP   148C
ENDADDR             106E
ENDMSG              1023
FIND_OPCODE         1224
GET_EA              132C
GET_EA_MODE         1342
GET_END_ADDRESS     10B2
GET_INPUT           1086
GET_REGISTER_NUMBER  130C
GET_SIZE            12E2
GET_START_ADDRESS   1098
GRAB_FIRST_FOUR_BITS  1212
GRAB_NEXT_WORD      120E
IDENTIFY_OPCODE     11D0
INVALID_EA          1444
INVALID_INPUT       10F0
ITERATE             1142
LETTER_TO_HEX       1134
LF                  A
LOAD_ADDRESSES      11A0
LONG_TO_BUFFER      1476
MAIN                107E
NEWLINE             1062
NUM_TO_HEX          112C
OPCODE              107A
OPC_0100            123E
OPC_1100            123E
OPC_1100_AND        1242
OPC_1100_MULS       1294
OPC_1101            12A8
OPERATION_TYPE      12F8
OPOUTPUT            1072
OPTAG               107C
PRINT_INSTRUCTION   11EC
PRINT_MSG           0
RESTORE_REGS        11E6
SIZE_TO_BUFFER      144A
STARTADDR           106A
STARTMSG            1000
STB_END             147E
STORE_CHAR          113C
STORE_END           1180
STORE_INPUT         1150
STORE_START         1160
USERADDR            1066
VALID               107D
VALIDATE_INPUT      10CC
WORD_TO_BUFFER      146E
