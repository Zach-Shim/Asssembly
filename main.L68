0000127C Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/11/2021 1:30:24 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00000000                            11              
00001000                            12              ORG     $1000
00001000                            13  
00001000  =0000000D                 14  CR          EQU     $0D             ; Define Carriage Return and Line Feed
00001000  =0000000A                 15  LF          EQU     $0A 
00001000                            16  
00001000= 31 2E 20 41 64 64 ...     17  rule1:      DC.B    '1. Addresses must be in the range $FFFFFF > x > $6FFF', CR, LF, 0 ' 
00001038= 77 68 65 72 65 20 ...     18  rule1c:     DC.B    'where x is your given address.', CR, LF, 0 '
00001059= 32 2E 20 49 66 20 ...     19  rule2:      DC.B    '2. If you use any letters (A-F), make sure they are upper case.', CR, LF, 0
0000109B= 33 2E 20 49 66 20 ...     20  rule3:      DC.B    '3. If you use constants (DC), make sure you give addresses that', CR, LF, 0 
000010DD= 64 6F 20 6E 6F 74 ...     21  rule3c:     DC.B    'do not include that part of memory (only want to parse instructions).', CR, LF, 0
00001125= 50 6C 65 61 73 65 ...     22  startMsg:   DC.B    'Please enter a starting address.  ', CR, LF, 0
0000114A= 50 6C 65 61 73 65 ...     23  endMsg:     DC.B    'Please enter an ending address. ', CR, LF, 0
0000116D= 65 78 69 74 69 6E ...     24  doneMsg:    DC.B    'exiting...', CR, LF, 0
0000117A= 49 6E 76 61 6C 69 ...     25  badInput:   DC.B    'Invalid Input', CR, LF, 0
0000118A= 0D 0A 00                  26  newline:    DC.B    '', CR, LF, 0
0000118D                            27  
0000118E                            28  userAddr:   DS.L    1
00001192= 00000000                  29              DC.L    0 *Null termination for userAddr
00001196                            30  startAddr:  DS.L    1
0000119A                            31  endAddr:    DS.L    1
0000119E                            32  
0000119E                            33  opcode:     DS.W    1   
000011A0                            34  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
000011A1                            35  opSize:     DS.B    1
000011A2                            36  valid:      DS.B    1
000011A3                            37  
000011A3                            38  ea_mode     DS.B    1
000011A4                            39  ea_register DS.B    1
000011A5                            40  ea_valid    DS.B    1
000011A6                            41  
000011A6                            42  
000011A6                            43  
000011A6                            44  
000011A6                            45  
000011A6                            46  
000011A6                            47  
000011A6                            48  *-----------------------------------------------------------
000011A6                            49  * Macros:
000011A6                            50  *-----------------------------------------------------------
000011A6                            51  
000011A6                            52  PRINT_MSG:  MACRO 
000011A6                            53              CLR.L   D0
000011A6                            54              LEA     \1, A1      ; \1 acts as a parameter
000011A6                            55              MOVE.B  #14, D0     
000011A6                            56              TRAP    #15
000011A6                            57              ENDM
000011A6                            58  
000011A6                            59  CLR_D_REGS: MACRO
000011A6                            60              CLR.L   D0
000011A6                            61              CLR.L   D1
000011A6                            62              CLR.L   D2
000011A6                            63              CLR.L   D3
000011A6                            64              CLR.L   D4
000011A6                            65              CLR.L   D5
000011A6                            66              CLR.L   D6
000011A6                            67              CLR.L   D7
000011A6                            68              ENDM
000011A6                            69  
000011A6                            70  CLR_A_REG:  MACRO
000011A6                            71              CLR.L   \1
000011A6                            72              MOVE.L  \1, \2
000011A6                            73              ENDM              
000011A6                            74  
000011A6                            75  *-----------------------------------------------------------
000011A6                            76  * Parameters:
000011A6                            77  *   \1 should be highest bit in range
000011A6                            78  *   \2 should be lowest bit in range
000011A6                            79  * 
000011A6                            80  * Example: #11, #9
000011A6                            81  *
000011A6                            82  * Return Value:
000011A6                            83  *   D4 = value held within bits \1 and \2
000011A6                            84  *
000011A6                            85  * Registers:
000011A6                            86  *   D4 = holds opcode
000011A6                            87  *   D5 = highest bit in range 
000011A6                            88  *   D6 = lowest bit in range 
000011A6                            89  *   D7 = number of bits we want
000011A6                            90  *-----------------------------------------------------------
000011A6                            91  GET_BITS:   MACRO
000011A6                            92  
000011A6                            93              CLR_D_REGS
000011A6                            94  
000011A6                            95              * Subtract value to find amount to shift by 
000011A6                            96              ADD.B   \1, D7          
000011A6                            97              SUB.B   \2, D7 
000011A6                            98              ADD.B   #1, D7  * add 1 because we start our count from 0
000011A6                            99  
000011A6                           100              * Get high bit offset
000011A6                           101              ADD.B   #15, D5
000011A6                           102              SUB.B   \1, D5
000011A6                           103              
000011A6                           104              * shift out high bits
000011A6                           105              MOVE.W  opcode, D4
000011A6                           106              LSL.W   D5, D4
000011A6                           107              
000011A6                           108              *get low bit offset
000011A6                           109              *16 - NUMBER OF BITS WE WANT
000011A6                           110              ADD.B   #16, D6         * 16 total bits
000011A6                           111              SUB.L   D7, D6          * subtract numBits from 16
000011A6                           112              
000011A6                           113              * shift out low bits
000011A6                           114              LSR.W   D6, D4          * isolate bits
000011A6                           115              ENDM
000011A6                           116  
000011A6                           117  *----------------------Value To Buffer----------------------
000011A6                           118  * Description:
000011A6                           119  * Converts a Hex numbered address (1-9 or A-F) back to an
000011A6                           120  * ASCII value and pushes it to the buffer for printing
000011A6                           121  *
000011A6                           122  * Parameters:
000011A6                           123  *   \1 = should hold value (in hex) you want to push to the buffer
000011A6                           124  *
000011A6                           125  *-----------------------------------------------------------
000011A6                           126  VALUE_TO_BUFFER:  MACRO
000011A6                           127                    MOVE.L  \1, D2  
000011A6                           128                    JSR     NUMBER_OR_LETTER
000011A6                           129                    ENDM
000011A6                           130  *-----------------------------------------------------------
000011A6                           131  
000011A6                           132  *----------------------Size To Buffer-----------------------
000011A6                           133  * Description:
000011A6                           134  * Converts a binary size (Byte = 00, Word = 01, or Long = 10) 
000011A6                           135  * to a letter (B, W, L) and pushes it to the buffer
000011A6                           136  *
000011A6                           137  * Parameters:
000011A6                           138  *   \1 = should hold size (in binary) of the size you want
000011A6                           139  *        to push to the buffer
000011A6                           140  *
000011A6                           141  *-----------------------------------------------------------
000011A6                           142  SIZE_TO_BUFFER:   MACRO
000011A6                           143                    MOVE.L  \1, D3
000011A6                           144                    JSR     FIND_SIZE
000011A6                           145                    ENDM
000011A6                           146  *-----------------------------------------------------------
000011A6                           147  
000011A6                           148  
000011A6                           149  
000011A6                           150  
000011A6                           151  
000011A6                           152  
000011A6                           153  *----------------Decoding EA Mode and Register--------------
000011A6                           154  * Description:
000011A6                           155  * Decodes EA mode and register and pushes to buffer
000011A6                           156  * 
000011A6                           157  * Parameters:
000011A6                           158  *   \1 = high bit of ea
000011A6                           159  *   \2 = low bit of ea
000011A6                           160  *
000011A6                           161  * Registers Used:
000011A6                           162  *   D1 = temp variable
000011A6                           163  *
000011A6                           164  * For Example (most common): 
000011A6                           165  *   DECODE_EA    #5, #0
000011A6                           166  *
000011A6                           167  *-----------------------------------------------------------
000011A6                           168  DECODE_EA:  MACRO
000011A6                           169              CLR_D_REGS
000011A6                           170              MOVE.B      \1, D1
000011A6                           171              JSR         DECODE_EA_HELP
000011A6                           172              JSR         EA_TO_BUFFER
000011A6                           173              ENDM
000011A6                           174  
000011A6                           175  GET_EA_MODE: MACRO
000011A6                           176               GET_BITS        \1, \2
000011A6                           177               MOVE.B          D4, ea_mode
000011A6                           178               ENDM
000011A6                           179  
000011A6                           180  GET_EA_REG:  MACRO
000011A6                           181               GET_BITS        \1, \2
000011A6                           182               MOVE.B          D4, ea_register
000011A6                           183               ENDM
000011A6                           184  *-----------------------------------------------------------
000011A6                           185  
000011A6                           186  *-----------------------------------------------------------
000011A6                           187  DECODE_EA_HELP:
000011A6                           188          
000011A6  B23C 0005                189              CMP.B       #5, D1               * is this bits 5-0?
000011AA  6700 000A                190              BEQ         DECODE_6_TO_0
000011AE                           191  
000011AE  B23C 000B                192              CMP.B       #11, D1              * is this bits 11-6? 
000011B2  6700 0064                193              BEQ         DECODE_11_TO_6
000011B6                           194  
000011B6                           195  DECODE_6_TO_0:
000011B6                           196m             GET_EA_MODE #5, #3               * get ea mode
000011C6                           197mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011CC                           198mm             * GET HIGH BIT OFFSET
000011D2                           199mm             * SHIFT OUT HIGH BITS
000011D8                           200mm             *GET LOW BIT OFFSET
000011D8                           201mm             *16 - NUMBER OF BITS WE WANT
000011DE                           202mm             * SHIFT OUT LOW BITS
000011E4                           203m             GET_EA_REG  #2, #0               * get ea register
000011F4                           204mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000011FC                           205mm             * GET HIGH BIT OFFSET
00001202                           206mm             * SHIFT OUT HIGH BITS
00001208                           207mm             *GET LOW BIT OFFSET
00001208                           208mm             *16 - NUMBER OF BITS WE WANT
0000120E                           209mm             * SHIFT OUT LOW BITS
00001214  6000 0064                210              BRA         EA_END
00001218                           211  
00001218                           212  DECODE_11_TO_6:
00001218                           213m             GET_EA_MODE #8, #6               * get ea mode
00001228                           214mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000122E                           215mm             * GET HIGH BIT OFFSET
00001234                           216mm             * SHIFT OUT HIGH BITS
0000123A                           217mm             *GET LOW BIT OFFSET
0000123A                           218mm             *16 - NUMBER OF BITS WE WANT
00001240                           219mm             * SHIFT OUT LOW BITS
00001246                           220m             GET_EA_REG  #11, #9              * get ea register
00001256                           221mm             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001260                           222mm             * GET HIGH BIT OFFSET
00001268                           223mm             * SHIFT OUT HIGH BITS
0000126E                           224mm             *GET LOW BIT OFFSET
0000126E                           225mm             *16 - NUMBER OF BITS WE WANT
00001274                           226mm             * SHIFT OUT LOW BITS
0000127A                           227  
0000127A                           228  EA_END:
0000127A  4E75                     229              RTS
0000127C                           230  
0000127C                           231  *-----------------------------------------------------------            
0000127C                           232  
0000127C                           233  
0000127C                           234  
0000127C                           235  
0000127C                           236  
0000127C                           237  *----------------------Buffer Macros------------------------
0000127C                           238  * Description:
0000127C                           239  * Pushes commonly used single characters to the buffer
0000127C                           240  *-----------------------------------------------------------
0000127C                           241  INSERT_SPACE:   MACRO
0000127C                           242                  MOVE.B  #' ',(A1)+          * add blank space to buffer
0000127C                           243                  ENDM
0000127C                           244  
0000127C                           245  INSERT_COMMA:   MACRO
0000127C                           246                  MOVE.B  #',',(A1)+          * add blank space to buffer
0000127C                           247                  ENDM
0000127C                           248  
0000127C                           249  INSERT_PERIOD:  MACRO
0000127C                           250                  MOVE.B  #'.',(A1)+          * add blank space to buffer
0000127C                           251                  ENDM
0000127C                           252  
0000127C                           253  INSERT_POUND:   MACRO
0000127C                           254                  MOVE.B  #'#',(A1)+          * add blank space to buffer
0000127C                           255                  ENDM
0000127C                           256  
0000127C                           257  INSERT_DOLLAR:  MACRO
0000127C                           258                  MOVE.B  #'$',(A1)+          * add blank space to buffer
0000127C                           259                  ENDM
0000127C                           260  *-----------------------------------------------------------
0000127C                           261  
0000127C                           262  
0000127C                           263  
0000127C                           264  
0000127C                           265  
0000127C                           266  
0000127C                           267  
0000127C                           268  
0000127C                           269  
0000127C                           270  *-----------------------------------------------------------
0000127C                           271  * Description:  
0000127C                           272  * Main routine
0000127C                           273  *-----------------------------------------------------------
0000127C                           274  
0000127C                           275  *-------------------------MAIN------------------------------
0000127C                           276  MAIN:
0000127C                           277m             PRINT_MSG    rule1
00001288                           278m             PRINT_MSG    rule1c                   
00001294                           279m             PRINT_MSG    rule2
000012A0                           280m             PRINT_MSG    rule3
000012AC                           281m             PRINT_MSG    rule3c
000012B8  6100 000A                282              BSR          GET_INPUT
000012BC  6100 0074                283              BSR          CHECK_ADDRESS
000012C0  6000 018C                284              BRA          LOAD_ADDRESSES
000012C4                           285  *-----------------------------------------------------------
000012C4                           286  
000012C4                           287  
000012C4                           288  
000012C4                           289  
000012C4                           290  
000012C4                           291  
000012C4                           292  
000012C4                           293  
000012C4                           294  *-----------------------------------------------------------
000012C4                           295  * Description:  
000012C4                           296  * Get User Input
000012C4                           297  *
000012C4                           298  * Registers Used:
000012C4                           299  *   D0 = task values
000012C4                           300  *   D1 = stores of size of ascii string in A1 from user input
000012C4                           301  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000012C4                           302  *   A1 = stores an ascii string from user input
000012C4                           303  *-----------------------------------------------------------
000012C4                           304  *-------------------------Get Input-------------------------
000012C4                           305  GET_INPUT:
000012C4                           306m             PRINT_MSG    startMsg
000012D0  6100 002C                307              BSR          GET_ADDRESS   
000012D4  21C7 1196                308              MOVE.L       D7, startAddr
000012D8                           309  
000012D8                           310m             CLR_D_REGS
000012E8                           311  
000012E8                           312m             PRINT_MSG    endMsg
000012F4  6100 0008                313              BSR          GET_ADDRESS   
000012F8  21C7 119A                314              MOVE.L       D7, endAddr
000012FC  4E75                     315              RTS 
000012FE                           316  *-----------------------------------------------------------
000012FE                           317  
000012FE                           318  *------------------------Get Address------------------------
000012FE                           319  GET_ADDRESS:
000012FE  43F8 118E                320              LEA.L   userAddr, A1
00001302  103C 0002                321              MOVE.B  #2, D0
00001306  4E4F                     322              TRAP    #15
00001308                           323  
00001308  6100 0008                324              BSR     CHECK_LENGTH
0000130C  6100 0054                325              BSR     CONVERT_TO_HEX
00001310  4E75                     326              RTS
00001312                           327  *-----------------------------------------------------------
00001312                           328  
00001312                           329  
00001312                           330  
00001312                           331  
00001312                           332  
00001312                           333  
00001312                           334  
00001312                           335  
00001312                           336  
00001312                           337  
00001312                           338  *-----------------------------------------------------------
00001312                           339  * Description:  Validate User Input
00001312                           340  * Constraints:  
00001312                           341  *   User input must be:
00001312                           342  *   Length 4 or Length 8
00001312                           343  *   ASCII character 0-9 or A-F
00001312                           344  *   Starting and ending address with value < $00FFFFFF 
00001312                           345  *   Starting address is before ending address
00001312                           346  *
00001312                           347  * Registers Used:
00001312                           348  *   D0 = task values
00001312                           349  *   D1 = stores of size of ascii string in A1 from user input
00001312                           350  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
00001312                           351  *   A1 = stores an ascii string from user input
00001312                           352  *-----------------------------------------------------------
00001312                           353  
00001312                           354  *----------------------VALIDATE INPUT---------------------------      
00001312                           355  CHECK_LENGTH:
00001312  B23C 0001                356              CMP.B      #1, D1               ; for task 2, length of string is in D1                
00001316  6D00 000C                357              BLT        INVALID_INPUT 
0000131A  B23C 0008                358              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
0000131E  6E00 0004                359              BGT        INVALID_INPUT
00001322  4E75                     360              RTS
00001324                           361  
00001324                           362  INVALID_INPUT:  
00001324                           363m             PRINT_MSG  badInput
00001330  6092                     364              BRA        GET_INPUT
00001332                           365  *-----------------------------------------------------------
00001332                           366  
00001332                           367  *----------------------VALIDATE INPUT---------------------------      
00001332                           368  CHECK_ADDRESS:
00001332  2A38 1196                369              MOVE.L     startAddr, D5
00001336  BAB8 119A                370              CMP.L      endAddr, D5          ; starting address >= ending address?
0000133A  6C00 0016                371              BGE        INVALID_ADDRESS
0000133E                           372  
0000133E  BABC 00006FFF            373              CMP.L      #$6FFF, D5
00001344  6FDE                     374              BLE        INVALID_INPUT 
00001346                           375              
00001346  0CB8 00FFFFFF 119A       376              CMP.L      #$FFFFFF, endAddr
0000134E  6CD4                     377              BGE        INVALID_INPUT
00001350  4E75                     378              RTS
00001352                           379  
00001352                           380  INVALID_ADDRESS:  
00001352                           381m             PRINT_MSG  badInput
0000135E  6000 FF64                382              BRA        GET_INPUT
00001362                           383  *-----------------------------------------------------------
00001362                           384  
00001362                           385  *----------------CONVERT FROM ASCII TO HEX------------------
00001362                           386  CONVERT_TO_HEX:
00001362  0C11 0030                387              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001366  6DBC                     388              BLT        INVALID_INPUT        
00001368                           389  
00001368  0C11 003A                390              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
0000136C  6D00 0012                391              BLT        NUM_TO_HEX      
00001370                           392  
00001370  0C11 0041                393              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001374  6DAE                     394              BLT        INVALID_INPUT             
00001376                           395  
00001376  0C11 0047                396              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
0000137A  6D00 000C                397              BLT        LETTER_TO_HEX
0000137E                           398  
0000137E  60A4                     399              BRA        INVALID_INPUT    
00001380                           400  
00001380                           401  NUM_TO_HEX:      
00001380  0411 0030                402              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001384  6000 000A                403              BRA        STORE_CHAR   
00001388                           404  
00001388                           405  LETTER_TO_HEX:     
00001388  0411 0037                406              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
0000138C  6000 0002                407              BRA        STORE_CHAR
00001390                           408  
00001390                           409  STORE_CHAR:       
00001390  D619                     410              ADD.B      (A1)+, D3           ; keep hex stored in D3           
00001392  6000 0002                411              BRA        ITERATE                 
00001396                           412  
00001396                           413  ITERATE:
00001396  5301                     414              SUB.B      #$1, D1
00001398  B23C 0000                415              CMP.B      #0, D1
0000139C  6700 0006                416              BEQ        STORE_INPUT
000013A0                           417  
000013A0  E98B                     418              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
000013A2  60BE                     419              BRA        CONVERT_TO_HEX
000013A4                           420  
000013A4                           421  STORE_INPUT:
000013A4  2E03                     422              MOVE.L     D3, D7
000013A6  4E75                     423              RTS
000013A8                           424  *-----------------------------------------------------------
000013A8                           425  
000013A8                           426  
000013A8                           427  
000013A8                           428  
000013A8                           429  
000013A8                           430  
000013A8                           431  
000013A8                           432  
000013A8                           433  
000013A8                           434  
000013A8                           435              
000013A8                           436  *--------------------------PRINT----------------------------
000013A8                           437  * Description:
000013A8                           438  * Prints hex addresses according to where we are in the .S file
000013A8                           439  * and source/destination effective addresses
000013A8                           440  *
000013A8                           441  * No Parameters
000013A8                           442  *
000013A8                           443  * Registers:
000013A8                           444  *   D0 = used for tasks and trap #15
000013A8                           445  *   D1 = size of comparison
000013A8                           446  *   D2 = destination for comparisons, holds an address
000013A8                           447  *   D3 = iterator
000013A8                           448  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000013A8                           449  *   A2 = current address (given by user)
000013A8                           450  *-----------------------------------------------------------
000013A8                           451  
000013A8                           452  *----------------------PRINT_ADDRESS------------------------
000013A8                           453  PRINT_ADDRESS:
000013A8                           454              * reset A1 to beginning of string
000013A8                           455m             CLR_D_REGS
000013B8                           456m             CLR_A_REG D0, A1
000013BC                           457              
000013BC                           458              * move current address to D2
000013BC  240A                     459              MOVE.L    A2, D2
000013BE                           460  
000013BE                           461              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
000013BE  223C 00008000            462              MOVE.L    #$8000, D1
000013C4  B481                     463              CMP.L     D1, D2
000013C6  6D00 000E                464              BLT       PRINT_WORD
000013CA                           465              
000013CA                           466              * if absolute long, print long. Range $8000 - $FFFF7FFF
000013CA  223C FFFF8000            467              MOVE.L    #$FFFF8000, D1
000013D0  B481                     468              CMP.L     D1, D2
000013D2  6C00 001C                469              BGE       PRINT_LONG                 
000013D6                           470  
000013D6                           471  PRINT_WORD:
000013D6                           472m             CLR_D_REGS
000013E6  123C 0001                473              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000013EA  3E0A                     474              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000013EC  6000 001C                475              BRA       FINISH_PRINT
000013F0                           476  
000013F0                           477  PRINT_LONG:
000013F0                           478m             CLR_D_REGS
00001400  123C 0003                479              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
00001404  2E0A                     480              MOVE.L    A2, D7
00001406  6000 0002                481              BRA       FINISH_PRINT
0000140A                           482  
0000140A                           483  FINISH_PRINT:
0000140A                           484              * convert hex values back to ASCII
0000140A  4EB9 00001D52            485              JSR       HEX_TO_ASCII
00001410                           486              
00001410                           487              * print out string
00001410  12BC 0000                488              MOVE.B    #00,(A1)
00001414                           489m             CLR_D_REGS
00001424                           490m             CLR_A_REG D0, A1
00001428  103C 000E                491              MOVE.B    #14, D0
0000142C  4E4F                     492              TRAP      #15
0000142E  4E75                     493              RTS
00001430                           494  *-----------------------------------------------------------
00001430                           495  
00001430                           496  *-------------------PRINT_INSTRUCTION-----------------------
00001430                           497  PRINT_INSTRUCTION:    
00001430                           498              * null terminator
00001430  12BC 0000                499              MOVE.B    #00,(A1)              
00001434                           500  
00001434                           501              * reset A1 to beginning of string
00001434  4280                     502              CLR.L     D0
00001436                           503m             CLR_A_REG D0, A1
0000143A                           504  
0000143A                           505              * print out string
0000143A  103C 000E                506              MOVE.B    #14, D0
0000143E  4E4F                     507              TRAP      #15
00001440                           508  
00001440                           509m             PRINT_MSG newline
0000144C  4E75                     510              RTS
0000144E                           511  *-----------------------------------------------------------
0000144E                           512  
0000144E                           513  
0000144E                           514  
0000144E                           515  
0000144E                           516  
0000144E                           517  
0000144E                           518  
0000144E                           519  
0000144E                           520  
0000144E                           521  
0000144E                           522  
0000144E                           523  
0000144E                           524  
0000144E                           525  
0000144E                           526  
0000144E                           527  
0000144E                           528  
0000144E                           529  
0000144E                           530  
0000144E                           531  
0000144E                           532  *---------------------LOAD ADDRESSES------------------------
0000144E                           533  * Description:
0000144E                           534  * Stores INITIAL values into appropriate address registers 
0000144E                           535  * which is necessary to complete before starting identify opcodes loop
0000144E                           536  * Also pushes reigsters onto the stack
0000144E                           537  *
0000144E                           538  * No Parameters
0000144E                           539  *
0000144E                           540  * Registers:
0000144E                           541  *   A2 = current address (given by user)
0000144E                           542  *   A3 = ending address (given by user)
0000144E                           543  *-----------------------------------------------------------
0000144E                           544  LOAD_ADDRESSES: 
0000144E                           545              * reset A1 to beginning of string
0000144E  4280                     546              CLR.L       D0
00001450                           547m             CLR_A_REG   D0, A1
00001454                           548  
00001454                           549              * load start and end registers and print starting address
00001454  2478 1196                550              MOVEA.L     startAddr, A2
00001458  2678 119A                551              MOVEA.L     endAddr, A3
0000145C  6100 FF4A                552              BSR         PRINT_ADDRESS
00001460                           553m             INSERT_SPACE
00001464                           554  
00001464  6100 0040                555              BSR         GRAB_NEXT_WORD
00001468  6100 0042                556              BSR         GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
0000146C                           557  
0000146C                           558              * Push current registers onto the stack (so we can have fresh registers)
0000146C  48E7 FF00                559              MOVEM.L D0-D7,-(SP)                  ; move the old registers onto the stack
00001470  6000 004C                560              BRA     FIND_OPCODE
00001474                           561  *-----------------------------------------------------------
00001474                           562  
00001474                           563  *-----------------------------------------------------------
00001474                           564  * Description:  IDENTIFY OPCODES LOOP
00001474                           565  * Registers:
00001474                           566  *   D0 = used for tasks and trap #15
00001474                           567  *   D1 = size of shifting bits
00001474                           568  *   D2 = destination for shifts
00001474                           569  *   D3 = size of opcode
00001474                           570  *   D4 = used to hold bits returned from SHIFT macro
00001474                           571  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001474                           572  *   A2 = current address (given by user)
00001474                           573  *   A3 = ending address (given by user)
00001474                           574  *-----------------------------------------------------------
00001474                           575  *-------------------IDENTIFY OPCODES------------------------
00001474                           576  * evaluates an opcode based on first four bits (aka opTag)
00001474                           577  * for now only works with one instruction
00001474                           578  *-----------------------------------------------------------
00001474                           579  IDENTIFY_OPCODE:
00001474                           580  
00001474                           581              * print opcode
00001474  61BA                     582              BSR     PRINT_INSTRUCTION
00001476                           583  
00001476                           584              * check if starting address >= ending address
00001476  B5CB                     585              CMPA.L  A3, A2
00001478  6C00 097E                586              BGE     DONE
0000147C                           587              
0000147C                           588              * print next address
0000147C  6100 FF2A                589              BSR     PRINT_ADDRESS
00001480                           590m             INSERT_SPACE
00001484                           591              
00001484                           592              ;BSR     RESTORE_REGS           need to fix
00001484                           593  
00001484                           594m             CLR_D_REGS
00001494  6100 0010                595              BSR     GRAB_NEXT_WORD          * grab opcode
00001498  6100 0012                596              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
0000149C                           597             
0000149C  6000 0020                598              BRA     FIND_OPCODE
000014A0                           599  *------------------------------------------------------------
000014A0                           600  
000014A0                           601  *----------------------RESTORE_REGS--------------------------
000014A0                           602  * Description:
000014A0                           603  * Move the old registers onto the stack
000014A0                           604  *------------------------------------------------------------
000014A0                           605  RESTORE_REGS:
000014A0  4CDF 00FF                606              MOVEM.L (SP)+, D0-D7            
000014A4  4E75                     607              RTS
000014A6                           608  *-----------------------------------------------------------
000014A6                           609  
000014A6                           610  *---------Useful Subroutines For Identifying Opcodes--------
000014A6                           611  GRAB_NEXT_WORD:
000014A6                           612              * load current word of bits into D7
000014A6  31DA 119E                613              MOVE.W (A2)+, opcode
000014AA  4E75                     614              RTS
000014AC                           615  
000014AC                           616  GRAB_FIRST_FOUR_BITS:
000014AC                           617              * find first four bits of opcode
000014AC  3438 119E                618              MOVE.W  opcode, D2
000014B0  123C 000C                619              MOVE.B  #12, D1
000014B4  E2AA                     620              LSR.L   D1, D2
000014B6  1002                     621              MOVE.B  D2, D0
000014B8  11C0 11A0                622              MOVE.B  D0, opTag
000014BC  4E75                     623              RTS
000014BE                           624  *-----------------------------------------------------------
000014BE                           625  
000014BE                           626  
000014BE                           627  
000014BE                           628  
000014BE                           629  
000014BE                           630  
000014BE                           631  
000014BE                           632  
000014BE                           633  
000014BE                           634  *----------------------FIND OPCODE--------------------------
000014BE                           635  * Description:
000014BE                           636  * Finds a matching opTag (first four bits of opcode) and 
000014BE                           637  * jumps to that opcode's encoding subroutine
000014BE                           638  *
000014BE                           639  * For example:
000014BE                           640  *               ADD's first four bits = 1101, so I put
000014BE                           641  *               CMP.B #%1101, D0
000014BE                           642  *
000014BE                           643  * No Parameters
000014BE                           644  *
000014BE                           645  * No Registers Used
000014BE                           646  *-----------------------------------------------------------        
000014BE                           647  FIND_OPCODE:
000014BE  0C38 0000 11A0           648              CMP.B   #%0000, opTag 
000014C4  6700 0070                649              BEQ     OPC_0000
000014C8                           650  
000014C8  0C38 0001 11A0           651              CMP.B   #%0001, opTag 
000014CE  6700 0162                652              BEQ     OPC_0001
000014D2                           653  
000014D2  0C38 0002 11A0           654              CMP.B   #%0010, opTag 
000014D8  6700 0182                655              BEQ     OPC_0010
000014DC                           656  
000014DC  0C38 0003 11A0           657              CMP.B   #%0011, opTag 
000014E2  6700 01A2                658              BEQ     OPC_0011
000014E6                           659  
000014E6  0C38 0004 11A0           660              CMP.B   #%0100, opTag 
000014EC  6700 0208                661              BEQ     OPC_0100
000014F0                           662              
000014F0  0C38 0006 11A0           663              CMP.B   #%0110, opTag
000014F6  6700 04A4                664              BEQ     OPC_0110
000014FA                           665  
000014FA  0C38 0005 11A0           666              CMP.B   #%0101, opTag 
00001500  6700 038C                667              BEQ     OPC_0101
00001504                           668  
00001504  0C38 0008 11A0           669              CMP.B   #%1000, opTag
0000150A  6700 0350                670              BEQ     OPC_1000
0000150E                           671  
0000150E  0C38 0009 11A0           672              CMP.B   #%1001, opTag
00001514  6700 054A                673              BEQ     OPC_1001
00001518                           674  
00001518  0C38 000C 11A0           675              CMP.B   #%1100, opTag
0000151E  6700 0554                676              BEQ     OPC_1100
00001522                           677  
00001522  0C38 000D 11A0           678              CMP.B   #%1101, opTag
00001528  6700 05C2                679              BEQ     OPC_1101
0000152C                           680  
0000152C                           681              * error, bad opcode
0000152C  6000 0002                682              BRA      BAD_OPCODE
00001530                           683  
00001530                           684  *-----------------------------------------------------------
00001530                           685  
00001530                           686  *-----------------------BAD OPCODE--------------------------
00001530                           687  BAD_OPCODE:
00001530  4EF9 00001DF8            688              JMP      DONE
00001536                           689  *-----------------------------------------------------------
00001536                           690  
00001536                           691  *------------------------OPC_0000---------------------------
00001536                           692  * First four bits = 0000
00001536                           693  * (ADDI, SUBI)
00001536                           694  *-----------------------------------------------------------
00001536                           695  OPC_0000:
00001536                           696m             GET_BITS  #11, #8
00001546                           697m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000154E                           698m             * GET HIGH BIT OFFSET
00001556                           699m             * SHIFT OUT HIGH BITS
0000155C                           700m             *GET LOW BIT OFFSET
0000155C                           701m             *16 - NUMBER OF BITS WE WANT
00001562                           702m             * SHIFT OUT LOW BITS
00001564                           703              
00001564                           704              * is the opcode ADDI?
00001564  B83C 0006                705              CMP.B     #%0110, D4
00001568  6700 000E                706              BEQ       OPC_ADDI
0000156C                           707  
0000156C                           708              * is the opcode SUBI?
0000156C  B83C 0004                709              CMP.B     #%0100, D4
00001570  6700 001E                710              BEQ       OPC_SUBI
00001574                           711  
00001574  4EF8 1530                712              JMP       BAD_OPCODE
00001578                           713  
00001578                           714  *------------------------OPC_ADDI---------------------------
00001578                           715  OPC_ADDI:
00001578  12FC 0041                716              MOVE.B  #'A',(A1)+          * Put ADD into Buff
0000157C  12FC 0044                717              MOVE.B  #'D',(A1)+
00001580  12FC 0044                718              MOVE.B  #'D',(A1)+
00001584  12FC 0049                719              MOVE.B  #'I',(A1)+
00001588                           720m             INSERT_PERIOD
0000158C                           721  
0000158C  6100 001A                722              BSR     DECODE_IMMEDIATE
00001590                           723  
00001590                           724  *------------------------OPC_SUBI---------------------------
00001590                           725  OPC_SUBI:            
00001590  12FC 0053                726              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001594  12FC 0055                727              MOVE.B  #'U',(A1)+
00001598  12FC 0042                728              MOVE.B  #'B',(A1)+
0000159C  12FC 0049                729              MOVE.B  #'I',(A1)+
000015A0                           730m             INSERT_PERIOD
000015A4                           731  
000015A4  6100 0002                732              BSR     DECODE_IMMEDIATE
000015A8                           733  
000015A8                           734  *--------------Subroutines for OPC_0000---------------------  
000015A8                           735  DECODE_IMMEDIATE:
000015A8                           736              * push size to buffer
000015A8                           737m             GET_BITS        #7, #6              * get size bits (gets returned to D4)
000015B8                           738m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000015BE                           739m             * GET HIGH BIT OFFSET
000015C4                           740m             * SHIFT OUT HIGH BITS
000015CA                           741m             *GET LOW BIT OFFSET
000015CA                           742m             *16 - NUMBER OF BITS WE WANT
000015D0                           743m             * SHIFT OUT LOW BITS
000015D2  11C4 11A1                744              MOVE.B          D4, opSize
000015D6                           745m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000015DE                           746  
000015DE                           747              * push #<data> to buffer
000015DE  4EB9 0000160E            748              JSR             CHECK_IMMEDIATE
000015E4                           749  
000015E4                           750m             INSERT_COMMA
000015E8                           751m             INSERT_SPACE
000015EC                           752  
000015EC                           753              * push <ea> to buffer
000015EC                           754m             DECODE_EA       #5, #0
0000160A  6000 FE68                755              BRA             IDENTIFY_OPCODE
0000160E                           756   
0000160E                           757  CHECK_IMMEDIATE:
0000160E                           758m             INSERT_POUND
00001612                           759  
00001612  B67C 0001                760              CMP     #1, D3
00001616  6F00 000A                761              BLE     IMMEDIATE_WORD
0000161A                           762  
0000161A  B67C 0002                763              CMP     #2, D3
0000161E  6000 000A                764              BRA     IMMEDIATE_LONG
00001622                           765  
00001622                           766  IMMEDIATE_WORD:
00001622  4EB9 00001D06            767              JSR     EA_WORD
00001628  4E75                     768              RTS
0000162A                           769  
0000162A                           770  IMMEDIATE_LONG:
0000162A  4EB9 00001D1A            771              JSR     EA_LONG      
00001630  4E75                     772              RTS
00001632                           773  *-----------------------------------------------------------
00001632                           774  
00001632                           775  *------------------------OPC_0001---------------------------
00001632                           776  * First four bits = 0001
00001632                           777  * (MOVE.B)
00001632                           778  *-----------------------------------------------------------
00001632                           779  OPC_0001:
00001632  12FC 004D                780              MOVE.B   #'M',(A1)+          * Put ADD into Buff
00001636  12FC 004F                781              MOVE.B   #'O',(A1)+
0000163A  12FC 0056                782              MOVE.B   #'V',(A1)+
0000163E  12FC 0045                783              MOVE.B   #'E',(A1)+
00001642  12FC 002E                784              MOVE.B   #'.',(A1)+
00001646  12FC 0042                785              MOVE.B   #'B',(A1)+
0000164A                           786m             INSERT_SPACE
0000164E                           787  
0000164E  11FC 0000 11A1           788              MOVE.B   #0, opSize
00001654                           789  
00001654  6100 005A                790              BSR      DECODE_MOVE
00001658  6000 FE1A                791              BRA      IDENTIFY_OPCODE
0000165C                           792  *-----------------------------------------------------------
0000165C                           793  
0000165C                           794  *------------------------OPC_0010---------------------------
0000165C                           795  * First four bits = 0010
0000165C                           796  * (MOVE.L)
0000165C                           797  *-----------------------------------------------------------
0000165C                           798  OPC_0010:
0000165C  12FC 004D                799              MOVE.B  #'M',(A1)+          * Put ADD into Buff
00001660  12FC 004F                800              MOVE.B  #'O',(A1)+
00001664  12FC 0056                801              MOVE.B  #'V',(A1)+
00001668  12FC 0045                802              MOVE.B  #'E',(A1)+
0000166C  12FC 002E                803              MOVE.B  #'.',(A1)+
00001670  12FC 004C                804              MOVE.B  #'L',(A1)+
00001674                           805m             INSERT_SPACE
00001678                           806  
00001678  11FC 0002 11A1           807              MOVE.B   #2, opSize
0000167E                           808  
0000167E  6100 0030                809              BSR      DECODE_MOVE
00001682  6000 FDF0                810              BRA      IDENTIFY_OPCODE
00001686                           811  *-----------------------------------------------------------
00001686                           812  
00001686                           813  *------------------------OPC_0011---------------------------
00001686                           814  * First four bits = 0011
00001686                           815  * (MOVE.W)
00001686                           816  *-----------------------------------------------------------
00001686                           817  OPC_0011:
00001686  12FC 004D                818              MOVE.B  #'M',(A1)+          * Put ADD into Buff
0000168A  12FC 004F                819              MOVE.B  #'O',(A1)+
0000168E  12FC 0056                820              MOVE.B  #'V',(A1)+
00001692  12FC 0045                821              MOVE.B  #'E',(A1)+
00001696  12FC 002E                822              MOVE.B  #'.',(A1)+
0000169A  12FC 0057                823              MOVE.B  #'W',(A1)+
0000169E                           824m             INSERT_SPACE
000016A2                           825  
000016A2  11FC 0001 11A1           826              MOVE.B   #1, opSize
000016A8                           827  
000016A8  6100 0006                828              BSR      DECODE_MOVE
000016AC  6000 FDC6                829              BRA      IDENTIFY_OPCODE
000016B0                           830  *-----------------------------------------------------------
000016B0                           831  
000016B0                           832  *---------------------Decode Move---------------------------
000016B0                           833  DECODE_MOVE:
000016B0                           834m             DECODE_EA       #5, #0
000016CE                           835              
000016CE                           836m             INSERT_COMMA
000016D2                           837m             INSERT_SPACE
000016D6                           838  
000016D6                           839m             DECODE_EA       #11, #6
000016F4  4E75                     840              RTS
000016F6                           841  *-----------------------------------------------------------
000016F6                           842  
000016F6                           843  *------------------------OPC_0100---------------------------
000016F6                           844  * First four bits = 0100
000016F6                           845  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
000016F6                           846  *-----------------------------------------------------------
000016F6                           847  OPC_0100:
000016F6                           848  
000016F6                           849              * Check if the opcode is NOP
000016F6  3438 119E                850              MOVE.W  opcode, D2              * Copy opcode to D2
000016FA  B47C 4E71                851              CMP.W   #$4E71, D2              * Check if D2 is equal to NOP (0x4E71 in hex)
000016FE  6700 0054                852              BEQ     OPC_NOP                 * If equal branch to label to handle the opcode NOP
00001702                           853              
00001702                           854              * Check if the opcode is NOT
00001702  E082                     855              ASR.L   #8, D2                  * Shift bits to compare
00001704  B43C 0046                856              CMP.B   #%01000110, D2
00001708  6700 005A                857              BEQ     OPC_NOT
0000170C  4282                     858              CLR.L   D2
0000170E                           859              
0000170E                           860              * Check if the opcode is LEA
0000170E  3838 119E                861              MOVE.W   opcode, D4             * Put opcode in D4 to use the macro get bits
00001712                           862m             GET_BITS #8, #6 
00001722                           863m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001728                           864m             * GET HIGH BIT OFFSET
0000172E                           865m             * SHIFT OUT HIGH BITS
00001734                           866m             *GET LOW BIT OFFSET
00001734                           867m             *16 - NUMBER OF BITS WE WANT
0000173A                           868m             * SHIFT OUT LOW BITS
0000173C  B83C 0007                869              CMP.B    #%0111, D4              * if bits 6-8 are equal to 111, then the opocde is LEA
00001740  6700 008A                870              BEQ      OPC_LEA
00001744                           871  
00001744                           872              * Check if the opcode is JSR
00001744  B83C 0002                873              CMP.B   #%0010, D4              * if bits 6-8 are equal to 010, then the opocde is LEA
00001748  6700 00D0                874              BEQ     OPC_JSR
0000174C                           875  
0000174C                           876              * Check if the opcode is RTS
0000174C  B83C 0001                877              CMP.B   #%0001, D4              * if bits 6-8 are equal to 001, then the opocde is LEA
00001750  6700 00FA                878              BEQ     OPC_RTS
00001754                           879  
00001754                           880  *---------------------------OPC_NOP--------------------------------
00001754                           881  
00001754                           882  OPC_NOP:
00001754                           883              * Put NOP into A1 buffer for printing
00001754  12FC 004E                884              MOVE.B  #'N',(A1)+      
00001758  12FC 004F                885              MOVE.B  #'O',(A1)+ 
0000175C  12FC 0050                886              MOVE.B  #'P',(A1)+ 
00001760                           887              
00001760  6000 FD12                888              BRA     IDENTIFY_OPCODE
00001764                           889  
00001764                           890  
00001764                           891  *-----------------------------OPC_NOT------------------------------
00001764                           892  
00001764                           893  OPC_NOT:
00001764                           894              * Put NOT into A1 buffer for printing
00001764  12FC 004E                895              MOVE.B  #'N',(A1)+ 
00001768  12FC 004F                896              MOVE.B  #'O',(A1)+
0000176C  12FC 0054                897              MOVE.B  #'T',(A1)+
00001770                           898m             INSERT_PERIOD
00001774                           899              
00001774                           900              * Calculate Size (.b,.w.l)
00001774                           901m             GET_BITS        #7, #6
00001784                           902m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
0000178A                           903m             * GET HIGH BIT OFFSET
00001790                           904m             * SHIFT OUT HIGH BITS
00001796                           905m             *GET LOW BIT OFFSET
00001796                           906m             *16 - NUMBER OF BITS WE WANT
0000179C                           907m             * SHIFT OUT LOW BITS
0000179E  11C4 11A1                908              MOVE.B          D4, opSize
000017A2                           909m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
000017AA                           910m             DECODE_EA       #5, #0
000017C8  6000 FCAA                911              BRA             IDENTIFY_OPCODE
000017CC                           912  
000017CC                           913  *-----------------------------OPC_LEA------------------------------
000017CC                           914  OPC_LEA:
000017CC                           915              * Put LEA into A1 buffer for printing
000017CC  12FC 004C                916              MOVE.B  #'L',(A1)+      
000017D0  12FC 0045                917              MOVE.B  #'E',(A1)+ 
000017D4  12FC 0041                918              MOVE.B  #'A',(A1)+
000017D8                           919m             INSERT_PERIOD
000017DC  12FC 004C                920              MOVE.B  #'L',(A1)+ 
000017E0                           921m             INSERT_SPACE
000017E4                           922  
000017E4  11FC 0002 11A1           923              MOVE.B          #2, opSize      * required to always be long operation
000017EA                           924                      
000017EA                           925m             DECODE_EA       #5, #0
00001808                           926m             INSERT_COMMA
0000180C                           927m             INSERT_SPACE
00001810  4EB9 00001BD8            928              JSR GET_DATA_REG_NUM
00001816                           929  
00001816  6000 FC5C                930              BRA IDENTIFY_OPCODE    
0000181A                           931  
0000181A                           932  
0000181A                           933  *-----------------------------------------------------------
0000181A                           934  
0000181A                           935  *-----------------------------OPC_JSR------------------------------
0000181A                           936  OPC_JSR:
0000181A                           937              * Put LEA into A1 buffer for printing
0000181A  12FC 004A                938              MOVE.B  #'J',(A1)+      
0000181E  12FC 0053                939              MOVE.B  #'S',(A1)+ 
00001822  12FC 0052                940              MOVE.B  #'R',(A1)+
00001826                           941m             INSERT_SPACE
0000182A                           942              
0000182A                           943m             DECODE_EA       #5, #0
00001848  6000 FC2A                944              BRA             IDENTIFY_OPCODE  
0000184C                           945  
0000184C                           946  *-----------------------------OPC_RTS------------------------------
0000184C                           947  OPC_RTS:
0000184C                           948              * Put LEA into A1 buffer for printing
0000184C  12FC 0052                949              MOVE.B  #'R',(A1)+      
00001850  12FC 0054                950              MOVE.B  #'T',(A1)+ 
00001854  12FC 0053                951              MOVE.B  #'S',(A1)+
00001858                           952          
00001858  6000 FC1A                953              BRA IDENTIFY_OPCODE
0000185C                           954  
0000185C                           955  *-----------------------------------------------------------
0000185C                           956  
0000185C                           957  *---------------------------OPC_1000------------------------
0000185C                           958  * First four bits = 1001
0000185C                           959  * (DIVU)
0000185C                           960  *-----------------------------------------------------------
0000185C                           961  OPC_1000:   * keeping this in case there's more that start with 1000
0000185C  6000 0002                962              BRA     OPC_DIVU
00001860                           963              
00001860                           964  OPC_DIVU:
00001860  12FC 0044                965              MOVE.B  #'D',(A1)+
00001864  12FC 0049                966              MOVE.B  #'I',(A1)+
00001868  12FC 0056                967              MOVE.B  #'V',(A1)+
0000186C  12FC 0055                968              MOVE.B  #'U',(A1)+
00001870                           969m             INSERT_PERIOD
00001874  12FC 0057                970              MOVE.B  #'W',(A1)+  * always size word
00001878                           971m             INSERT_SPACE
0000187C                           972  
0000187C  11FC 0001 11A1           973              MOVE.B  #1, opSize
00001882                           974              
00001882                           975              * set the valid bits (since there's only one adressing mode)
00001882  11FC 00BF 11A2           976              MOVE.B  #%10111111, valid
00001888                           977              
00001888  4EF9 00001BA0            978              JMP     EA_TO_D
0000188E                           979  
0000188E                           980  *-----------------------------------------------------------
0000188E                           981  
0000188E                           982  
0000188E                           983  
0000188E                           984  *-----------------------OPC_0101----------------------------
0000188E                           985  * First four bits = 0101
0000188E                           986  * (ADDQ, SUBQ)
0000188E                           987  *-----------------------------------------------------------
0000188E                           988  OPC_0101:
0000188E                           989m             GET_BITS  #8, #8
0000189E                           990m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000018A4                           991m             * GET HIGH BIT OFFSET
000018AA                           992m             * SHIFT OUT HIGH BITS
000018B0                           993m             *GET LOW BIT OFFSET
000018B0                           994m             *16 - NUMBER OF BITS WE WANT
000018B6                           995m             * SHIFT OUT LOW BITS
000018B8                           996              
000018B8                           997              * is the opcode ADDQ?
000018B8  B83C 0000                998              CMP.B     #%0000, D4
000018BC  6700 000E                999              BEQ       OPC_ADDQ
000018C0                          1000  
000018C0                          1001              * is the opcode SUBI?
000018C0  B83C 0001               1002              CMP.B     #%0001, D4
000018C4  6700 001E               1003              BEQ       OPC_SUBQ
000018C8                          1004  
000018C8  4EF8 1530               1005              JMP       BAD_OPCODE
000018CC                          1006  
000018CC                          1007  *------------------------OPC_ADDQ---------------------------
000018CC                          1008  OPC_ADDQ:
000018CC  12FC 0041               1009              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000018D0  12FC 0044               1010              MOVE.B  #'D',(A1)+
000018D4  12FC 0044               1011              MOVE.B  #'D',(A1)+
000018D8  12FC 0051               1012              MOVE.B  #'Q',(A1)+
000018DC                          1013m             INSERT_PERIOD
000018E0                          1014  
000018E0  6100 001A               1015              BSR     DECODE_QUICK
000018E4                          1016  
000018E4                          1017  *------------------------OPC_SUBI---------------------------
000018E4                          1018  OPC_SUBQ:            
000018E4  12FC 0053               1019              MOVE.B  #'S',(A1)+          * Put ADD into Buff
000018E8  12FC 0055               1020              MOVE.B  #'U',(A1)+
000018EC  12FC 0042               1021              MOVE.B  #'B',(A1)+
000018F0  12FC 0051               1022              MOVE.B  #'Q',(A1)+
000018F4                          1023m             INSERT_PERIOD
000018F8                          1024  
000018F8  6100 0002               1025              BSR     DECODE_QUICK
000018FC                          1026  
000018FC                          1027  *------------------Subroutines for OPC_0101-----------------
000018FC                          1028  DECODE_QUICK:            
000018FC                          1029              * Get size of operation and push to buffer
000018FC  4284                    1030              CLR.L           D4
000018FE                          1031m             GET_BITS        #7, #6
0000190E                          1032m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001914                          1033m             * GET HIGH BIT OFFSET
0000191A                          1034m             * SHIFT OUT HIGH BITS
00001920                          1035m             *GET LOW BIT OFFSET
00001920                          1036m             *16 - NUMBER OF BITS WE WANT
00001926                          1037m             * SHIFT OUT LOW BITS
00001928  11C4 11A1               1038              MOVE.B          D4, opSize
0000192C                          1039m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001934                          1040  
00001934                          1041              * push value of #<data> to buffer
00001934  4284                    1042              CLR.L            D4
00001936                          1043m             GET_BITS         #11, #9
00001946                          1044m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001950                          1045m             * GET HIGH BIT OFFSET
00001958                          1046m             * SHIFT OUT HIGH BITS
0000195E                          1047m             *GET LOW BIT OFFSET
0000195E                          1048m             *16 - NUMBER OF BITS WE WANT
00001964                          1049m             * SHIFT OUT LOW BITS
00001966                          1050m             INSERT_POUND
0000196A                          1051m             VALUE_TO_BUFFER  D4
00001972                          1052  
00001972                          1053m             INSERT_COMMA
00001976                          1054m             INSERT_SPACE
0000197A                          1055  
0000197A                          1056              * push <ea> to buffer
0000197A                          1057m             DECODE_EA       #5, #0
00001998  6000 FADA               1058              BRA             IDENTIFY_OPCODE
0000199C                          1059  *-----------------------------------------------------------
0000199C                          1060  
0000199C                          1061  
0000199C                          1062  *-----------------------OPC_0110----------------------------
0000199C                          1063  * First four bits = 0110
0000199C                          1064  * BRA or Bcc condtions
0000199C                          1065  *-----------------------------------------------------------
0000199C                          1066  OPC_0110:
0000199C                          1067m             GET_BITS #12, #8
000019AC                          1068m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019B4                          1069m             * GET HIGH BIT OFFSET
000019BC                          1070m             * SHIFT OUT HIGH BITS
000019C2                          1071m             *GET LOW BIT OFFSET
000019C2                          1072m             *16 - NUMBER OF BITS WE WANT
000019C8                          1073m             * SHIFT OUT LOW BITS
000019CA  B83C 0000               1074              CMP.B   #0,D4 *Check if opcode is BRA
000019CE  6700 0006               1075              BEQ     OPC_BRA
000019D2                          1076              
000019D2  4EF8 1530               1077              JMP     BAD_OPCODE
000019D6                          1078              
000019D6                          1079  OPC_BRA:
000019D6  12FC 0042               1080              MOVE.B  #'B',(A1)+          * Put BRA into Buff
000019DA  12FC 0052               1081              MOVE.B  #'R',(A1)+
000019DE  12FC 0041               1082              MOVE.B  #'A',(A1)+
000019E2  12FC 002E               1083              MOVE.B  #'.',(A1)+
000019E6                          1084              
000019E6                          1085m             GET_BITS #7,#0 *Get displacement bits
000019F6                          1086m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
000019FE                          1087m             * GET HIGH BIT OFFSET
00001A04                          1088m             * SHIFT OUT HIGH BITS
00001A0A                          1089m             *GET LOW BIT OFFSET
00001A0A                          1090m             *16 - NUMBER OF BITS WE WANT
00001A10                          1091m             * SHIFT OUT LOW BITS
00001A12                          1092              
00001A12  B83C 0000               1093              CMP.B   #0,D4 *Check if we have 16 bit dispalcement, branch if true
00001A16  6700 0024               1094              BEQ     BRA_16_BIT_DISPLACEMENT
00001A1A                          1095             
00001A1A  12FC 0042               1096              MOVE.B  #'B',(A1)+
00001A1E                          1097m             INSERT_SPACE 
00001A22  12FC 0024               1098              MOVE.B  #'$',(A1)+
00001A26                          1099              
00001A26  2E0A                    1100              MOVE.L  A2,D7  *Get the current address
00001A28                          1101              
00001A28  4884                    1102              EXT.W   D4 *Sign extend to long for addition
00001A2A  48C4                    1103              EXT.L   D4 *Sign extend again, must extend from byte to word and then word to long
00001A2C  DE84                    1104              ADD.L   D4,D7  *Add the displacement
00001A2E                          1105  
00001A2E  123C 0003               1106              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001A32  4EB9 00001D52           1107              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001A38                          1108              
00001A38  6000 FA3A               1109              BRA IDENTIFY_OPCODE   
00001A3C                          1110              
00001A3C                          1111  BRA_16_BIT_DISPLACEMENT: 
00001A3C  12FC 0057               1112              MOVE.B  #'W',(A1)+
00001A40                          1113m             INSERT_SPACE 
00001A44  12FC 0024               1114              MOVE.B  #'$',(A1)+
00001A48                          1115              
00001A48  2E0A                    1116              MOVE.L  A2,D7  *Get the current address
00001A4A                          1117              
00001A4A  4284                    1118              CLR.L D4 *Clear the contents of D4
00001A4C  381A                    1119              MOVE.W  (A2)+,D4 *Increment A2 to get 16 bit displacement value
00001A4E                          1120              
00001A4E  48C4                    1121              EXT.L   D4  *Sign extend to long for addition
00001A50  DE84                    1122              ADD.L   D4,D7  *Add the displacement 
00001A52                          1123                        
00001A52  123C 0003               1124              MOVE.B  #3,D1  *Move a 3 to print long address - it's a parameter of HEX_TO_ASCII
00001A56  4EB9 00001D52           1125              JSR     HEX_TO_ASCII ;Convert the address to ascii, and add to buffer for printing
00001A5C                          1126              
00001A5C  6000 FA16               1127              BRA IDENTIFY_OPCODE 
00001A60                          1128              
00001A60                          1129  
00001A60                          1130  *-----------------------OPC_1001----------------------------
00001A60                          1131  * First four bits = 1001
00001A60                          1132  * (SUB)
00001A60                          1133  *-----------------------------------------------------------
00001A60                          1134  OPC_1001:
00001A60                          1135              * fill in A1 register
00001A60  12FC 0053               1136              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001A64  12FC 0055               1137              MOVE.B  #'U',(A1)+
00001A68  12FC 0042               1138              MOVE.B  #'B',(A1)+
00001A6C                          1139m             INSERT_PERIOD
00001A70  6000 008E               1140              BRA     PROCESS_ROEA
00001A74                          1141  *-----------------------------------------------------------
00001A74                          1142  
00001A74                          1143  
00001A74                          1144  
00001A74                          1145  *-----------------------OPC_1100----------------------------
00001A74                          1146  * First four bits = 1100
00001A74                          1147  * (AND, MULS)
00001A74                          1148  *-----------------------------------------------------------
00001A74                          1149  OPC_1100:   
00001A74                          1150              ; check to see if bits 8-6 are 111
00001A74                          1151              ; if they are, then branch to PARSE_MULS
00001A74                          1152              ; else, keep going to parse AND
00001A74                          1153  
00001A74                          1154m             GET_BITS #8, #6
00001A84                          1155m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001A8A                          1156m             * GET HIGH BIT OFFSET
00001A90                          1157m             * SHIFT OUT HIGH BITS
00001A96                          1158m             *GET LOW BIT OFFSET
00001A96                          1159m             *16 - NUMBER OF BITS WE WANT
00001A9C                          1160m             * SHIFT OUT LOW BITS
00001A9E  B83C 0007               1161              CMP.B    #%00000111, D4
00001AA2  6700 001A               1162              BEQ      OPC_MULS
00001AA6  6600 0002               1163              BNE      OPC_AND
00001AAA                          1164  
00001AAA                          1165  *---------------------------OPC_AND------------------------
00001AAA                          1166  OPC_AND:    ; AND opcode subroutine
00001AAA                          1167  
00001AAA                          1168              ;-----------------------------
00001AAA                          1169              ; fill A1 with the opcode name
00001AAA  12FC 0041               1170              MOVE.B  #'A',(A1)+
00001AAE  12FC 004E               1171              MOVE.B  #'N',(A1)+
00001AB2  12FC 0044               1172              MOVE.B  #'D',(A1)+
00001AB6                          1173m             INSERT_PERIOD
00001ABA  6000 0044               1174              BRA     PROCESS_ROEA
00001ABE                          1175  
00001ABE                          1176  *---------------------------OPC_MULS------------------------
00001ABE                          1177  OPC_MULS:  * MULS opcode subroutine
00001ABE                          1178  
00001ABE                          1179              * load the command name into the output
00001ABE  12FC 004D               1180              MOVE.B  #'M',(A1)+
00001AC2  12FC 0055               1181              MOVE.B  #'U',(A1)+
00001AC6  12FC 004C               1182              MOVE.B  #'L',(A1)+
00001ACA  12FC 0053               1183              MOVE.B  #'S',(A1)+
00001ACE                          1184m             INSERT_PERIOD
00001AD2  12FC 0057               1185              MOVE.B  #'W',(A1)+ * always size word
00001AD6                          1186m             INSERT_SPACE
00001ADA                          1187  
00001ADA  11FC 0001 11A1          1188              MOVE.B   #1, opSize
00001AE0                          1189              
00001AE0  11FC 00BF 11A2          1190              MOVE.B  #%10111111, valid   * set the valid mode bits (to be used later)
00001AE6                          1191              
00001AE6  4EF9 00001BA0           1192              JMP     EA_TO_D
00001AEC                          1193  *-----------------------------------------------------------
00001AEC                          1194  
00001AEC                          1195  
00001AEC                          1196  *---------------------------opc_1101------------------------
00001AEC                          1197  * First four bits = 1101
00001AEC                          1198  * (ADD)
00001AEC                          1199  *-----------------------------------------------------------
00001AEC                          1200  OPC_1101:
00001AEC                          1201              * fill in A1 register
00001AEC  12FC 0041               1202              MOVE.B  #'A',(A1)+          * Put ADD into Buff
00001AF0  12FC 0044               1203              MOVE.B  #'D',(A1)+
00001AF4  12FC 0044               1204              MOVE.B  #'D',(A1)+
00001AF8                          1205m             INSERT_PERIOD
00001AFC  6000 0002               1206              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
00001B00                          1207  
00001B00                          1208  *-----------------------------------------------------------
00001B00                          1209  
00001B00                          1210  
00001B00                          1211  
00001B00                          1212  
00001B00                          1213  
00001B00                          1214  
00001B00                          1215  
00001B00                          1216  
00001B00                          1217  
00001B00                          1218  
00001B00                          1219  
00001B00                          1220  *--------------Process Register->Opmode->EA-----------------
00001B00                          1221  * Description:
00001B00                          1222  * Parses bits for opcodes that share bit placements:
00001B00                          1223  * ROEA stands for Register, Opmode, and Effective Address,
00001B00                          1224  * because the opcodes below share this bit order.
00001B00                          1225  *
00001B00                          1226  * Used by: (ADD, SUB, MULS)
00001B00                          1227  *
00001B00                          1228  *-----------------------------------------------------------
00001B00                          1229  PROCESS_ROEA:
00001B00                          1230m             GET_BITS        #7, #6              * retrieve size
00001B10                          1231m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B16                          1232m             * GET HIGH BIT OFFSET
00001B1C                          1233m             * SHIFT OUT HIGH BITS
00001B22                          1234m             *GET LOW BIT OFFSET
00001B22                          1235m             *16 - NUMBER OF BITS WE WANT
00001B28                          1236m             * SHIFT OUT LOW BITS
00001B2A  11C4 11A1               1237              MOVE.B          D4, opSize
00001B2E                          1238m             SIZE_TO_BUFFER  D4                  * put operation size in buffer
00001B36                          1239  
00001B36                          1240m             GET_BITS        #8, #8              * retrieve type  
00001B46                          1241m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001B4C                          1242m             * GET HIGH BIT OFFSET
00001B52                          1243m             * SHIFT OUT HIGH BITS
00001B58                          1244m             *GET LOW BIT OFFSET
00001B58                          1245m             *16 - NUMBER OF BITS WE WANT
00001B5E                          1246m             * SHIFT OUT LOW BITS
00001B60  B83C 0001               1247              CMP.B           #1, D4              * is this Dn + <ea> -> <ea>?
00001B64  6700 000A               1248              BEQ             D_TO_EA
00001B68  B83C 0000               1249              CMP.B           #0, D4              * is this <ea> + Dn -> <ea>?
00001B6C  6700 0032               1250              BEQ             EA_TO_D
00001B70                          1251  
00001B70                          1252  D_TO_EA:
00001B70  4EB9 00001BD8           1253              JSR             GET_DATA_REG_NUM
00001B76                          1254m             INSERT_COMMA
00001B7A                          1255m             INSERT_SPACE
00001B7E                          1256m             DECODE_EA       #5, #0
00001B9C  6000 0032               1257              BRA             ROEA_DONE
00001BA0                          1258  
00001BA0                          1259  EA_TO_D:
00001BA0                          1260m             DECODE_EA       #5, #0
00001BBE                          1261m             INSERT_COMMA
00001BC2                          1262m             INSERT_SPACE
00001BC6  4EB9 00001BD8           1263              JSR             GET_DATA_REG_NUM
00001BCC  6000 0002               1264              BRA             ROEA_DONE
00001BD0                          1265  
00001BD0                          1266  ROEA_DONE:
00001BD0                          1267m             INSERT_SPACE
00001BD4  6000 F89E               1268              BRA     IDENTIFY_OPCODE
00001BD8                          1269  
00001BD8                          1270  GET_DATA_REG_NUM:
00001BD8  4284                    1271              CLR.L    D4
00001BDA                          1272m             GET_BITS #11, #9                     * retrieve high data register number
00001BEA                          1273m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001BF4                          1274m             * GET HIGH BIT OFFSET
00001BFC                          1275m             * SHIFT OUT HIGH BITS
00001C02                          1276m             *GET LOW BIT OFFSET
00001C02                          1277m             *16 - NUMBER OF BITS WE WANT
00001C08                          1278m             * SHIFT OUT LOW BITS
00001C0A                          1279  
00001C0A                          1280              * store in appropriate register
00001C0A  12FC 0044               1281              MOVE.B            #'D',(A1)+                  * add "D" to buffer
00001C0E                          1282m             VALUE_TO_BUFFER   D4          
00001C16  4E75                    1283              RTS
00001C18                          1284  *-----------------------------------------------------------
00001C18                          1285  
00001C18                          1286  
00001C18                          1287  
00001C18                          1288  
00001C18                          1289  
00001C18                          1290  
00001C18                          1291  
00001C18                          1292  
00001C18                          1293  
00001C18                          1294  
00001C18                          1295  
00001C18                          1296  
00001C18                          1297  *----------------------EA_TO_BUFFER------------------
00001C18                          1298  * Description:
00001C18                          1299  * Evaluates the ea mode and register of an opcode 
00001C18                          1300  * (usually last 6 bits of instruction format),
00001C18                          1301  * and adds it to A1 to be printed out
00001C18                          1302  *
00001C18                          1303  * No Parameters
00001C18                          1304  *
00001C18                          1305  * Registers Used:
00001C18                          1306  *   D1 = amount to shift the opcode
00001C18                          1307  *   D2 = destination for shifts
00001C18                          1308  *-----------------------------------------------------------
00001C18                          1309  EA_TO_BUFFER:                            
00001C18  0C38 0000 11A3          1310              CMP.B   #%0000, ea_mode        * Direct Data Register
00001C1E  6700 004C               1311              BEQ     EA_000
00001C22                          1312  
00001C22  0C38 0001 11A3          1313              CMP.B   #%0001, ea_mode        * Direct Address Register
00001C28  6700 0052               1314              BEQ     EA_001
00001C2C                          1315  
00001C2C  0C38 0002 11A3          1316              CMP.B   #%0010, ea_mode        * Indirect Address Register
00001C32  6700 0058               1317              BEQ     EA_010
00001C36                          1318  
00001C36  0C38 0003 11A3          1319              CMP.B   #%0011, ea_mode        * Post Increment
00001C3C  6700 0066               1320              BEQ     EA_011
00001C40                          1321  
00001C40  0C38 0004 11A3          1322              CMP.B   #%0100, ea_mode        * Pre Decrement
00001C46  6700 0078               1323              BEQ     EA_100
00001C4A                          1324  
00001C4A  0C38 0005 11A3          1325              CMP.B   #%0101, ea_mode        * Not necessary, go to bad EA
00001C50  6700 008A               1326              BEQ     EA_101
00001C54                          1327  
00001C54  0C38 0006 11A3          1328              CMP.B   #%0110, ea_mode        * Not necessary, go to bad EA
00001C5A  6700 0084               1329              BEQ     EA_110
00001C5E                          1330  
00001C5E  0C38 0007 11A3          1331              CMP.B   #%0111, ea_mode        * Absolute or immediate address
00001C64  6700 007E               1332              BEQ     EA_111
00001C68                          1333  
00001C68  6000 00E2               1334              BRA    INVALID_EA
00001C6C                          1335  
00001C6C                          1336  *----------------------------Direct Data Register------------------------
00001C6C                          1337  EA_000:
00001C6C  12FC 0044               1338              MOVE.B      #'D',(A1)+              * add "D" to buffer
00001C70  0638 0030 11A4          1339              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001C76  12F8 11A4               1340              MOVE.B      ea_register, (A1)+      * register # to buffer                  
00001C7A  4E75                    1341              RTS                                
00001C7C                          1342  
00001C7C                          1343  *----------------------------Direct Address Register------------------------
00001C7C                          1344  EA_001:
00001C7C  12FC 0041               1345              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001C80  0638 0030 11A4          1346              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001C86  12F8 11A4               1347              MOVE.B      ea_register, (A1)+      * register # to buffer               
00001C8A  4E75                    1348              RTS                            
00001C8C                          1349  
00001C8C                          1350  *----------------------------Indirect Address Register------------------------
00001C8C                          1351  EA_010:
00001C8C  12FC 0028               1352              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001C90  12FC 0041               1353              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001C94  0638 0030 11A4          1354              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001C9A  12F8 11A4               1355              MOVE.B      ea_register, (A1)+      * register # to buffer     
00001C9E  12FC 0029               1356              MOVE.B      #')',(A1)+              * add ")" to buffer
00001CA2  4E75                    1357              RTS                            
00001CA4                          1358  
00001CA4                          1359  *----------------------------Post Increment------------------------
00001CA4                          1360  EA_011:
00001CA4  12FC 0028               1361              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001CA8  12FC 0041               1362              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001CAC  0638 0030 11A4          1363              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001CB2  12F8 11A4               1364              MOVE.B      ea_register, (A1)+      * register # to buffer 
00001CB6  12FC 0029               1365              MOVE.B      #')',(A1)+              * add ")" to buffer
00001CBA  12FC 002B               1366              MOVE.B      #'+',(A1)+              * add "+" to buffer 
00001CBE  4E75                    1367              RTS                              
00001CC0                          1368  
00001CC0                          1369  *----------------------------Pre Decrement------------------------
00001CC0                          1370  EA_100:
00001CC0  12FC 002D               1371              MOVE.B      #'-',(A1)+              * add "-" to buffer
00001CC4  12FC 0028               1372              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001CC8  12FC 0041               1373              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001CCC  0638 0030 11A4          1374              ADD.B       #$30, ea_register       * convert data register # to ASCII digit
00001CD2  12F8 11A4               1375              MOVE.B      ea_register, (A1)+      * register # to buffer 
00001CD6  12FC 0029               1376              MOVE.B      #')',(A1)+              * add ")" to buffer
00001CDA  4E75                    1377              RTS
00001CDC                          1378  
00001CDC                          1379  *----------------------------Not necessary, go to bad EA------------------------
00001CDC                          1380  EA_101:
00001CDC  6000 006E               1381              BRA         INVALID_EA        
00001CE0                          1382  
00001CE0                          1383  *----------------------------Not necessary, go to bad EA------------------------
00001CE0                          1384  EA_110:
00001CE0  6000 006A               1385              BRA         INVALID_EA        
00001CE4                          1386  
00001CE4                          1387  *----------------------------Absolute or immediate address------------------------
00001CE4                          1388  EA_111:
00001CE4                          1389              * D405      0 0003456  23345245
00001CE4                          1390              * ADD.L     $1234, D0
00001CE4                          1391  
00001CE4                          1392              * 8 bit value
00001CE4                          1393              * 11111111
00001CE4                          1394  
00001CE4                          1395              * 11111011 - Direct data register would be Invalid
00001CE4                          1396              * 00000100
00001CE4                          1397              * 00000000 -> invalid code
00001CE4                          1398  
00001CE4                          1399              * and.b     #$F, Dn        ---->  10000000
00001CE4                          1400              * cmp.b     #%10000000, Dn  
00001CE4                          1401  
00001CE4                          1402              * check against valid bits
00001CE4                          1403                  * if invalid, branch to invalid opcode subroutine
00001CE4                          1404                      * if the mode is 111, then go back and print out addresses
00001CE4                          1405  
00001CE4  0C38 0000 11A4          1406              CMP.B       #%000, ea_register                * compare to determine if it's a word
00001CEA  6700 001A               1407              BEQ         EA_WORD                  * put word address in buffer
00001CEE                          1408  
00001CEE  0C38 0001 11A4          1409              CMP.B       #%001, ea_register                * compare to determine if it's a long
00001CF4  6700 0024               1410              BEQ         EA_LONG                  * put long address in buffer
00001CF8                          1411              
00001CF8  0C38 0004 11A4          1412              CMP.B       #%100, ea_register
00001CFE  6700 002E               1413              BEQ         EA_IMMEDIATE             * always print a long if it's immediate data
00001D02                          1414  
00001D02                          1415              * Invalid EA mode/register
00001D02  6000 0048               1416              BRA         INVALID_EA
00001D06                          1417  
00001D06                          1418  EA_WORD:
00001D06  12FC 0024               1419              MOVE.B      #'$', (A1)+
00001D0A  4281                    1420              CLR.L       D1
00001D0C  123C 0001               1421              MOVE.B      #1, D1
00001D10  3E1A                    1422              MOVE.W      (A2)+, D7
00001D12  6100 003E               1423              BSR         HEX_TO_ASCII
00001D16  6000 0032               1424              BRA         GET_EA_DONE
00001D1A                          1425  
00001D1A                          1426  EA_LONG:
00001D1A  12FC 0024               1427              MOVE.B      #'$', (A1)+
00001D1E  4281                    1428              CLR.L       D1
00001D20  123C 0003               1429              MOVE.B      #3, D1
00001D24  2E1A                    1430              MOVE.L      (A2)+, D7   
00001D26  6100 002A               1431              BSR         HEX_TO_ASCII
00001D2A  6000 001E               1432              BRA         GET_EA_DONE
00001D2E                          1433  
00001D2E                          1434  EA_IMMEDIATE:
00001D2E  12FC 0023               1435              MOVE.B      #'#', (A1)+
00001D32                          1436  
00001D32  0C38 0000 11A1          1437              CMP.B       #0, opSize          
00001D38  67CC                    1438              BEQ         EA_WORD
00001D3A                          1439  
00001D3A  0C38 0001 11A1          1440              CMP.B       #1, opSize          
00001D40  67C4                    1441              BEQ         EA_WORD          
00001D42                          1442              
00001D42  0C38 0002 11A1          1443              CMP.B       #2, opSize
00001D48  60D0                    1444              BRA         EA_LONG             
00001D4A                          1445  
00001D4A                          1446  GET_EA_DONE:
00001D4A  4E75                    1447              RTS
00001D4C                          1448  
00001D4C                          1449  *------------------Invalid Effective Address----------------
00001D4C                          1450  INVALID_EA:
00001D4C  4EF9 00001DF8           1451              JMP      DONE
00001D52                          1452  *-----------------------------------------------------------
00001D52                          1453  
00001D52                          1454  
00001D52                          1455  
00001D52                          1456  
00001D52                          1457  
00001D52                          1458  
00001D52                          1459  
00001D52                          1460  
00001D52                          1461  
00001D52                          1462  *----------------------HEX TO ASCII-------------------------
00001D52                          1463  * Description:
00001D52                          1464  * Converts a Hex numbered address (1-9 or A-F) back to an
00001D52                          1465  * ASCII value for printing
00001D52                          1466  *
00001D52                          1467  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
00001D52                          1468  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
00001D52                          1469  *   D7 = holds the original address to parse (either word or long, for example: $7000)
00001D52                          1470  *
00001D52                          1471  *
00001D52                          1472  * Registers Used:
00001D52                          1473  *   D0 = number of bits to remove
00001D52                          1474  *   D2 = holds either top four bits or bottom four bits of each byte in D6
00001D52                          1475  *   D3 = holds temp data
00001D52                          1476  *   D6 = holds part of address (used as temp variable)
00001D52                          1477  *   A1 = used for buffer
00001D52                          1478  *-----------------------------------------------------------
00001D52                          1479  HEX_TO_ASCII:
00001D52  1001                    1480              MOVE.B   D1, D0             * current number of bytes to remove
00001D54  C1FC 0008               1481              MULS.W   #8, D0             * number of bits to remove
00001D58                          1482  
00001D58  2C07                    1483              MOVE.L   D7, D6             * load original address to parse
00001D5A  E0AE                    1484              LSR.L    D0, D6             * remove lowest byte(s)
00001D5C                          1485  
00001D5C                          1486              * isolate first four bits
00001D5C  1406                    1487              MOVE.B   D6, D2
00001D5E  E80A                    1488              LSR.B    #4, D2 
00001D60  6100 0018               1489              BSR      NUMBER_OR_LETTER
00001D64                          1490  
00001D64                          1491              * isolate second set of four bits
00001D64  1406                    1492              MOVE.B   D6, D2
00001D66  E90A                    1493              LSL.B    #4, D2 
00001D68  E80A                    1494              LSR.B    #4, D2 
00001D6A  6100 000E               1495              BSR      NUMBER_OR_LETTER
00001D6E                          1496  
00001D6E  5301                    1497              SUB.B    #1, D1             * iterate
00001D70  B23C 0000               1498              CMP.B    #0, D1             * done if equal
00001D74  6D00 0036               1499              BLT      ATH_DONE
00001D78                          1500  
00001D78  60D8                    1501              BRA      HEX_TO_ASCII
00001D7A                          1502  
00001D7A                          1503  NUMBER_OR_LETTER:
00001D7A  1602                    1504              MOVE.B   D2, D3
00001D7C  0603 0030               1505              ADD.B    #$30, D3           
00001D80  B63C 0039               1506              CMP.B    #$39, D3           * is byte in D2 a number?
00001D84  6F00 0012               1507              BLE      NUMBER_TO_ASCII
00001D88                          1508              
00001D88  1602                    1509              MOVE.B   D2, D3
00001D8A  0603 0037               1510              ADD.B    #$37, D3           
00001D8E  B63C 0039               1511              CMP.B    #$39, D3           * is byte in D2 a letter?
00001D92  6C00 000C               1512              BGE      LETTER_TO_ASCII
00001D96                          1513  
00001D96  60B4                    1514              BRA      INVALID_EA
00001D98                          1515  
00001D98                          1516  NUMBER_TO_ASCII:
00001D98  0602 0030               1517              ADD.B    #$30, D2           * Get the hex range from '0-9'
00001D9C  6000 000A               1518              BRA      ADD_TO_BUFFER
00001DA0                          1519  
00001DA0                          1520  LETTER_TO_ASCII:
00001DA0  0602 0037               1521              ADD.B    #$37, D2           * Get the hex range from 'A-F'
00001DA4  6000 0002               1522              BRA      ADD_TO_BUFFER
00001DA8                          1523  
00001DA8                          1524  ADD_TO_BUFFER:
00001DA8  12C3                    1525              MOVE.B   D3, (A1)+          * add part of address to buffer    
00001DAA  4E75                    1526              RTS
00001DAC                          1527  
00001DAC                          1528  ATH_DONE:
00001DAC                          1529m             CLR_D_REGS
00001DBC  4E75                    1530              RTS
00001DBE                          1531  *-----------------------------------------------------------
00001DBE                          1532  
00001DBE                          1533  
00001DBE                          1534  
00001DBE                          1535  
00001DBE                          1536  
00001DBE                          1537  
00001DBE                          1538  
00001DBE                          1539  
00001DBE                          1540  
00001DBE                          1541  *---------------------SIZE TO BUFFER------------------------
00001DBE                          1542  * Description:
00001DBE                          1543  * Evaluates the size of an opcode and adds it to A1 to be printed out
00001DBE                          1544  *
00001DBE                          1545  * Parameters:
00001DBE                          1546  *   D3 = size of opcode
00001DBE                          1547  *
00001DBE                          1548  * Registers Used:
00001DBE                          1549  *   A1: adding words/numbers to buffer
00001DBE                          1550  *-----------------------------------------------------------
00001DBE                          1551  FIND_SIZE: 
00001DBE  B63C 0000               1552              CMP.B   #%0000,D3            
00001DC2  6700 0016               1553              BEQ     BYTE_TO_BUFFER              
00001DC6                          1554  
00001DC6  B63C 0001               1555              CMP.B   #%0001,D3             * is this a word?
00001DCA  6700 0016               1556              BEQ     WORD_TO_BUFFER
00001DCE                          1557  
00001DCE  B63C 0002               1558              CMP.B   #%0010,D3             * is this a long?
00001DD2  6700 0016               1559              BEQ     LONG_TO_BUFFER             
00001DD6                          1560        
00001DD6  4EF8 1530               1561              JMP     BAD_OPCODE  
00001DDA                          1562              
00001DDA                          1563  BYTE_TO_BUFFER:
00001DDA  12FC 0042               1564              MOVE.B  #'B', (A1)+           * add B to buffer
00001DDE  6000 0012               1565              BRA     STB_END             
00001DE2                          1566              
00001DE2                          1567  WORD_TO_BUFFER:
00001DE2  12FC 0057               1568              MOVE.B  #'W', (A1)+          * add W to buffer
00001DE6  6000 000A               1569              BRA     STB_END             
00001DEA                          1570  
00001DEA                          1571  LONG_TO_BUFFER:
00001DEA  12FC 004C               1572              MOVE.B  #'L',(A1)+          * add L to buffer
00001DEE  6000 0002               1573              BRA     STB_END             
00001DF2                          1574  
00001DF2                          1575  STB_END:
00001DF2  12FC 0020               1576              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001DF6  4E75                    1577              RTS                         
00001DF8                          1578  *-----------------------------------------------------------
00001DF8                          1579  
00001DF8                          1580  
00001DF8                          1581  
00001DF8                          1582  
00001DF8                          1583  
00001DF8                          1584  
00001DF8                          1585  *-------------------------DONE-------------------------------
00001DF8                          1586  DONE:
00001DF8                          1587m             CLR_A_REG D0, A1
00001DFC                          1588  
00001DFC                          1589              * add 'SIMHAULT' to buffer
00001DFC  12FC 0053               1590              MOVE.B  #'S',(A1)+      
00001E00  12FC 0049               1591              MOVE.B  #'I',(A1)+         
00001E04  12FC 004D               1592              MOVE.B  #'M',(A1)+         
00001E08  12FC 0048               1593              MOVE.B  #'H',(A1)+        
00001E0C  12FC 0041               1594              MOVE.B  #'A',(A1)+                 
00001E10  12FC 004C               1595              MOVE.B  #'L',(A1)+          
00001E14  12FC 0054               1596              MOVE.B  #'T',(A1)+         
00001E18  12FC 0000               1597              MOVE.B  #00,(A1)+         
00001E1C                          1598  
00001E1C                          1599m             CLR_A_REG D0, A1
00001E20                          1600              
00001E20                          1601              * print out string
00001E20  103C 000E               1602              MOVE.B    #14, D0
00001E24  4E4F                    1603              TRAP      #15
00001E26                          1604              
00001E26                          1605m             CLR_A_REG D0, A1
00001E2A                          1606  
00001E2A                          1607  
00001E2A                          1608              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       1DA8
ATH_DONE            1DAC
BADINPUT            117A
BAD_OPCODE          1530
BRA_16_BIT_DISPLACEMENT  1A3C
BYTE_TO_BUFFER      1DDA
CHECK_ADDRESS       1332
CHECK_IMMEDIATE     160E
CHECK_LENGTH        1312
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      1362
CR                  D
DECODE_11_TO_6      1218
DECODE_6_TO_0       11B6
DECODE_EA           57B
DECODE_EA_HELP      11A6
DECODE_IMMEDIATE    15A8
DECODE_MOVE         16B0
DECODE_QUICK        18FC
DONE                1DF8
DONEMSG             116D
D_TO_EA             1B70
EA_000              1C6C
EA_001              1C7C
EA_010              1C8C
EA_011              1CA4
EA_100              1CC0
EA_101              1CDC
EA_110              1CE0
EA_111              1CE4
EA_END              127A
EA_IMMEDIATE        1D2E
EA_LONG             1D1A
EA_MODE             11A3
EA_REGISTER         11A4
EA_TO_BUFFER        1C18
EA_TO_D             1BA0
EA_VALID            11A5
EA_WORD             1D06
ENDADDR             119A
ENDMSG              114A
FIND_OPCODE         14BE
FIND_SIZE           1DBE
FINISH_PRINT        140A
GET_ADDRESS         12FE
GET_BITS            1C5
GET_DATA_REG_NUM    1BD8
GET_EA_DONE         1D4A
GET_EA_MODE         613
GET_EA_REG          675
GET_INPUT           12C4
GRAB_FIRST_FOUR_BITS  14AC
GRAB_NEXT_WORD      14A6
HEX_TO_ASCII        1D52
IDENTIFY_OPCODE     1474
IMMEDIATE_LONG      162A
IMMEDIATE_WORD      1622
INSERT_COMMA        73A
INSERT_DOLLAR       857
INSERT_PERIOD       799
INSERT_POUND        7F8
INSERT_SPACE        6DB
INVALID_ADDRESS     1352
INVALID_EA          1D4C
INVALID_INPUT       1324
ITERATE             1396
LETTER_TO_ASCII     1DA0
LETTER_TO_HEX       1388
LF                  A
LOAD_ADDRESSES      144E
LONG_TO_BUFFER      1DEA
MAIN                127C
NEWLINE             118A
NUMBER_OR_LETTER    1D7A
NUMBER_TO_ASCII     1D98
NUM_TO_HEX          1380
OPCODE              119E
OPC_0000            1536
OPC_0001            1632
OPC_0010            165C
OPC_0011            1686
OPC_0100            16F6
OPC_0101            188E
OPC_0110            199C
OPC_1000            185C
OPC_1001            1A60
OPC_1100            1A74
OPC_1101            1AEC
OPC_ADDI            1578
OPC_ADDQ            18CC
OPC_AND             1AAA
OPC_BRA             19D6
OPC_DIVU            1860
OPC_JSR             181A
OPC_LEA             17CC
OPC_MULS            1ABE
OPC_NOP             1754
OPC_NOT             1764
OPC_RTS             184C
OPC_SUBI            1590
OPC_SUBQ            18E4
OPSIZE              11A1
OPTAG               11A0
PRINT_ADDRESS       13A8
PRINT_INSTRUCTION   1430
PRINT_LONG          13F0
PRINT_MSG           0
PRINT_WORD          13D6
PROCESS_ROEA        1B00
RESTORE_REGS        14A0
ROEA_DONE           1BD0
RULE1               1000
RULE1C              1038
RULE2               1059
RULE3               109B
RULE3C              10DD
SIZE_TO_BUFFER      51C
STARTADDR           1196
STARTMSG            1125
STB_END             1DF2
STORE_CHAR          1390
STORE_INPUT         13A4
USERADDR            118E
VALID               11A2
VALUE_TO_BUFFER     4B4
WORD_TO_BUFFER      1DE2
