0000107E Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 5/4/2021 1:09:46 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :DASM
00000000                             3  * Written by :Lucas Buckeye, Brendan Hurt, Zach Shim
00000000                             4  * Date       :4.19.21
00000000                             5  * Description:v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  *-----------------------------------------------------------
00000000                             9  * Directives:
00000000                            10  *-----------------------------------------------------------
00007000                            11              ORG     $7000
00007000  C401                      12              AND.B   D1, D2
00007002                            13  
00001000                            14              ORG     $1000
00001000                            15  
00001000= 50 6C 65 61 73 65 ...     16  startMsg:   DC.B    'Please enter a starting address ', CR, LF, 0
00001023= 50 6C 65 61 73 65 ...     17  endMsg:     DC.B    'Please enter an ending address ', CR, LF, 0
00001045= 65 78 69 74 69 6E ...     18  doneMsg:    DC.B    'exiting...', CR, LF, 0
00001052= 49 6E 76 61 6C 69 ...     19  badInput:   DC.B    'Invalid Input', CR, LF, 0
00001062= 0D 0A 00                  20  newline:    DC.B    '', CR, LF, 0
00001065                            21  
00001066                            22  userAddr:   DS.L    1
0000106A                            23  startAddr:  DS.L    1
0000106E                            24  endAddr:    DS.L    1
00001072                            25  
00001072                            26  opOutput:   DS.L    2
0000107A                            27  
0000107A                            28  opcode:     DS.W    1   
0000107C                            29  opTag:      DS.B    1               ; a four bit identifier for opcodes (first four bits of an instruction, ex. 1011 = ADD)
0000107D                            30  valid:      DS.B    1
0000107E                            31  
0000107E                            32  
0000107E                            33  
0000107E                            34  
0000107E                            35  
0000107E                            36  
0000107E                            37  *-----------------------------------------------------------
0000107E                            38  * Macros:
0000107E                            39  *-----------------------------------------------------------
0000107E                            40  
0000107E                            41  PRINT_MSG:  MACRO 
0000107E                            42              CLR.L   D0
0000107E                            43              LEA     \1, A1      ; \1 acts as a parameter
0000107E                            44              MOVE.B  #14, D0     
0000107E                            45              TRAP    #15
0000107E                            46              ENDM
0000107E                            47  
0000107E                            48  CLR_D_REGS: MACRO
0000107E                            49              CLR.L   D0
0000107E                            50              CLR.L   D1
0000107E                            51              CLR.L   D2
0000107E                            52              CLR.L   D3
0000107E                            53              CLR.L   D4
0000107E                            54              CLR.L   D5
0000107E                            55              CLR.L   D6
0000107E                            56              CLR.L   D7
0000107E                            57              ENDM
0000107E                            58  
0000107E                            59  CLR_A_REG:  MACRO
0000107E                            60              CLR.L   \1
0000107E                            61              MOVE.L  \1, \2
0000107E                            62              ENDM              
0000107E                            63  
0000107E                            64  *-----------------------------------------------------------
0000107E                            65  * \1 should be highest bit in range
0000107E                            66  * \2 should be lowest bit in range
0000107E                            67  * Result will be returned in D4
0000107E                            68  * Example: #11, #9
0000107E                            69  * 
0000107E                            70  *
0000107E                            71  * Registers:
0000107E                            72  *   D4 = holds opcode
0000107E                            73  *   D5 = highest bit in range 
0000107E                            74  *   D6 = lowest bit in range 
0000107E                            75  *   D7 = number of bits we want
0000107E                            76  *-----------------------------------------------------------
0000107E                            77  GET_BITS:   MACRO
0000107E                            78              * Subtract value to find amount to shift by 
0000107E                            79              ADD.B   \1, D7          
0000107E                            80              SUB.B   \2, D7 
0000107E                            81              ADD.B   #1, D7  * add 1 because we start our count from 0
0000107E                            82  
0000107E                            83              * Get high bit offset
0000107E                            84              ADD.B   #15, D5
0000107E                            85              SUB.B   \1, D5
0000107E                            86              
0000107E                            87              * shift out high bits
0000107E                            88              MOVE.W  opcode, D4
0000107E                            89              LSL.W   D5, D4
0000107E                            90              
0000107E                            91              *get low bit offset
0000107E                            92              *16 - NUMBER OF BITS WE WANT
0000107E                            93              ADD.B   #16, D6         * 16 total bits
0000107E                            94              SUB.L   D7, D6          * subtract numBits from 16
0000107E                            95              
0000107E                            96              * shift out low bits
0000107E                            97              LSR.W   D6, D4          * isolate bits
0000107E                            98              ENDM
0000107E                            99  
0000107E                           100  
0000107E                           101  *-----------------------------------------------------------
0000107E                           102  * Description:  
0000107E                           103  * Main routine
0000107E                           104  *-----------------------------------------------------------
0000107E                           105  
0000107E                           106  *-------------------------MAIN------------------------------
0000107E                           107  MAIN:
0000107E  6100 0006                108              BSR     GET_INPUT
00001082  6000 01C8                109              BRA     LOAD_ADDRESSES
00001086                           110  *-----------------------------------------------------------
00001086                           111  
00001086                           112  
00001086                           113  
00001086                           114  
00001086                           115  
00001086                           116  
00001086                           117  
00001086                           118  
00001086                           119  *-----------------------------------------------------------
00001086                           120  * Description:  
00001086                           121  * Get User Input
00001086                           122  *
00001086                           123  * Registers Used:
00001086                           124  *   D0 = task values
00001086                           125  *   D1 = stores of size of ascii string in A1 from user input
00001086                           126  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
00001086                           127  *   A1 = stores an ascii string from user input
00001086                           128  *-----------------------------------------------------------
00001086                           129  *-------------------------Get Input-------------------------
00001086                           130  GET_INPUT:
00001086  B87C 0000                131              CMP      #0, D4
0000108A  6700 000C                132              BEQ      GET_START_ADDRESS
0000108E                           133                 
0000108E  21C6 106A                134              MOVE.L   D6, startAddr
00001092  21C7 106E                135              MOVE.L   D7, endAddr
00001096  4E75                     136              RTS 
00001098                           137  *-----------------------------------------------------------
00001098                           138  
00001098                           139  *----------------------Get Starting Address-----------------
00001098                           140  GET_START_ADDRESS:
00001098  4280                     141              CLR.L   D0
0000109A  43F8 1000                142              LEA.L   startMsg, A1      
0000109E  103C 000E                143              MOVE.B  #14, D0     
000010A2  4E4F                     144              TRAP    #15
000010A4                           145  
000010A4  43F8 1066                146              LEA.L   userAddr, A1
000010A8  103C 0002                147              MOVE.B  #2, D0
000010AC  4E4F                     148              TRAP    #15
000010AE                           149              ;MOVE.B  D1, startSize
000010AE  6000 001C                150              BRA     VALIDATE_INPUT
000010B2                           151  *-----------------------------------------------------------
000010B2                           152  
000010B2                           153  *----------------------Get Ending Address-------------------
000010B2                           154  GET_END_ADDRESS:
000010B2  4280                     155              CLR.L   D0
000010B4  43F8 1023                156              LEA.L   endMsg, A1      
000010B8  103C 000E                157              MOVE.B  #14, D0     
000010BC  4E4F                     158              TRAP    #15
000010BE                           159  
000010BE  43F8 1066                160              LEA.L   userAddr, A1
000010C2  103C 0002                161              MOVE.B  #2, D0
000010C6  4E4F                     162              TRAP    #15
000010C8                           163              ;MOVE.B  D1, endSize
000010C8  6000 0012                164              BRA     CHECK_LENGTH
000010CC                           165  *-----------------------------------------------------------
000010CC                           166  
000010CC                           167  
000010CC                           168  
000010CC                           169  
000010CC                           170  
000010CC                           171  
000010CC                           172  
000010CC                           173  
000010CC                           174  
000010CC                           175  
000010CC                           176  *-----------------------------------------------------------
000010CC                           177  * Description:  Validate User Input
000010CC                           178  * Constraints:  
000010CC                           179  *   User input must be:
000010CC                           180  *   Length 4 or Length 8
000010CC                           181  *   ASCII character 0-9 or A-F
000010CC                           182  *   Starting and ending address with value < $00FFFFFF 
000010CC                           183  *   Starting address is before ending address
000010CC                           184  *
000010CC                           185  * Registers Used:
000010CC                           186  *   D0 = task values
000010CC                           187  *   D1 = stores of size of ascii string in A1 from user input
000010CC                           188  *   D4 = bool check (0 = starting address, 1 = ending address, 2 = done)
000010CC                           189  *   A1 = stores an ascii string from user input
000010CC                           190  *-----------------------------------------------------------
000010CC                           191  
000010CC                           192  *----------------------VALIDATE INPUT---------------------------      
000010CC                           193  
000010CC                           194  VALIDATE_INPUT:        
000010CC  B83C 0000                195              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
000010D0  6700 000A                196              BEQ        CHECK_LENGTH         ; if equal, parse START address 
000010D4  B83C 0001                197              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
000010D8  67D8                     198              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
000010DA  60AA                     199              BRA        GET_INPUT            ; done parsing, D4 = 2
000010DC                           200  
000010DC                           201  CHECK_LENGTH:
000010DC  B23C 0004                202              CMP.B      #4, D1               ; for task 2, length of string is in D1                
000010E0  6700 002C                203              BEQ        CONVERT_TO_HEX 
000010E4  B23C 0008                204              CMP.B      #8, D1               ; address can either be 4 or 8 bits in length  
000010E8  6700 0024                205              BEQ        CONVERT_TO_HEX
000010EC  6000 0002                206              BRA        INVALID_INPUT
000010F0                           207  
000010F0                           208  INVALID_INPUT:  
000010F0  4283                     209              CLR.L      D3
000010F2                           210m             PRINT_MSG  badInput
000010FE  B83C 0000                211              CMP.B      #0, D4 
00001102  6794                     212              BEQ        GET_START_ADDRESS  
00001104  B83C 0001                213              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
00001108  67A8                     214              BEQ        GET_END_ADDRESS      ; if equal, parse ENDING address  
0000110A  6000 FF72                215              BRA        MAIN
0000110E                           216  *-----------------------------------------------------------
0000110E                           217  
0000110E                           218  *----------------CONVERT FROM ASCII TO HEX------------------
0000110E                           219  CONVERT_TO_HEX:
0000110E  0C11 0030                220              CMP.B      #$30, (A1)           ; check if input is a number (lower range) - check ascii table for reference
00001112  6DDC                     221              BLT        INVALID_INPUT        
00001114                           222  
00001114  0C11 003A                223              CMP.B      #$3A,(A1)            ; check if input is a number (upper range)
00001118  6D00 0012                224              BLT        NUM_TO_HEX      
0000111C                           225  
0000111C  0C11 0041                226              CMP.B      #$41, (A1)           ; check if input is a letter (lower range)
00001120  6DCE                     227              BLT        INVALID_INPUT             
00001122                           228  
00001122  0C11 0047                229              CMP.B      #$47,(A1)            ; check if input is a number (upper range)
00001126  6D00 000C                230              BLT        LETTER_TO_HEX
0000112A                           231  
0000112A  60C4                     232              BRA        INVALID_INPUT    
0000112C                           233  
0000112C                           234  NUM_TO_HEX:      
0000112C  0411 0030                235              SUB.B      #$30, (A1)          ; subtract 30 to get a number 
00001130  6000 000A                236              BRA        STORE_CHAR   
00001134                           237  
00001134                           238  LETTER_TO_HEX:     
00001134  0411 0037                239              SUB.B      #$37, (A1)          ; subtract 37 to get a letter
00001138  6000 0002                240              BRA        STORE_CHAR
0000113C                           241  
0000113C                           242  STORE_CHAR:       
0000113C  D619                     243              ADD.B     (A1)+, D3            ; keep hex stored in D3           
0000113E  6000 0002                244              BRA        ITERATE                 
00001142                           245  
00001142                           246  ITERATE:
00001142  5301                     247              SUB.B      #$1, D1
00001144  B23C 0000                248              CMP.B      #0, D1
00001148  6700 0006                249              BEQ        STORE_INPUT
0000114C                           250  
0000114C  E98B                     251              LSL.L      #4, D3               ; shift D3 contents left by 4 to receive next input
0000114E  60BE                     252              BRA        CONVERT_TO_HEX
00001150                           253  
00001150                           254  STORE_INPUT:
00001150  B83C 0000                255              CMP.B      #0, D4               ; D4 = 0 if start and end address have not been parsed
00001154  6700 000A                256              BEQ        STORE_START          ; if equal, parse START address 
00001158                           257              
00001158  B83C 0001                258              CMP.B      #1, D4               ; D4 = 1 if start has been parsed but not end address
0000115C  6700 0022                259              BEQ        STORE_END         
00001160                           260  
00001160                           261  STORE_START:
00001160  2C03                     262              MOVE.L     D3, D6
00001162  5204                     263              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001164                           264              ;CLR        D3
00001164                           265              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001164                           266  
00001164                           267              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001164  4281                     268              CLR.L       D1
00001166  2203                     269              MOVE.L      D3, D1   
00001168  103C 0003                270              MOVE.B      #3, D0     
0000116C  4E4F                     271              TRAP        #15
0000116E                           272m             PRINT_MSG   newline
0000117A                           273              
0000117A  4243                     274              CLR         D3
0000117C  6000 FF4E                275              BRA         VALIDATE_INPUT
00001180                           276  
00001180                           277  STORE_END:
00001180  2E03                     278              MOVE.L     D3, D7
00001182  5204                     279              ADD.B      #1, D4               ; value to indicate if we are done parsing
00001184                           280              ;CLR        D3
00001184                           281              ;BRA       VALIDATE_INPUT       ; UNCOMMENT WHEN TAKING OUT TEST CODE BELOW
00001184                           282  
00001184                           283              ; USED FOR TESTING - MAKE SURE OUTPUT IS CORRECT
00001184  4281                     284              CLR.L       D1
00001186  2203                     285              MOVE.L      D3, D1   
00001188  103C 0003                286              MOVE.B      #3, D0     
0000118C  4E4F                     287              TRAP        #15
0000118E                           288m             PRINT_MSG   newline
0000119A                           289  
0000119A  4243                     290              CLR         D3
0000119C  6000 FF2E                291              BRA         VALIDATE_INPUT
000011A0                           292  *-----------------------------------------------------------
000011A0                           293  
000011A0                           294  
000011A0                           295  
000011A0                           296  
000011A0                           297  
000011A0                           298  
000011A0                           299  
000011A0                           300  
000011A0                           301  
000011A0                           302  
000011A0                           303  
000011A0                           304  *--------------------------PRINT----------------------------
000011A0                           305  * Description:
000011A0                           306  * Prints hex addresses according to where we are in the .S file
000011A0                           307  * and source/destination effective addresses
000011A0                           308  *
000011A0                           309  * No Parameters
000011A0                           310  *
000011A0                           311  * Registers:
000011A0                           312  *   D0 = used for tasks and trap #15
000011A0                           313  *   D1 = size of comparison
000011A0                           314  *   D2 = destination for comparisons, holds an address
000011A0                           315  *   D3 = iterator
000011A0                           316  *   A1 = used for task 14 (printing out strings to screen) and trap #15
000011A0                           317  *   A2 = current address (given by user)
000011A0                           318  *-----------------------------------------------------------
000011A0                           319  
000011A0                           320  *----------------------PRINT_ADDRESS------------------------
000011A0                           321  PRINT_ADDRESS:
000011A0                           322              * reset A1 to beginning of string
000011A0                           323m             CLR_D_REGS
000011B0                           324m             CLR_A_REG D0, A1
000011B4                           325              
000011B4                           326              * move current address to D2
000011B4  240A                     327              MOVE.L    A2, D2
000011B6                           328  
000011B6                           329              * if absolute short, print word. Range $0000 - $7FFF and $FFFF8000 - $FFFFFFFF
000011B6  223C 00008000            330              MOVE.L    #$8000, D1
000011BC  B481                     331              CMP.L     D1, D2
000011BE  6D00 000E                332              BLT       PRINT_WORD
000011C2                           333              
000011C2                           334              * if absolute long, print long. Range $8000 - $FFFF7FFF
000011C2  223C FFFF8000            335              MOVE.L    #$FFFF8000, D1
000011C8  B481                     336              CMP.L     D1, D2
000011CA  6C00 0022                337              BGE       PRINT_LONG                 
000011CE                           338  
000011CE                           339  PRINT_WORD:
000011CE                           340m             CLR_D_REGS
000011DE  123C 0001                341              MOVE.B    #1, D1            * passing 1 means we are passing word as a parameter to HEX_TO_ASCII
000011E2  3E0A                     342              MOVE.W    A2, D7            * passing current parsing position means we are passing an address as a parameter in D7 to HEX_TO_ASCII
000011E4  4EB9 000015D0            343              JSR       HEX_TO_ASCII
000011EA  6000 0022                344              BRA       FINISH_PRINT
000011EE                           345  
000011EE                           346  PRINT_LONG:
000011EE                           347m             CLR_D_REGS
000011FE  123C 0003                348              MOVE.B    #3, D1            * passing 1 means we are passing long as a parameter to HEX_TO_ASCII
00001202  2E0A                     349              MOVE.L    A2, D7
00001204  4EB9 000015D0            350              JSR       HEX_TO_ASCII
0000120A  6000 0002                351              BRA       FINISH_PRINT
0000120E                           352  
0000120E                           353  FINISH_PRINT:
0000120E                           354              * print out string
0000120E  12BC 0000                355              MOVE.B    #00,(A1)
00001212                           356m             CLR_D_REGS
00001222                           357m             CLR_A_REG D0, A1
00001226  103C 000E                358              MOVE.B    #14, D0
0000122A  4E4F                     359              TRAP      #15
0000122C  4E75                     360              RTS
0000122E                           361  *-----------------------------------------------------------
0000122E                           362  
0000122E                           363  *-------------------PRINT_INSTRUCTION-----------------------
0000122E                           364  PRINT_INSTRUCTION:    
0000122E                           365              * null terminator
0000122E  12BC 0000                366              MOVE.B    #00,(A1)              
00001232                           367  
00001232                           368              * reset A1 to beginning of string
00001232  4280                     369              CLR.L     D0
00001234                           370m             CLR_A_REG D0, A1
00001238                           371  
00001238                           372              * print out string
00001238  103C 000E                373              MOVE.B    #14, D0
0000123C  4E4F                     374              TRAP      #15
0000123E                           375  
0000123E                           376m             PRINT_MSG newline
0000124A  4E75                     377              RTS
0000124C                           378  *-----------------------------------------------------------
0000124C                           379  
0000124C                           380  
0000124C                           381  
0000124C                           382  
0000124C                           383  
0000124C                           384  
0000124C                           385  
0000124C                           386  
0000124C                           387  
0000124C                           388  
0000124C                           389  
0000124C                           390  *---------------------LOAD ADDRESSES------------------------
0000124C                           391  * Description:
0000124C                           392  * Stores INITIAL values into appropriate address registers 
0000124C                           393  * which is necessary to complete before starting identify opcodes loop
0000124C                           394  * Also pushes reigsters onto the stack
0000124C                           395  *
0000124C                           396  * No Parameters
0000124C                           397  *
0000124C                           398  * Registers:
0000124C                           399  *   A2 = current address (given by user)
0000124C                           400  *   A3 = ending address (given by user)
0000124C                           401  *-----------------------------------------------------------
0000124C                           402  LOAD_ADDRESSES: 
0000124C                           403              * reset A1 to beginning of string
0000124C  4280                     404              CLR.L     D0
0000124E                           405m             CLR_A_REG D0, A1
00001252                           406  
00001252                           407              * load start and end registers and print starting address
00001252  2478 106A                408              MOVEA.L startAddr, A2
00001256  2678 106E                409              MOVEA.L endAddr, A3
0000125A  6100 FF44                410              BSR     PRINT_ADDRESS
0000125E  4EB9 0000163C            411              JSR     INSERT_SPACE
00001264                           412  
00001264  6100 0042                413              BSR     GRAB_NEXT_WORD
00001268  6100 0044                414              BSR     GRAB_FIRST_FOUR_BITS     ; grabs that opcode's ID (first four bits)
0000126C                           415  
0000126C                           416              * Push current registers onto the stack (so we can have fresh registers)
0000126C  48E7 FF00                417              MOVEM.L D0-D7,-(SP)              ; move the old registers onto the stack
00001270  6000 004E                418              BRA     FIND_OPCODE
00001274                           419  *-----------------------------------------------------------
00001274                           420  
00001274                           421  *-----------------------------------------------------------
00001274                           422  * Description:  IDENTIFY OPCODES LOOP
00001274                           423  * Registers:
00001274                           424  *   D0 = used for tasks and trap #15
00001274                           425  *   D1 = size of shifting bits
00001274                           426  *   D2 = destination for shifts
00001274                           427  *   D3 = size of opcode
00001274                           428  *   D4 = used to hold bits returned from SHIFT macro
00001274                           429  *   D7 = holds address (word in length)
00001274                           430  *   A1 = used for task 14 (printing out strings to screen) and trap #15
00001274                           431  *   A2 = current address (given by user)
00001274                           432  *   A3 = ending address (given by user)
00001274                           433  *-----------------------------------------------------------
00001274                           434  *-------------------IDENTIFY OPCODES------------------------
00001274                           435  * evaluates an opcode based on first four bits (aka opTag)
00001274                           436  * for now only works with one instruction
00001274                           437  *-----------------------------------------------------------
00001274                           438  IDENTIFY_OPCODE:
00001274                           439  
00001274                           440              * print opcode
00001274  61B8                     441              BSR     PRINT_INSTRUCTION
00001276                           442  
00001276                           443              * check to see if we are done (start address >= end address)
00001276  B5CB                     444              CMPA.L  A3, A2
00001278  6C00 0402                445              BGE     DONE
0000127C                           446              
0000127C                           447              * print next address
0000127C  6100 FF22                448              BSR     PRINT_ADDRESS
00001280  4EB9 0000163C            449              JSR     INSERT_SPACE
00001286                           450              
00001286                           451              ;BSR     RESTORE_REGS           need to fix
00001286                           452  
00001286                           453m             CLR_D_REGS
00001296  6100 0010                454              BSR     GRAB_NEXT_WORD          * grab opcode
0000129A  6100 0012                455              BSR     GRAB_FIRST_FOUR_BITS    * grabs that opcode's ID (first four bits)
0000129E                           456             
0000129E  6000 0020                457              BRA     FIND_OPCODE
000012A2                           458  *-----------------------------------------------------------
000012A2                           459  
000012A2                           460  *----------------------RESTORE_REGS--------------------------
000012A2                           461  * Description:
000012A2                           462  * Move the old registers onto the stack
000012A2                           463  RESTORE_REGS:
000012A2  4CDF 00FF                464              MOVEM.L (SP)+, D0-D7            
000012A6  4E75                     465              RTS
000012A8                           466  *-----------------------------------------------------------
000012A8                           467  
000012A8                           468  *---------Useful Subroutines For Identifying Opcodes--------
000012A8                           469  GRAB_NEXT_WORD:
000012A8                           470              * load current word of bits into D7
000012A8  31DA 107A                471              MOVE.W (A2)+, opcode
000012AC  4E75                     472              RTS
000012AE                           473  
000012AE                           474  GRAB_FIRST_FOUR_BITS:
000012AE                           475              * find first four bits of opcode
000012AE  3438 107A                476              MOVE.W  opcode, D2
000012B2  123C 000C                477              MOVE.B  #12, D1
000012B6  E2AA                     478              LSR.L   D1, D2
000012B8  1002                     479              MOVE.B  D2, D0
000012BA  11C0 107C                480              MOVE.B  D0, opTag
000012BE  4E75                     481              RTS
000012C0                           482  *-----------------------------------------------------------
000012C0                           483  
000012C0                           484  
000012C0                           485  
000012C0                           486  
000012C0                           487  
000012C0                           488  
000012C0                           489  
000012C0                           490  
000012C0                           491  
000012C0                           492  *----------------------FIND OPCODE--------------------------
000012C0                           493  * Description:
000012C0                           494  * Finds a matching opTag (first four bits of opcode) and 
000012C0                           495  * jumps to that opcode's encoding subroutine
000012C0                           496  *
000012C0                           497  * For example:
000012C0                           498  *               ADD's first four bits = 1101, so I put
000012C0                           499  *               CMP.B #%1101, D0
000012C0                           500  *
000012C0                           501  * No Parameters
000012C0                           502  *
000012C0                           503  * No Registers Used
000012C0                           504  *-----------------------------------------------------------        
000012C0                           505  FIND_OPCODE:
000012C0  0C38 0004 107C           506              CMP.B   #%0100, opTag 
000012C6  6700 002A                507              BEQ     OPC_0100
000012CA                           508  
000012CA  0C38 0009 107C           509              CMP.B   #%1001, opTag
000012D0  6700 00BA                510              BEQ     OPC_1001
000012D4                           511  
000012D4  0C38 000C 107C           512              CMP.B   #%1100, opTag
000012DA  6700 00C4                513              BEQ     OPC_1100
000012DE                           514  
000012DE  0C38 000D 107C           515              CMP.B   #%1101, opTag
000012E4  6700 00E2                516              BEQ     OPC_1101
000012E8                           517  
000012E8                           518              * error, bad opcode
000012E8  6000 0002                519              BRA      BAD_OPCODE
000012EC                           520  
000012EC                           521  *-----------------------------------------------------------
000012EC                           522  
000012EC                           523  *-----------------------BAD OPCODE--------------------------
000012EC                           524  BAD_OPCODE:
000012EC  4EF9 0000167C            525              JMP      DONE
000012F2                           526  *-----------------------------------------------------------
000012F2                           527  
000012F2                           528  *------------------------OPC_0100---------------------------
000012F2                           529  * First four bits = 0100
000012F2                           530  * (NOP, NOT, MOVEM, JSR, RTS, LEA) 
000012F2                           531  *-----------------------------------------------------------
000012F2                           532  OPC_0100:
000012F2                           533  
000012F2                           534              ;Check if the opcode is NOP
000012F2  3438 107A                535              MOVE.W  opcode, D2          ;Copy opcode to D2
000012F6  B47C 4E71                536              CMP.W   #$4E71, D2          ;Check if D2 is equal to NOP (0x4E71 in hex)
000012FA  6700 0038                537              BEQ     OPC_NOP             ;If equal branch to label to handle the opcode NOP
000012FE                           538              
000012FE                           539              ;Check if the opcode is NOT
000012FE  E082                     540              ASR.L   #8, D2 ;Shift bits to compare
00001300  B43C 0046                541              CMP.B   #%01000110, D2
00001304  6700 003E                542              BEQ     OPC_NOT
00001308  4282                     543              CLR.L   D2
0000130A                           544              
0000130A                           545              ;Check if the opcode is LEA
0000130A  3838 107A                546              MOVE.W  opcode, D4 ;Put opcode in D4 to use the macro get bits
0000130E                           547m             GET_BITS #8, #6 
0000130E                           548m             * SUBTRACT VALUE TO FIND AMOUNT TO SHIFT BY 
00001314                           549m             * GET HIGH BIT OFFSET
0000131A                           550m             * SHIFT OUT HIGH BITS
00001320                           551m             *GET LOW BIT OFFSET
00001320                           552m             *16 - NUMBER OF BITS WE WANT
00001326                           553m             * SHIFT OUT LOW BITS
00001328  B83C 0007                554              CMP.B #%00000111, D4 ;if bits 6-8 are equal to 111, then the opocde is LEA
0000132C  6700 0052                555              BEQ     OPC_LEA
00001330  4282                     556              CLR.L   D2 ;If opcode doesn't match clear appropriate registers 
00001332  4284                     557              CLR.L   D4
00001334                           558  
00001334                           559  OPC_NOP:
00001334                           560              * Put NOP into A1 buffer for printing
00001334  12FC 004E                561              MOVE.B  #'N',(A1)+      
00001338  12FC 004F                562              MOVE.B  #'O',(A1)+ 
0000133C  12FC 0050                563              MOVE.B  #'P',(A1)+ 
00001340                           564              
00001340  6000 FF32                565              BRA     IDENTIFY_OPCODE
00001344                           566  
00001344                           567  
00001344                           568  OPC_NOT:
00001344                           569              * Put NOT into A1 buffer for printing
00001344  12FC 004E                570              MOVE.B  #'N',(A1)+ 
00001348  12FC 004F                571              MOVE.B  #'O',(A1)+
0000134C  12FC 0054                572              MOVE.B  #'T',(A1)+
00001350  12FC 002E                573              MOVE.B  #'.',(A1)+
00001354                           574              
00001354                           575              * Calculate Size (.b,.w.l)
00001354  4EB9 0000136A            576              JSR     GET_NOT_SIZE
0000135A  4EB9 00001642            577              JSR     SIZE_TO_BUFFER 
00001360  4EB9 00001474            578              JSR     GET_EA_MODE
00001366  6000 FF0C                579              BRA     IDENTIFY_OPCODE
0000136A                           580              
0000136A                           581  GET_NOT_SIZE:
0000136A  4282                     582              CLR.L   D2
0000136C  3438 107A                583              MOVE.W  opcode, D2
00001370                           584  
00001370                           585              * shift left to get rid of opTag
00001370  123C 0008                586              MOVE.B  #8, D1
00001374  E36A                     587              LSL.W   D1, D2
00001376                           588  
00001376                           589              * shift right to get rid of opmode, mode, and register bits
00001376  123C 000E                590              MOVE.B  #14, D1
0000137A  E26A                     591              LSR.W   D1, D2
0000137C                           592  
0000137C                           593              * store in appropriate register
0000137C  1602                     594              MOVE.B  D2, D3
0000137E  4E75                     595              RTS
00001380                           596  
00001380                           597  OPC_LEA:
00001380  12FC 004C                598              MOVE.B  #'L',(A1)+      
00001384  12FC 0045                599              MOVE.B  #'E',(A1)+ 
00001388  12FC 0041                600              MOVE.B  #'A',(A1)+     
0000138C                           601               
0000138C                           602  
0000138C                           603              
0000138C                           604  *-----------------------------------------------------------
0000138C                           605  
0000138C                           606  *-----------------------OPC_1001----------------------------
0000138C                           607  * First four bits = 1001
0000138C                           608  * (SUB)
0000138C                           609  *-----------------------------------------------------------
0000138C                           610  OPC_1001:
0000138C                           611              * fill in A1 register
0000138C  12FC 0053                612              MOVE.B  #'S',(A1)+          * Put ADD into Buff
00001390  12FC 0055                613              MOVE.B  #'U',(A1)+
00001394  12FC 0042                614              MOVE.B  #'B',(A1)+
00001398  12FC 002E                615              MOVE.B  #'.',(A1)+
0000139C  6000 003E                616              BRA     PROCESS_ROEA
000013A0                           617  *-----------------------------------------------------------
000013A0                           618  
000013A0                           619  *-----------------------OPC_1100----------------------------
000013A0                           620  * First four bits = 1100
000013A0                           621  * (AND, MULS)
000013A0                           622  *-----------------------------------------------------------
000013A0                           623  OPC_1100:   ; AND opcode subroutine
000013A0                           624              
000013A0                           625              ; check to see if bits 8-6 are 111
000013A0                           626              ; if they are, then branch to PARSE_MULS
000013A0                           627              ; else, keep going to parse AND
000013A0                           628  
000013A0                           629  OPC_AND:
000013A0                           630              ; fill A1 with the opcode name
000013A0  12FC 0041                631              MOVE.B  #'A',(A1)+
000013A4  12FC 004E                632              MOVE.B  #'N',(A1)+
000013A8  12FC 0044                633              MOVE.B  #'D',(A1)+
000013AC  12FC 002E                634              MOVE.B  #'.',(A1)+
000013B0  6000 002A                635              BRA     PROCESS_ROEA
000013B4                           636  
000013B4                           637  OPC_MULS:
000013B4                           638              ; load the command name into the output
000013B4  12FC 004D                639              MOVE.B  #'M',(A1)+
000013B8  12FC 0055                640              MOVE.B  #'U',(A1)+
000013BC  12FC 004C                641              MOVE.B  #'L',(A1)+
000013C0  12FC 0053                642              MOVE.B  #'S',(A1)+
000013C4  12FC 002E                643              MOVE.B  #'.',(A1)+
000013C8                           644  
000013C8                           645  
000013C8                           646  *---------------------------opc_1101------------------------
000013C8                           647  * First four bits = 1101
000013C8                           648  * (ADD)
000013C8                           649  *-----------------------------------------------------------
000013C8                           650  OPC_1101:
000013C8                           651              * fill in A1 register
000013C8  12FC 0041                652              MOVE.B  #'A',(A1)+          * Put ADD into Buff
000013CC  12FC 0044                653              MOVE.B  #'D',(A1)+
000013D0  12FC 0044                654              MOVE.B  #'D',(A1)+
000013D4  12FC 002E                655              MOVE.B  #'.',(A1)+
000013D8  6000 0002                656              BRA     PROCESS_ROEA        * subroutine processes everything for ADD
000013DC                           657  
000013DC                           658  *-----------------------------------------------------------
000013DC                           659  
000013DC                           660  
000013DC                           661  
000013DC                           662  
000013DC                           663  
000013DC                           664  
000013DC                           665  
000013DC                           666  
000013DC                           667  
000013DC                           668  
000013DC                           669  *--------------Process Register->Opmode->EA-----------------
000013DC                           670  * Description:
000013DC                           671  * Parses bits for opcodes that share bit placements:
000013DC                           672  * ROEA stands for Register, Opmode, and Effective Address,
000013DC                           673  * because the opcodes below share this bit order.
000013DC                           674  *
000013DC                           675  * Used by: (ADD, SUB, MULS)
000013DC                           676  *
000013DC                           677  *-----------------------------------------------------------
000013DC                           678  PROCESS_ROEA:
000013DC  4EB9 0000142A            679              JSR     GET_SIZE
000013E2  4EB9 00001642            680              JSR     SIZE_TO_BUFFER
000013E8  4EB9 00001440            681              JSR     OPMODE_TYPE         * 0 or 1 value (either <ea> -> Dn or Dn -> <ea>)  
000013EE  B83C 0001                682              CMP.B   #1, D4              * is this Dn + <ea> -> <ea>?
000013F2  6700 0006                683              BEQ     D_TO_EA
000013F6  6600 0016                684              BNE     EA_TO_D
000013FA                           685  
000013FA                           686  D_TO_EA:
000013FA  4EB9 00001454            687              JSR     GET_DATA_REG_NUM
00001400  12FC 002C                688              MOVE.B  #',',(A1)+
00001404  4EB9 00001474            689              JSR     GET_EA_MODE
0000140A  6000 0016                690              BRA     ROEA_DONE
0000140E                           691  
0000140E                           692  EA_TO_D:
0000140E  4EB9 00001474            693              JSR     GET_EA_MODE
00001414  12FC 002C                694              MOVE.B  #',',(A1)+
00001418  4EB9 00001454            695              JSR     GET_DATA_REG_NUM
0000141E  6000 0002                696              BRA     ROEA_DONE
00001422                           697  
00001422                           698  ROEA_DONE:
00001422  12FC 0020                699              MOVE.B  #' ',(A1)+
00001426  6000 FE4C                700              BRA     IDENTIFY_OPCODE
0000142A                           701              
0000142A                           702  
0000142A                           703  GET_SIZE:
0000142A  4282                     704              CLR.L   D2
0000142C  3438 107A                705              MOVE.W  opcode ,D2          ; copy current instruction to shift
00001430                           706              
00001430                           707              * shift left to get rid of opTag
00001430  123C 0008                708              MOVE.B  #8, D1
00001434  E36A                     709              LSL.W   D1, D2
00001436                           710  
00001436                           711              * shift right to get rid of opmode, mode, and register bits
00001436  123C 000E                712              MOVE.B  #14, D1
0000143A  E26A                     713              LSR.W   D1, D2
0000143C                           714  
0000143C                           715              * store in appropriate register
0000143C  1602                     716              MOVE.B  D2, D3
0000143E                           717              
0000143E  4E75                     718              RTS
00001440                           719  
00001440                           720  OPMODE_TYPE:
00001440                           721              * D3 should hold the size of the opcode operation
00001440  4282                     722              CLR.L   D2
00001442  3403                     723              MOVE.W  D3, D2
00001444                           724  
00001444                           725              * shift left to identify
00001444  123C 0007                726              MOVE.B  #7, D1
00001448  E36A                     727              LSL.W   D1, D2
0000144A                           728              
0000144A                           729              * shift left to identify
0000144A  123C 000F                730              MOVE.B  #15, D1
0000144E  E26A                     731              LSR.W   D1, D2
00001450                           732  
00001450                           733              * store in appropriate register
00001450  1802                     734              MOVE.B  D2, D4
00001452                           735  
00001452  4E75                     736              RTS
00001454                           737  
00001454                           738  GET_DATA_REG_NUM:
00001454                           739              * D3 should hold the size of the opcode operation
00001454  4282                     740              CLR.L   D2
00001456  3438 107A                741              MOVE.W  opcode, D2  
0000145A                           742  
0000145A                           743              * shift left to identify
0000145A  123C 0004                744              MOVE.B  #4, D1
0000145E  E36A                     745              LSL.W   D1, D2
00001460                           746              
00001460                           747              * shift right to isolate high register bits
00001460  123C 000D                748              MOVE.B  #13, D1
00001464  E26A                     749              LSR.W   D1, D2
00001466                           750  
00001466                           751              * store in appropriate register
00001466  12FC 0044                752              MOVE.B  #'D',(A1)+              * add "D" to buffer
0000146A  0602 0030                753              ADD.B   #$30,D2                   * convert data register # to hex digit
0000146E  12C2                     754              MOVE.B  D2,(A1)+                * register # to buffer             
00001470  1C02                     755              MOVE.B  D2, D6
00001472                           756  
00001472  4E75                     757              RTS
00001474                           758  
00001474                           759  
00001474                           760  
00001474                           761  
00001474                           762  
00001474                           763  
00001474                           764  
00001474                           765  
00001474                           766  
00001474                           767  *----------------------------GET_EA_MODE------------------------
00001474                           768  * Description:
00001474                           769  * Evaluates the ea mode and register of an opcode 
00001474                           770  * (usually last 6 bits of instruction format),
00001474                           771  * and adds it to A1 to be printed out
00001474                           772  *
00001474                           773  * No Parameters
00001474                           774  *
00001474                           775  * Registers Used:
00001474                           776  *   D1 = amount to shift the opcode
00001474                           777  *   D2 = destination for shifts
00001474                           778  *   D5 = addressing mode
00001474                           779  *-----------------------------------------------------------
00001474                           780  GET_EA_MODE:
00001474                           781m             CLR_D_REGS
00001484                           782              * move size of opcode to be manipulated
00001484  4282                     783              CLR.L   D2
00001486  3438 107A                784              MOVE.W  opcode, D2     
0000148A                           785  
0000148A                           786              * shift left to identify
0000148A  123C 000A                787              MOVE.B  #10, D1
0000148E  E36A                     788              LSL.W   D1, D2
00001490                           789              
00001490                           790              * shift right to isolate mode bits for EA 
00001490  123C 000D                791              MOVE.B  #13, D1
00001494  E26A                     792              LSR.W   D1, D2
00001496                           793  
00001496                           794              * store in appropriate register
00001496  1A02                     795              MOVE.B  D2, D5
00001498                           796              
00001498  6000 0002                797              BRA     FIND_MODE
0000149C                           798  
0000149C                           799  *----------------------------FIND_MODE------------------------
0000149C                           800  FIND_MODE:                            
0000149C  BA3C 0000                801              CMP.B   #%0000, D5        * Direct Data Register
000014A0  6700 003E                802              BEQ     ea_000
000014A4                           803  
000014A4  BA3C 0001                804              CMP.B   #%0001, D5        * Direct Address Register
000014A8  6700 004E                805              BEQ     ea_001
000014AC                           806  
000014AC  BA3C 0002                807              CMP.B   #%0010, D5        * Indirect Address Register
000014B0  6700 005E                808              BEQ     ea_010
000014B4                           809  
000014B4  BA3C 0003                810              CMP.B   #%0011, D5        * Post Increment
000014B8  6700 0076                811              BEQ     ea_011
000014BC                           812  
000014BC  BA3C 0004                813              CMP.B   #%0100, D5        * Pre Decrement
000014C0  6700 0092                814              BEQ     ea_100
000014C4                           815  
000014C4  BA3C 0005                816              CMP.B   #%0101, D5        * Not necessary, go to bad ea
000014C8  6700 00AE                817              BEQ     ea_101
000014CC                           818  
000014CC  BA3C 0006                819              CMP.B   #%0110, D5        * Not necessary, go to bad ea
000014D0  6700 00AA                820              BEQ     ea_110
000014D4                           821  
000014D4  BA3C 0007                822              CMP.B   #%0111, D5        * Absolute or immediate address
000014D8  6700 00A6                823              BEQ     ea_111
000014DC                           824  
000014DC  6000 00EC                825              BRA    INVALID_EA
000014E0                           826  
000014E0                           827  *----------------------------Direct Data Register------------------------
000014E0                           828  ea_000:
000014E0  3438 107A                829              MOVE.W      opcode, D2              * move current working word into temp storage
000014E4  12FC 0044                830              MOVE.B      #'D',(A1)+              * add "D" to buffer
000014E8                           831              
000014E8  123C 000D                832              MOVE.B      #13, D1
000014EC  E36A                     833              LSL.W       D1,D2                   * isolate register bits (last 3)
000014EE  E26A                     834              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
000014F0  0602 0030                835              ADD.B       #$30,D2                 * convert data register # to ASCII digit
000014F4                           836  
000014F4  12C2                     837              MOVE.B      D2,(A1)+                * register # to buffer                  
000014F6                           838              
000014F6  4E75                     839              RTS                                
000014F8                           840  
000014F8                           841  *----------------------------Direct Address Register------------------------
000014F8                           842  ea_001:
000014F8  3438 107A                843              MOVE.W      opcode, D2              * move current working word into temp storage
000014FC  12FC 0041                844              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001500                           845              
00001500  123C 000D                846              MOVE.B      #13, D1
00001504  E36A                     847              LSL.W       D1,D2                   * isolate register bits (last 3)
00001506  E26A                     848              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
00001508  0602 0030                849              ADD.B       #$30,D2                 * convert data register # to ASCII digit
0000150C                           850  
0000150C  12C2                     851              MOVE.B      D2,(A1)+                * register # to buffer               
0000150E                           852                
0000150E  4E75                     853              RTS                            
00001510                           854  
00001510                           855  *----------------------------Indirect Address Register------------------------
00001510                           856  ea_010:
00001510  3438 107A                857              MOVE.W      opcode, D2              * move current working word into temp storage
00001514  12FC 0028                858              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001518  12FC 0041                859              MOVE.B      #'A',(A1)+              * add "A" to buffer
0000151C                           860  
0000151C  123C 000D                861              MOVE.B      #13, D1
00001520  E36A                     862              LSL.W       D1,D2                   * isolate register bits (last 3)
00001522  E26A                     863              LSR.W       D1,D2                   * D2 now holds the mode of the opcode
00001524  0602 0030                864              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001528  12C2                     865              MOVE.B      D2,(A1)+                * register # to buffer     
0000152A                           866  
0000152A  12FC 0029                867              MOVE.B      #')',(A1)+              * add ")" to buffer
0000152E                           868               
0000152E  4E75                     869              RTS                            
00001530                           870  
00001530                           871  *----------------------------Post Increment------------------------
00001530                           872  ea_011:
00001530  3438 107A                873              MOVE.W      opcode, D2              * move current working word into temp storage
00001534                           874  
00001534  12FC 0028                875              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001538  12FC 0041                876              MOVE.B      #'A',(A1)+              * add "A" to buffer
0000153C                           877              
0000153C  123C 000D                878              MOVE.B      #13, D1
00001540  E36A                     879              LSL.W       D1,D2                   * isolate register bits (last 3)
00001542  E26A                     880              LSR.W       D1,D2                  
00001544  0602 0030                881              ADD.B       #$30,D2                 * convert data register # to ASCII digit
00001548  12C2                     882              MOVE.B      D2,(A1)+                * register # to buffer     
0000154A                           883  
0000154A  12FC 0029                884              MOVE.B      #')',(A1)+              * add ")" to buffer
0000154E  12FC 002B                885              MOVE.B      #'+',(A1)+              * add "+" to buffer
00001552                           886                   
00001552  4E75                     887              RTS                              
00001554                           888  
00001554                           889  *----------------------------Pre Decrement------------------------
00001554                           890  ea_100:
00001554  3438 107A                891              MOVE.W      opcode, D2              * move current working word into temp storage
00001558                           892  
00001558  12FC 002D                893              MOVE.B      #'-',(A1)+              * add "-" to buffer
0000155C  12FC 0028                894              MOVE.B      #'(',(A1)+              * add "(" to buffer
00001560  12FC 0041                895              MOVE.B      #'A',(A1)+              * add "A" to buffer
00001564                           896              
00001564  123C 000D                897              MOVE.B      #13, D1
00001568  E36A                     898              LSL.W       D1, D2                   * isolate register bits (last 3)
0000156A  E26A                     899              LSR.W       D1, D2                   * D2 now holds the mode of the opcode
0000156C  0602 0030                900              ADD.B       #$30, D2                 * convert data register # to ASCII digit
00001570  12C2                     901              MOVE.B      D2, (A1)+                * register # to buffer     
00001572                           902  
00001572  12FC 0029                903              MOVE.B      #')',(A1)+               * add ")" to buffer
00001576                           904              
00001576  4E75                     905              RTS
00001578                           906  
00001578                           907  *----------------------------Not necessary, go to bad ea------------------------
00001578                           908  ea_101:
00001578  6000 0050                909              BRA         INVALID_EA        
0000157C                           910  
0000157C                           911  
0000157C                           912  *----------------------------Not necessary, go to bad ea------------------------
0000157C                           913  ea_110:
0000157C  6000 004C                914              BRA         INVALID_EA        
00001580                           915  
00001580                           916  
00001580                           917  *----------------------------Absolute or immediate address------------------------
00001580                           918  ea_111:
00001580                           919              * D405      0 0003456  23345245
00001580                           920              * ADD.L     $1234, D0
00001580                           921  
00001580                           922              * 8 bit value
00001580                           923              * 11111111
00001580                           924  
00001580                           925              * 11111011 - Direct data register would be Invalid
00001580                           926              * 00000100
00001580                           927              * 00000000 -> invalid code
00001580                           928  
00001580                           929              * and.b     #$F, Dn        ---->  10000000
00001580                           930              * cmp.b     #%10000000, Dn  
00001580                           931  
00001580                           932              * check against valid bits
00001580                           933                  * if invalid, branch to invalid opcode subroutine
00001580                           934                      * if the mode is 111, then go back and print out addresses
00001580                           935  
00001580  12FC 0024                936              MOVE.B      #'$', (A1)+
00001584  3438 107A                937              MOVE.W      opcode, D2
00001588  123C 000F                938              MOVE.B      #15, D1
0000158C  E36A                     939              LSL.W       D1, D2                   * isolate register bits (last 3)
0000158E  E26A                     940              LSR.W       D1, D2                   * isolate register bits (last 3)
00001590                           941              ;ADD.B       #$30, D2                 * convert data register # to ASCII digit
00001590                           942  
00001590  B43C 0000                943              CMP.B       #%0000, D2               * compare to determine if it's a word
00001594  6700 0012                944              BEQ         EA_WORD                 * put word address in buffer
00001598                           945  
00001598  B43C 0001                946              CMP.B       #%0001, D2               * compare to determine if it's a long
0000159C  6700 001A                947              BEQ         EA_LONG                 * put long address in buffer
000015A0                           948              
000015A0  B43C 0004                949              CMP.B       #%0100, D2
000015A4  6700 0022                950              BEQ         EA_IMMEDIATE
000015A8                           951  
000015A8                           952              * NEED TO WORK ON IMMEDIATE
000015A8                           953  
000015A8                           954  EA_WORD:
000015A8  4281                     955              CLR.L       D1
000015AA  123C 0001                956              MOVE.B      #1, D1
000015AE  3E1A                     957              MOVE.W      (A2)+, D7
000015B0  6100 001E                958              BSR         HEX_TO_ASCII
000015B4  6000 0012                959              BRA         GET_EA_DONE
000015B8                           960  
000015B8                           961  EA_LONG:
000015B8  4281                     962              CLR.L       D1
000015BA  123C 0003                963              MOVE.B      #3, D1
000015BE  2E1A                     964              MOVE.L      (A2)+, D7   
000015C0  6100 000E                965              BSR         HEX_TO_ASCII
000015C4  6000 0002                966              BRA         GET_EA_DONE
000015C8                           967  
000015C8                           968  EA_IMMEDIATE:
000015C8                           969              * NEED TO WRITE
000015C8                           970  
000015C8                           971  
000015C8                           972  GET_EA_DONE:
000015C8  4E75                     973              RTS
000015CA                           974  
000015CA                           975  *------------------Invalid Effective Address----------------
000015CA                           976  INVALID_EA:
000015CA  4EF9 0000167C            977              JMP      DONE
000015D0                           978  *-----------------------------------------------------------
000015D0                           979  
000015D0                           980  
000015D0                           981  
000015D0                           982  
000015D0                           983  
000015D0                           984  
000015D0                           985  
000015D0                           986  
000015D0                           987  *----------------------HEX TO ASCII-------------------------
000015D0                           988  * Description:
000015D0                           989  * Converts a Hex numbered address (1-9 or A-F) back to an
000015D0                           990  * ASCII value for printing
000015D0                           991  *
000015D0                           992  * Parameters (if calling HEX_TO_ASCII (always used by print subroutine)):
000015D0                           993  *   D1 = pass in 1 if the address is a word, pass in 3 if address is a long
000015D0                           994  *   D7 = holds the original address to parse (either word or long, for example: $7000)
000015D0                           995  *
000015D0                           996  * Parameters (if calling NUMBER_OR_LETTER (usually done in opcode sections)):
000015D0                           997  *   D2 = should hold value (in hex) you want to push to the buffer
000015D0                           998  *
000015D0                           999  * Registers Used:
000015D0                          1000  *   D0 = number of bits to remove
000015D0                          1001  *   D2 = holds either top four bits or bottom four bits of each byte in D6
000015D0                          1002  *   D3 = holds temp data
000015D0                          1003  *   D6 = holds part of address (used as temp variable)
000015D0                          1004  *   A1 = used for buffer
000015D0                          1005  *-----------------------------------------------------------
000015D0                          1006  HEX_TO_ASCII:
000015D0  1001                    1007              MOVE.B   D1, D0             * current number of bytes to remove
000015D2  C1FC 0008               1008              MULS.W   #8, D0             * number of bits to remove
000015D6                          1009  
000015D6  2C07                    1010              MOVE.L   D7, D6             * load original address to parse
000015D8  E0AE                    1011              LSR.L    D0, D6             * remove lowest byte(s)
000015DA                          1012  
000015DA                          1013              * isolate first four bits
000015DA  1406                    1014              MOVE.B   D6, D2
000015DC  E80A                    1015              LSR.B    #4, D2 
000015DE  6100 0018               1016              BSR      NUMBER_OR_LETTER
000015E2                          1017  
000015E2                          1018              * isolate second set of four bits
000015E2  1406                    1019              MOVE.B   D6, D2
000015E4  E90A                    1020              LSL.B    #4, D2 
000015E6  E80A                    1021              LSR.B    #4, D2 
000015E8  6100 000E               1022              BSR      NUMBER_OR_LETTER
000015EC                          1023  
000015EC  5301                    1024              SUB.B    #1, D1             * iterate
000015EE  B23C 0000               1025              CMP.B    #0, D1             * done if equal
000015F2  6D00 0036               1026              BLT      ATH_DONE
000015F6                          1027  
000015F6  60D8                    1028              BRA      HEX_TO_ASCII
000015F8                          1029  
000015F8                          1030  NUMBER_OR_LETTER:
000015F8  1602                    1031              MOVE.B   D2, D3
000015FA  0603 0030               1032              ADD.B    #$30, D3           
000015FE  B63C 0039               1033              CMP.B    #$39, D3           * is byte in D2 a number?
00001602  6F00 0012               1034              BLE      NUMBER_TO_ASCII
00001606                          1035              
00001606  1602                    1036              MOVE.B   D2, D3
00001608  0603 0037               1037              ADD.B    #$37, D3           
0000160C  B63C 0039               1038              CMP.B    #$39, D3           * is byte in D2 a letter?
00001610  6C00 000C               1039              BGE      LETTER_TO_ASCII
00001614                          1040  
00001614  60B4                    1041              BRA      INVALID_EA
00001616                          1042  
00001616                          1043  NUMBER_TO_ASCII:
00001616  0602 0030               1044              ADD.B    #$30, D2           * Get the hex range from '0-9'
0000161A  6000 000A               1045              BRA      ADD_TO_BUFFER
0000161E                          1046  
0000161E                          1047  LETTER_TO_ASCII:
0000161E  0602 0037               1048              ADD.B    #$37, D2           * Get the hex range from 'A-F'
00001622  6000 0002               1049              BRA      ADD_TO_BUFFER
00001626                          1050  
00001626                          1051  ADD_TO_BUFFER:
00001626  12C3                    1052              MOVE.B   D3, (A1)+          * add part of address to buffer    
00001628  4E75                    1053              RTS
0000162A                          1054  
0000162A                          1055  ATH_DONE:
0000162A                          1056m             CLR_D_REGS
0000163A  4E75                    1057              RTS
0000163C                          1058  *-----------------------------------------------------------
0000163C                          1059  
0000163C                          1060  INSERT_SPACE:
0000163C  12FC 0020               1061              MOVE.B  #' ',(A1)+          * add blank space to buffer
00001640  4E75                    1062              RTS
00001642                          1063  
00001642                          1064  
00001642                          1065  
00001642                          1066  
00001642                          1067  
00001642                          1068  
00001642                          1069  
00001642                          1070  
00001642                          1071  
00001642                          1072  *---------------------SIZE TO BUFFER------------------------
00001642                          1073  * Description:
00001642                          1074  * Evaluates the size of an opcode and adds it to A1 to be printed out
00001642                          1075  *
00001642                          1076  * Parameters:
00001642                          1077  *   D3 = size of opcode
00001642                          1078  *
00001642                          1079  * Registers Used:
00001642                          1080  *   A1: adding words/numbers to buffer
00001642                          1081  *-----------------------------------------------------------
00001642                          1082  SIZE_TO_BUFFER: 
00001642  B63C 0000               1083              CMP.B   #%0000,D3            
00001646  6700 0016               1084              BEQ     BYTE_TO_BUFFER              
0000164A                          1085  
0000164A  B63C 0001               1086              CMP.B   #%0001,D3             * is this a word?
0000164E  6700 0016               1087              BEQ     WORD_TO_BUFFER
00001652                          1088  
00001652  B63C 0002               1089              CMP.B   #%0010,D3             * is this a long?
00001656  6700 0016               1090              BEQ     LONG_TO_BUFFER             
0000165A                          1091        
0000165A  4EF8 12EC               1092              JMP     BAD_OPCODE  
0000165E                          1093              
0000165E                          1094  BYTE_TO_BUFFER:
0000165E  12FC 0042               1095              MOVE.B  #'B', (A1)+           * add B to buffer
00001662  6000 0012               1096              BRA     STB_END             
00001666                          1097              
00001666                          1098  WORD_TO_BUFFER:
00001666  12FC 0057               1099              MOVE.B  #'W', (A1)+          * add W to buffer
0000166A  6000 000A               1100              BRA     STB_END             
0000166E                          1101  
0000166E                          1102  LONG_TO_BUFFER:
0000166E  12FC 004C               1103              MOVE.B  #'L',(A1)+          * add L to buffer
00001672  6000 0002               1104              BRA     STB_END             
00001676                          1105  
00001676                          1106  STB_END:
00001676  12FC 0020               1107              MOVE.B  #' ',(A1)+          * add blank space to buffer
0000167A  4E75                    1108              RTS                         
0000167C                          1109  
0000167C                          1110  
0000167C                          1111  
0000167C                          1112  
0000167C                          1113  
0000167C                          1114  
0000167C                          1115  
0000167C                          1116  
0000167C                          1117  
0000167C                          1118  *-------------------------DONE-------------------------------
0000167C                          1119  DONE:
0000167C  4280                    1120              CLR.L     D0
0000167E  103C 000E               1121              MOVE.B    #14, D0
00001682  43F8 1045               1122              LEA.L     doneMsg, A1
00001686  4E4F                    1123              TRAP      #15
00001688                          1124m             CLR_A_REG D0, A1
0000168C                          1125  
0000168C                          1126              END       MAIN              ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD_TO_BUFFER       1626
ATH_DONE            162A
BADINPUT            1052
BAD_OPCODE          12EC
BYTE_TO_BUFFER      165E
CHECK_LENGTH        10DC
CLR_A_REG           171
CLR_D_REGS          9F
CONVERT_TO_HEX      110E
CR                  D
DONE                167C
DONEMSG             1045
D_TO_EA             13FA
EA_000              14E0
EA_001              14F8
EA_010              1510
EA_011              1530
EA_100              1554
EA_101              1578
EA_110              157C
EA_111              1580
EA_IMMEDIATE        15C8
EA_LONG             15B8
EA_TO_D             140E
EA_WORD             15A8
ENDADDR             106E
ENDMSG              1023
FIND_MODE           149C
FIND_OPCODE         12C0
FINISH_PRINT        120E
GET_BITS            1C5
GET_DATA_REG_NUM    1454
GET_EA_DONE         15C8
GET_EA_MODE         1474
GET_END_ADDRESS     10B2
GET_INPUT           1086
GET_NOT_SIZE        136A
GET_SIZE            142A
GET_START_ADDRESS   1098
GRAB_FIRST_FOUR_BITS  12AE
GRAB_NEXT_WORD      12A8
HEX_TO_ASCII        15D0
IDENTIFY_OPCODE     1274
INSERT_SPACE        163C
INVALID_EA          15CA
INVALID_INPUT       10F0
ITERATE             1142
LETTER_TO_ASCII     161E
LETTER_TO_HEX       1134
LF                  A
LOAD_ADDRESSES      124C
LONG_TO_BUFFER      166E
MAIN                107E
NEWLINE             1062
NUMBER_OR_LETTER    15F8
NUMBER_TO_ASCII     1616
NUM_TO_HEX          112C
OPCODE              107A
OPC_0100            12F2
OPC_1001            138C
OPC_1100            13A0
OPC_1101            13C8
OPC_AND             13A0
OPC_LEA             1380
OPC_MULS            13B4
OPC_NOP             1334
OPC_NOT             1344
OPMODE_TYPE         1440
OPOUTPUT            1072
OPTAG               107C
PRINT_ADDRESS       11A0
PRINT_INSTRUCTION   122E
PRINT_LONG          11EE
PRINT_MSG           0
PRINT_WORD          11CE
PROCESS_ROEA        13DC
RESTORE_REGS        12A2
ROEA_DONE           1422
SIZE_TO_BUFFER      1642
STARTADDR           106A
STARTMSG            1000
STB_END             1676
STORE_CHAR          113C
STORE_END           1180
STORE_INPUT         1150
STORE_START         1160
USERADDR            1066
VALID               107D
VALIDATE_INPUT      10CC
WORD_TO_BUFFER      1666
